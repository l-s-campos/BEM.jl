<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interpolação · BEM.jl</title><meta name="title" content="Interpolação · BEM.jl"/><meta property="og:title" content="Interpolação · BEM.jl"/><meta property="twitter:title" content="Interpolação · BEM.jl"/><meta name="description" content="Documentation for BEM.jl."/><meta property="og:description" content="Documentation for BEM.jl."/><meta property="twitter:description" content="Documentation for BEM.jl."/><meta property="og:url" content="https://l-s-campos.github.io/BEM.jl/02-interpola/"/><meta property="twitter:url" content="https://l-s-campos.github.io/BEM.jl/02-interpola/"/><link rel="canonical" href="https://l-s-campos.github.io/BEM.jl/02-interpola/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BEM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">BEM</a></li><li><a class="tocitem" href="../01-teoria/">Apresentação</a></li><li class="is-active"><a class="tocitem" href>Interpolação</a><ul class="internal"><li><a class="tocitem" href="#Interpolação-polinomial"><span>Interpolação polinomial</span></a></li><li class="toplevel"><a class="tocitem" href="#962.2387878787877"><span>962.2387878787877</span></a></li><li class="toplevel"><a class="tocitem" href="#24.12775468975476"><span>24.12775468975476</span></a></li><li class="toplevel"><a class="tocitem" href="#interpole-em-500-pontos-no-intervalo-[0,35]."><span>interpole em 500 pontos no intervalo [0,35].</span></a></li><li class="toplevel"><a class="tocitem" href="#avalie-o-polinômio-nesses-pontos"><span>avalie o polinômio nesses pontos</span></a></li><li><a class="tocitem" href="#Desafio"><span>Desafio</span></a></li></ul></li><li><a class="tocitem" href="../03-diferenciais/">Equações diferenciais</a></li><li><a class="tocitem" href="../10-exemplos/">Exemplos</a></li><li><a class="tocitem" href="../90-contributing/">Contributing guidelines</a></li><li><a class="tocitem" href="../91-developer/">Developer documentation</a></li><li><a class="tocitem" href="../95-reference/">Reference</a></li><li><a class="tocitem" href="../Viga de Euler/">Viga de euler</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interpolação</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interpolação</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/l-s-campos/BEM.jl/blob/master/docs/src/02-interpola.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Interpolação"><a class="docs-heading-anchor" href="#Interpolação">Interpolação</a><a id="Interpolação-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolação" title="Permalink"></a></h1><h2 id="Interpolação-polinomial"><a class="docs-heading-anchor" href="#Interpolação-polinomial">Interpolação polinomial</a><a id="Interpolação-polinomial-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolação-polinomial" title="Permalink"></a></h2><p>Suponha que queremos conhecer a população às vezes entre os anos do censo ou estimar populações futuras. Uma técnica é encontrar um polinômio que passa por todos os pontos de dados. </p><p>Dado <span>$n$</span> pontos <span>$(t_1, y_1), \ldots, (t_n, y_n)$</span>, onde os <span>$t_i$</span> são todos distintos, o problema <strong>de interpolação polinomial</strong> é encontrar um polinomial <span>$P$</span> de grau menor que n tal que <span>$p (t_i) = y_i$</span> para todos <span>$i$</span>.</p><p>O problema de interpolação polinomial tem uma solução única. Uma vez encontrado o polinômio interpolador, ele pode ser avaliado em qualquer lugar para estimar ou prever valores.</p><h3 id="**Interpolação-como-um-sistema-linear**"><a class="docs-heading-anchor" href="#**Interpolação-como-um-sistema-linear**"><strong>Interpolação como um sistema linear</strong></a><a id="**Interpolação-como-um-sistema-linear**-1"></a><a class="docs-heading-anchor-permalink" href="#**Interpolação-como-um-sistema-linear**" title="Permalink"></a></h3><p>Dados os dados <span>$(t_i, y_i)$</span> por <span>$i = 1, \ldots, n$</span>, buscamos um polinômio</p><p class="math-container">\[ p(t) = c_1 + c_{2} t + c_3t^2 +  \cdots + c_{n} t^{n-1},
\]</p><p>de tal modo que <span>$y_i=p(t_i)$</span> para todos <span>$i$</span>. Essas condições são usadas para determinar os coeficientes <span>$c_1\ldots,c_n$</span>:</p><p class="math-container">\[ c_1 + c_2 t_1 + \cdots + c_{n-1}t_1^{n-2} + c_nt_1^{n-1} = y_1, \\ c_1 + c_2 t_2 + \cdots + c_{n-1}t_2^{n-2} + c_nt_2^{n-1} = y_2, \\ c_1 + c_2 t_3 + \cdots + c_{n-1}t_3^{n-2} + c_nt_3^{n-1} = y_3, \\ \vdots \qquad  \\ c_1 + c_2 t_n + \cdots + c_{n-1}t_n^{n-2} + c_nt_n^{n-1} = y_n.\]</p><p>Essas equações formam um sistema linear para os coeficientes  <span>$c_i:$</span></p><p class="math-container">\[  \begin{bmatrix}
    1 &amp; t_1 &amp; \cdots &amp; t_1^{n-2} &amp; t_1^{n-1} \\
    1 &amp; t_2 &amp; \cdots &amp; t_2^{n-2} &amp; t_2^{n-1} \\
    1 &amp; t_3 &amp; \cdots &amp; t_3^{n-2} &amp; t_3^{n-1} \\
    \vdots &amp; \vdots &amp;  &amp; \vdots &amp; \vdots \\
    1 &amp; t_n &amp; \cdots &amp; t_n^{n-2} &amp; t_n^{n-1} \\
  \end{bmatrix}
  \begin{bmatrix}
    c_1  \\
    c_2  \\
    c_3 \\
    \vdots \\
    c_n
  \end{bmatrix}
  =
  \begin{bmatrix}
    y_1  \\
    y_2  \\
    y_3 \\
    \vdots \\
    y_n
  \end{bmatrix},
  ```

ou simplesmente, $\mathbf{V} \mathbf{c} = \mathbf{y}$. A Matrix $\mathbf{V}$ é de um tipo especial chamado de Vandermonde.

A interpolação polinomial pode, portanto, ser formulada como um sistema linear de equações com uma matriz de Vandermonde.
Criamos dois vetores para dados sobre a população da China. O primeiro tem os anos dos dados do censo e o outro tem a população, em milhões de pessoas.
\]</p><p>julia year = [1982,2000,2010,2015]; pop = [1008.18, 1262.64, 1337.82, 1374.62]; t = year .- 1980.0 y = pop; V = [ t[i]^j for i=1:4, j=0:3 ] #4×4 Matrix{Float64}:  #1.0   2.0     4.0      8.0  #1.0  20.0   400.0   8000.0  #1.0  30.0   900.0  27000.0  #1.0  35.0  1225.0  42875.0  c = V \ y   #4-element Vector{Float64}:</p><h1 id="962.2387878787877"><a class="docs-heading-anchor" href="#962.2387878787877">962.2387878787877</a><a id="962.2387878787877-1"></a><a class="docs-heading-anchor-permalink" href="#962.2387878787877" title="Permalink"></a></h1><h1 id="24.12775468975476"><a class="docs-heading-anchor" href="#24.12775468975476">24.12775468975476</a><a id="24.12775468975476-1"></a><a class="docs-heading-anchor-permalink" href="#24.12775468975476" title="Permalink"></a></h1><p>#-0.592262049062053    #0.006843867243867301</p><p>using Polynomials p = Polynomial(c)    p(2005-1980)         </p><pre><code class="nohighlight hljs">
O valor oficial da população para 2005 foi 1303,72, então nosso resultado é bastante bom.
</code></pre><p>julia using Plots scatter(t,y, label=&quot;real&quot;, legend=:topleft, xlabel=&quot;anos desde 1980&quot;, ylabel=&quot;população (milhões)&quot;, title=&quot;População da China&quot;)</p><h1 id="interpole-em-500-pontos-no-intervalo-[0,35]."><a class="docs-heading-anchor" href="#interpole-em-500-pontos-no-intervalo-[0,35].">interpole em 500 pontos no intervalo [0,35].</a><a id="interpole-em-500-pontos-no-intervalo-[0,35].-1"></a><a class="docs-heading-anchor-permalink" href="#interpole-em-500-pontos-no-intervalo-[0,35]." title="Permalink"></a></h1><p>tt = range(0,35,length=500)   </p><h1 id="avalie-o-polinômio-nesses-pontos"><a class="docs-heading-anchor" href="#avalie-o-polinômio-nesses-pontos">avalie o polinômio nesses pontos</a><a id="avalie-o-polinômio-nesses-pontos-1"></a><a class="docs-heading-anchor-permalink" href="#avalie-o-polinômio-nesses-pontos" title="Permalink"></a></h1><p>yy = p.(tt) plot!(tt,yy,label=&quot;interpolante&quot;)</p><pre><code class="nohighlight hljs">
## Exercícios

1. Suponha que você queira interpolar os pontos (-1,0), (0,1), (2,0), (3,1) e (4,2) por um polinômio de grau o mais baixo possível.
    
    **(a)** ✍ Qual é o grau máximo necessário desse polinômio?
    
    **(b)** ✍ Escreva um sistema linear de equações para os coeficientes do polinômio interpolador.
    
    **(c)** ⌨ Use Julia para resolver numericamente o sistema em (b).
    
2. **(a)** ✍ Suponha que você quer encontrar um polinômio cúbico $p$ tal que $p(-1) = -2$, $p&#39;(-1) = 1$, $p(1) = 0$, e $p&#39;(1) = -1$. (Isso é conhecido como um *Interpolador de Hermite.*) Escreva um sistema linear de equações para os coeficientes de $p$.
    
    **(b)** ⌨ Use Julia para resolver o sistema linear na parte (a), e faça um gráfico de $p$ sobre $-1 \le x \le 1$.
    

# Continuando com interpolação

Dado $n+1$ pontos distintos $(t_0,y_0)$, $(t_1,y_1),\ldots,(t_n,y_n)$, com $t_0&lt;t_1&lt;\ldots &lt;t_n$ chamados de nós, o problema de interpolação é encontrar uma função $p(x)$, chamada de interpolante, tal que $p(t_k)=y_k$  para $k=0,\dots,n$.

Aqui $t_k$ são os nós e $x$ denota a variável independente contínua.

Os nós de interpolação são numerados de 0 a $n$. Isso é conveniente para nossas declarações matemáticas, mas menos em um idioma como Julia, no qual os índices vetoriais começam com 1. Os índices em um código de computador têm o mesmo significado que os nomeados idênticos nas fórmulas matemáticas e portanto, deve ser incrementado por um sempre que usado em um contexto de indexação.

Os polinômios são o primeiro candidato óbvio a servir como funções interpolando. Eles são fáceis de trabalhar e, em vimos que um sistema linear de equações pode ser usado para determinar os coeficientes de um polinômio que passa por todos os membros de um conjunto de pontos. No entanto, não é difícil encontrar exemplos para os quais a interpolação polinomial leva a resultados inutilizáveis.

Aqui estão alguns pontos que poderíamos considerar ser observações de uma função desconhecida em [-1,1].
</code></pre><p>julia n = 5 t = range(-1,1,length=n+1) y = @. t^2 + t + 0.05<em>sin(20</em>t)</p><p>scatter(t,y,label=&quot;dados&quot;,leg=:top)</p><pre><code class="nohighlight hljs">
O interpolante polinomial, calculado usando o `fit`, parece muito bom.
</code></pre><p>julia p = Polynomials.fit(t,y,n)      plot!(p,-1,1,label=&quot;interpolant&quot;)</p><pre><code class="nohighlight hljs">
Mas agora considere um conjunto diferente de pontos gerados quase exatamente da mesma maneira.
</code></pre><p>julia n = 18 t = range(-1,1,length=n+1) y = @. t^2 + t + 0.05<em>sin(20</em>t)</p><p>scatter(t,y,label=&quot;data&quot;,leg=:top)</p><pre><code class="nohighlight hljs">
Os pontos em si não tem nada de especial. Mas dê uma olhada no que acontece com a interpolante polinomial.
</code></pre><p>julia p = Polynomials.fit(t,y,n) x = range(-1,1,length=1000)     plot!(x,p.(x),label=&quot;interpolant&quot;)</p><pre><code class="nohighlight hljs">
Certamente deve haver funções que são mais representativas desses pontos!

## Interpolação por polinômios por partes

Para manter pequenos graus de polinomial enquanto interpolam grandes conjuntos de dados, escolheremos interpolantes dos polinômios por partes. Especificamente, o interpolante p deve ser um polinômio em cada subintervalo $[t_ {k-1}, t_k]$ para  $k = 1, \ldots, n.$

Geralmente, designamos antecipadamente um grau máximo  para cada parte polinomial de p (x). 
</code></pre><p>julia scatter(t,y,label=&quot;data&quot;,leg=:top) using Dierckx p1 = Spline1D(t,y;k=1)#grau 1 p2 = Spline1D(t,y;k=2)#grau 2  p3 = Spline1D(t,y;k=3)#grau 3 plot!(x-&gt;p1(x),-1,1,label=&quot;piecewise linear&quot;) plot!(x-&gt;p2(x),-1,1,label=&quot;piecewise quadrático&quot;) plot!(x-&gt;p3(x),-1,1,label=&quot;piecewise cúbico&quot;)</p><pre><code class="nohighlight hljs">
## Exercício

1. Os dois vetores a seguir definem uma forma geometrica.
</code></pre><p>julia x = [ 0,0.51,0.96,1.06,1.29,1.55,1.73,2.13,2.61,       2.19,1.76,1.56,1.25,1.04,0.58,0 ] y = [ 0,0.16,0.16,0.43,0.62,0.48,0.19,0.18,0,       -0.12,-0.12,-0.29,-0.30,-0.15,-0.16,0 ]</p><pre><code class="nohighlight hljs">
Podemos considerar x e y como funções de um parâmetro s, com os pontos sendo valores dados em  $s = 0,1, \ldots, 15$.

(a) Interpole os pontos usando spline1d e plote a imagem.

(b) Uma desvantagem do resultado na parte (a) é o canto perceptível no lado esquerdo, que corresponde a s = 0 de cima e s = 15 de baixo. Teste adicionar a palavra-chave `periodic = true` à chamada de spline1d e plote o resultado.

## **Estabilidade da interpolação polinomial**

Escolhemos uma função em relação ao intervalo  $[0,1]$ .
</code></pre><p>julia f = x -&gt; sin(exp(2*x)); plot(f,0,1,label=&quot;função&quot;,legend=:bottomleft) t = (0:6)/6 y = f.(t) scatter!(t,y,label=&quot;nós&quot;) p = Polynomials.fit(t,y) plot!(p,0,1,label=&quot;interpolante&quot;,title=&quot;Interpolante equidistante, n=6&quot;)</p><pre><code class="nohighlight hljs">
Isso parece bom. Queremos rastrear o comportamento do erro à medida que $N$ aumenta. Estimaremos o erro no interpolante contínuo, amostrando-o em um grande número de pontos e tomando a norma máxima.
</code></pre><p>julia using LinearAlgebra n = 5:5:60;  err = zeros(size(n)) x = range(0,1,length=2001)      # pontos para medir o erro for (i,n) in enumerate(n) 	t = (0:n)/n                    	y = f.(t)                      	p = Polynomials.fit(t,y) 	err[i] = norm( (@. f(x)-p(x)), Inf ) end plot(n,err,m=:o,title=&quot;Erro de interpolação para nós equidistantes&quot;, xaxis=(&quot;n&quot;),yaxis=(:log10,&quot;max error&quot;),)</p><pre><code class="nohighlight hljs">
O erro diminui inicialmente como seria de esperar, mas começa a crescer. Ambas as fases ocorrem a taxas exponenciais em $n$, ou seja,  $O (k^n)$, aparecendo linear em um gráfico semi-log.

## Fenômeno de Runge

A decepcionante perda de convergência  é um sinal de mau condicionamento devido ao uso de nós igualmente espaçados. 
</code></pre><p>julia  using Plots,LaTeXStrings,LinearAlgebra</p><p>f = x -&gt; 1/(x^2 + 16) plot(f,-1,1,title=&quot;Função teste&quot;,legend=:none)</p><pre><code class="nohighlight hljs">
Essa função possui infinitamente muitos derivadas contínuas em toda a linha real e parece fácil de aproximar em $[-1,1]$. Começamos fazendo interpolação polinomial equispacada para alguns pequenos valores de $n$.
</code></pre><p>julia plot(xaxis=(L&quot;x&quot;),yaxis=(:log10,L&quot;|f(x)-p(x)|&quot;,[1e-20,1]))</p><p>x = range(-1,1,length=2501) n = 4:4:12</p><p>for (k,n) in enumerate(n)     t = range(-1,1,length=n+1)           y = f.(t)                        		p = Polynomials.fit(t,y)     err = @. abs(f(x)-p(x))     plot!(x,err,m=(1,:o,stroke(0)),label=&quot;grau n&quot;) end title!(&quot;Erro para graus baixos&quot;) </p><pre><code class="nohighlight hljs">
A convergência até agora parece bastante boa, embora não seja uniformemente. No entanto, observe o que acontece à medida que continuamos aumentando o grau.
</code></pre><p>julia n = @. 12 + 15*(1:3) plot(xaxis=(L&quot;x&quot;),yaxis=(:log10,L&quot;|f(x)-p(x)|&quot;,[1e-20,1]))</p><p>for (k,n) in enumerate(n)     t = range(-1,1,length=n+1)           y = f.(t)                        		p = Polynomials.fit(t,y)     err = @. abs(f(x)-p(x))     plot!(x,err,m=(1,:o,stroke(0)),label=&quot;grau n&quot;) end title!(&quot;Erro para graus altos&quot;) </p><pre><code class="nohighlight hljs">
A convergência no meio não pode ficar melhor do que a precisão da máquina em relação aos valores da função. Portanto, a manutenção da lacuna crescente entre o centro e as extremidades empurra as curvas de erro exponencialmente rapidamente nas extremidades, destruindo a convergência.

A observação da instabilidade é conhecida como o fenômeno runge. O fenômeno de Runge é uma instabilidade manifestada quando os nós do interpolante são igualmente espaçados e o grau do polinomial aumenta. 
Significativamente, a convergência observada  é estável dentro de uma parte do intervalo. Ao redistribuir os nós de interpolação, sacrificaremos um pouco da convergência na parte do meio, a fim de melhorá-lo perto das extremidades e resgatar o processo globalmente.

Uma família de nós que fornece convergência estável para a interpolação polinomial é os pontos  Chebyshev do segundo tipo definido por:
</code></pre><p>math  t_k = - \cos\left(\frac{k \pi}{n}\right), \qquad k=0,\ldots,n.</p><pre><code class="nohighlight hljs"></code></pre><p>julia plot(label=&quot;&quot;,xaxis=(L&quot;x&quot;),yaxis=(:log10,L&quot;|f(x)-p(x)|&quot;,[1e-20,1])) x = range(-1,1,length=2001) for (k,n) in enumerate([4,10,16,40])     t = [ -cos(pi*k/n) for k in 0:n ]     y = f.(t)                            		p = Polynomials.fit(t,y)     err = @.abs(f(x)-p(x))     plot!(x,err,m=(1,:o,stroke(0)),label=&quot;degree n&quot;) end title!(&quot;Erro com os pontos de Chebyshev&quot;)</p><pre><code class="nohighlight hljs">
A partir do grau 16, o erro está dentro da precisão de máquina e ele permanece lá à medida que $n$ aumenta. 

### Exercício

1. Para cada caso, calcule o interpolante polinomial usando  $n$ nós de Chebyshev do segundo tipo em  $[-1,1]$  por  $n = 4,8,12, \ldots, 60$ . Em cada valor de $n$, calcule o erro (ou seja,  $\max | p (x) -f (x) |$  avaliado em 4000 valores de $x$. Usando uma escala log-linear, plote o erro em função de  $n$ e, em seguida, determine uma boa aproximação à constante $k$ de $O(n^{-k})$.
(a) $f (x) = 1/(25x^2+1)$
(b) $f (x) = \tanh (5 x+2)$ 
(c)  $f (x) = \cosh(\sin x)$
(d)  $f (x) = \sin (\cosh x)$ 

## Integração numérica

A primitiva de $e^x$ é simples, isso torna a avaliação de $\int_{-1}^1 e^xdx$  pelo teorema fundamental trivial.
</code></pre><p>julia using FastGaussQuadrature, LinearAlgebra exato = exp(1)-exp(-1)</p><p>x, w = gausslegendre(3) #([-0.7745966692414834, 0.0, 0.7745966692414834], [0.5555555555555556, 0.8888888888888888, 0.5555555555555556])</p><p>f(x) = exp(x)</p><p>In = dot(w, f.(x)) exato-In</p><pre><code class="nohighlight hljs">
A abordagem numérica é muito robusta. Por exemplo, $e^{\sin x}$ não tem primitiva conhecida. Mas numericamente, sua integral não é mais difícil de ser calculada.
</code></pre><p>julia f(x) = exp(sin(x)) In = dot(w, f.(x))</p><pre><code class="nohighlight hljs">
Quando você olha para os gráficos dessas funções, o que é notável é que uma dessas áreas é muito simples, enquanto o outro é analiticamente muito difícil. Do ponto de vista numérico, eles são praticamente o mesmo problema.
</code></pre><p>julia  using Plots,LaTeXStrings plot([exp,x-&gt;exp(sin(x))],-1,1,fill=0,layout=(2,1),     xlabel=L&quot;x&quot;,ylabel=[L&quot;e^x&quot; L&quot;e^{\sin(x)}&quot;],ylim=[0,2.7])</p><pre><code class="nohighlight hljs">
A integração numérica, que também passa pelo nome mais antigo quadratura, é executado pela combinação de valores do integrando amostrados nos nós. Nesta seção, assumiremos nós igualmente espaçados:
</code></pre><p>math   t_i = a +i h, \quad h=\frac{b-a}{n}, \qquad i=0,\ldots,n.</p><pre><code class="nohighlight hljs">
A Integração numérica consiste em uma lista de pesos $w_0, \ldots, w_N$ escolhidos de modo que:
</code></pre><p>math     \int<em>a^b f(x)\, dx \approx h \sum</em>{i=0}^n w<em>if(t</em>i) =  h \bigl[ w<em>0f(t</em>0)+w<em>1f(t</em>1)+\cdots w<em>nf(t</em>n) \bigr].</p><pre><code class="nohighlight hljs">
Uma maneira direta de derivar fórmulas de integração é encontrar um interpolante e operar exatamente nele.

### Regra do trapézio

Uma das fórmulas de integração mais importantes resulta da integração do interpolante linear por partes. Geometricamente, a fórmula trapezoidal de áreas de trapezoides que se aproximam da região sob a curva y = f (x)

![Interpolação linear](linear.png)

Usando áreas de triângulos, é trivial derivar que
</code></pre><p>math w_i = \begin{cases}1, &amp; i=1,\ldots,n-1,\\frac{1}{2}, &amp; i=0,n.\end{cases}</p><pre><code class="nohighlight hljs"></code></pre><p>julia &quot;&quot;&quot;     trapezoidal(f,a,b,n)</p><p>Aplique a fórmula de integração do trapezoidal no intervalo [<code>a</code>,<code>b</code>], quebrado em ppartes iguais.Retorna a estimativa, um vetor de nós e um vetor de valores do integrando nos nós. &quot;&quot;&quot;</p><p>function trapezoidal(f,a,b,n)     h = (b-a)/n     t = range(a,b,length=n+1)     y = f.(t)     T = h * ( sum(y[2:n]) + 0.5*(y[1] + y[n+1]) )     return T,t,y end</p><pre><code class="nohighlight hljs">
Vamos aproximar $f(x)=e^{\sin 7x}$ no intervalo $[0,2]$. 
</code></pre><p>julia using PrettyTables f = x -&gt; exp(sin(7*x)); a = 0;  b = 2;</p><p>Integral = 2.6632197827615394 #exato T,t,y = trapezoidal(f,a,b,40) @show (T,Integral-T);</p><p>n = [ 10^n for n in 1:5 ] err = [] for n in n     T,t,y = trapezoidal(f,a,b,n)     push!(err,Integral-T) end</p><p>pretty_table([n err],[&quot;n&quot;,&quot;erro&quot;])</p><pre><code class="nohighlight hljs">
Cada aumento em um fator de 10 em $n$ reduz o erro em um fator de cerca de 100, o que é consistente com a convergência de segunda ordem. 

### Quadratura de Gauss

Vamos considerar a fórmula de integração numérica genérica:
</code></pre><p>math \int<em>{-1}^1f(x) dx\approx\sum</em>{k=1}^nw<em>kf(t</em>k)=Q_n[f],</p><pre><code class="nohighlight hljs">
Como existem  $n$  nós e $n$  pesos disponíveis para escolher, parece plausível esperar  que a quadratura consiga representar exatamente os polinômios de grau $m = 2n-1$ , e essa intuição acaba sendo correta. 

Vamos testar isso na integral:
</code></pre><p>math \int_{-1}^1\frac1{1+4x^2}dx=\arctan(2).</p><pre><code class="nohighlight hljs"></code></pre><p>julia f = x-&gt;1/(1+4*x^2); exato = atan(2);</p><p>n = 8:4:96 errT = zeros(size(n)) errG = zeros(size(n)) for (k,n) in enumerate(n)   errT[k] = abs(exato - trapezoidal(f,-1,1,n)[1])   x, w = gausslegendre(n)   errG[k] = abs(exato - dot(w, f.(x))) end</p><p>errT[iszero.(errT)] .= NaN errG[iszero.(errG)] .= NaN plot(n,[errT errG],m=:o,label=[&quot;T&quot; &quot;GL&quot;],     xaxis=(&quot;nós&quot;), yaxis=(:log10,&quot;error&quot;,[1e-16,1]),      title=&quot;integração numérica&quot;)</p><pre><code class="nohighlight hljs">
E agora com uma integral com um integrando mais pontudo:

$\int_{-1}^1 \frac{1}{1+16x^2} \, dx = \frac{1}{2}\arctan(4).$
</code></pre><p>julia f = x-&gt;1/(1+16*x^2); exato = atan(4)/2;</p><p>n = 8:4:96 errT = zeros(size(n)) errG = zeros(size(n)) for (k,n) in enumerate(n)   errT[k] = abs(exato - trapezoidal(f,-1,1,n)[1])   x, w = gausslegendre(n)   errG[k] = abs(exato - dot(w, f.(x))) end</p><p>errT[iszero.(errT)] .= NaN errG[iszero.(errG)] .= NaN plot(n,[errT errG],m=:o,label=[&quot;T&quot; &quot;GL&quot;],     xaxis=(&quot;nós&quot;), yaxis=(:log10,&quot;error&quot;,[1e-16,1]),      title=&quot;integração numérica&quot;)</p><pre><code class="nohighlight hljs">
### Exercícios

1. Usando a mudança de variável:     $z = \phi(x) = a + (b-a)\frac{(x+1)}{2}$ a integral pode ser reescrita como:     $\int_{a}^b f(z) \, d z= \frac{b-a}{2} \int_{-1}^{1} f( \phi(x) ) \, d x .$ Sabendo disso, use a quadratura de Gauss para integrar     $\int_{\pi/2}^{\pi} x^2 \sin 8x \, d x = -\frac{3 \pi^2}{32}.$ Mostre resultados para diferentes valores de $n$ até que se obtenha uma convergência de 10 digitos.
2. Integre  numericamente a  função  $f(x) =  -x\log(|x-1/2|)$ no intervalo $[0,1/2]$ usando  a quadratura de Gauss. Use 5, 10, 15 e 20 pontos de Gauss.
    
    ```math
    I_a=\int_{0}^{1/2}-x\log(|x-\frac{1}{2}|) dx=\frac{1}{16}\left(3+2\log 2\right)=0,274143
    ```
    

## Integrais singulares ou quasi-singulares

A última função integrada tem uma singularidade quando $x=1/2$. Mesmo com essa singularidade, e tendendo a infinito nesse ponto, essa função pode ser integrada analiticamente. Numericamente é interessante usar técnicas especiais para tratar de integrais desses tipo. 

Considere uma integral do tipo:
</code></pre><p>math I<em>s=\int</em>{-1}^{1}\frac{g(\xi)}{(\xi-a)^{2}+b^{2}} \mathrm{d}\xi</p><pre><code class="nohighlight hljs">
Uma ideia para avaliar numericamente integrais singulares($b=0$) ou quasi-singulares($b\neq 0$) é  encontrar uma transformação cujo Jacobiano seja zero ou bem próximo de zero no ponto singular. Por exemplo, para integrais quasi-singulares podemos usar:
</code></pre><p>math \xi=a+b\sinh(\mu s-\eta)</p><pre><code class="nohighlight hljs">
onde 
</code></pre><p>math \mu=\frac12\left{\operatorname{arcsinh}\left(\frac{1+a}b\right)+\operatorname{arcsinh}\left(\frac{1-a}b\right)\right}\\eta=\frac12\left{\operatorname{arcsinh}\left(\frac{1+a}b\right)-\operatorname{arcsinh}\left(\frac{1-a}b\right)\right}</p><pre><code class="nohighlight hljs">
e seu jacobiano é dado por:
</code></pre><p>math \frac{\mathrm{d}\xi}{\mathrm{d}s}=b\mu\cosh(\mu s-\eta)</p><pre><code class="nohighlight hljs">
Aplicando essa transformação, obtém-se:
</code></pre><p>math I<em>s=\int</em>{-1}^{1}\frac{g(s(\xi))}{(s(\xi)-a)^{2}+b^{2}} \frac{\mathrm{d}\xi}{\mathrm{d}s}\mathrm{d}s</p><pre><code class="nohighlight hljs">
essa transformação suaviza o integrando e acelera a convergência da quadratura.
</code></pre><p>julia</p><p>function sinhtrans(u, a, b)     μ = 1 / 2 * (asinh((1 + a) / b) + asinh((1 - a) / b))     η = 1 / 2 * (asinh((1 + a) / b) - asinh((1 - a) / b))</p><pre><code class="nohighlight hljs">x = a .+ b * sinh.(μ * u .- η)
J = b * μ * cosh.(μ * u .- η)
x, J</code></pre><p>end</p><pre><code class="nohighlight hljs"></code></pre><p>julia x=range(-1,1,length=100)     xt,jac=sinhtrans(x, 0.5, 0.01) plot(xt,[x,jac],layout=(2,1),xlabel=L&quot;s&quot;,ylabel=[L&quot;\xi&quot; L&quot;\frac{d\xi}{ds}&quot;],legend=false)</p><pre><code class="nohighlight hljs">
aplicando essa técnica para a integral do último exemplo pode-se observar uma redução significativa do erro para a mesma quantidade de pontos.
</code></pre><p>julia f = x-&gt;1/(1+16*x^2); exato = atan(4)/2;</p><p>n = 8</p><p>x, w = gausslegendre(n)  xt,J= sinhtrans(x, 0, 1/4)  errG = abs(exato - dot(w, f.(x)))  errGt = abs(exato - dot(w, J.*f.(xt)))</p><pre><code class="nohighlight hljs">
### Exercício

1. Integre, outra vez , numericamente a  função  $f(x) =  -x\log(|x-1/2|)$ no intervalo $[0,1/2]$ usando  a quadratura de Gauss mas agora usando a transformada de Monegato com graus 3, 4 e 5. Use 5, 10, 15 e 20 pontos de Gauss e compare com os resultados.
</code></pre><p>julia &quot;&quot;&quot; transformada de Monegato de grau q singularidade em s0 &quot;&quot;&quot; function Monegato(t, s0, q=5.0)     δ = 2^(-q) * ((1 + s0)^(1 / q) + (1 - s0)^(1 / q))^q     t0 = ((1 + s0)^(1 / q) - (1 - s0)^(1 / q)) / ((1 + s0)^(1 / q) + (1 - s0)^(1 / q))     s = s0 .+ δ * (t .- t0) .^ q     ds = q * δ * (t .- t0) .^ (q - 1)     s, ds end</p><pre><code class="nohighlight hljs">
1. Use 10 pontos de Gauss para calcular as integrais abaixo. Compare com a solução analítica. Quais integrais tiveram os maiores erros? Por que? 
</code></pre><p>math \begin{array}{|c|c|}\hline\int<em>{-2}^{+3}\left(x^6-2x^5+7\right)\mathrm{d}x&amp;144.04761904761904\\hline\int</em>{0}^{+3}2\ln(x+1)\mathrm{d}x&amp;5.090354888959125\\hline\int<em>{0}^{+3}\ln(x)\mathrm{d}x&amp;0.2958368660043291\\hline\int</em>{0}^{\pi}\left(\sin(x)\right.\times\cos(2x)) \mathrm{d}x&amp;-\frac{2}{3}=-0.66666666666667\\hline\int<em>{0}^{\pi}\left(\sin(3x)\cdot\cos(2x)+2x^3+3x\sin(x)\right)\mathrm{d}x&amp;59.3293234777059\\hline\int</em>{0}^{1}\frac{1}{x+1}\mathrm{d}x&amp;\ln(2)=0.6931471805599453\\hline\int_{0}^{1}\frac{1}{x+0.1}\mathrm{d}x&amp;\ln(11)=2.3978952727983707\\hline\end{array} ```</p><h2 id="Desafio"><a class="docs-heading-anchor" href="#Desafio">Desafio</a><a id="Desafio-1"></a><a class="docs-heading-anchor-permalink" href="#Desafio" title="Permalink"></a></h2><p>Considere o resfriamento de uma aleta circular por meio de transferência de calor por convecção ao longo de seu comprimento. A convecção dá origem a uma perda de calor ou termo de sumidouro dependente da temperatura na equação governante. Mostrada na Figura está uma aleta cilíndrica com área de seção transversal uniforme A. A base está a uma temperatura de 100C (TB) e a extremidade direita está isolada. A aleta está exposta a uma temperatura ambiente de 20C. A transferência de calor unidimensional nesta situação é governada por<span>$\frac{\mathrm{d}}{\mathrm{d}x}\Bigg(kA\frac{\mathrm{d}T}{\mathrm{d}x}\Bigg)-hP(T-T_\infty)=0$</span></p><p>onde h é o coeficiente de transferência de calor por convecção, P o perímetro, k a condutividade térmica do material e T— a temperatura ambiente. Calcule usando BEM a distribuição de temperatura ao longo da aleta e compare os resultados com a solução analítica fornecida por <span>$\frac{T-T_\infty}{T_B-T_\infty}=\frac{\cosh[n(L-x)]}{\cosh(nL)}$</span></p><p><img src="../conve.png" alt="convecção"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../01-teoria/">« Apresentação</a><a class="docs-footer-nextpage" href="../03-diferenciais/">Equações diferenciais »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 27 February 2025 13:17">Thursday 27 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
