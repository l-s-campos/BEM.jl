var documenterSearchIndex = {"docs":
[{"location":"02-interpola/#Interpolação","page":"Interpolação","title":"Interpolação","text":"","category":"section"},{"location":"02-interpola/#Interpolação-polinomial","page":"Interpolação","title":"Interpolação polinomial","text":"","category":"section"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"Suponha que queremos conhecer a população às vezes entre os anos do censo ou estimar populações futuras. Uma técnica é encontrar um polinômio que passa por todos os pontos de dados. ","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"Dado n pontos (t_1 y_1) ldots (t_n y_n), onde os t_i são todos distintos, o problema de interpolação polinomial é encontrar um polinomial P de grau menor que n tal que p (t_i) = y_i para todos i.","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"O problema de interpolação polinomial tem uma solução única. Uma vez encontrado o polinômio interpolador, ele pode ser avaliado em qualquer lugar para estimar ou prever valores.","category":"page"},{"location":"02-interpola/#**Interpolação-como-um-sistema-linear**","page":"Interpolação","title":"Interpolação como um sistema linear","text":"","category":"section"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"Dados os dados (t_i y_i) por i = 1 ldots n, buscamos um polinômio","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":" p(t) = c_1 + c_2 t + c_3t^2 +  cdots + c_n t^n-1\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"de tal modo que y_i=p(t_i) para todos i. Essas condições são usadas para determinar os coeficientes c_1ldotsc_n:","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":" c_1 + c_2 t_1 + cdots + c_n-1t_1^n-2 + c_nt_1^n-1 = y_1  c_1 + c_2 t_2 + cdots + c_n-1t_2^n-2 + c_nt_2^n-1 = y_2  c_1 + c_2 t_3 + cdots + c_n-1t_3^n-2 + c_nt_3^n-1 = y_3  vdots qquad   c_1 + c_2 t_n + cdots + c_n-1t_n^n-2 + c_nt_n^n-1 = y_n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"Essas equações formam um sistema linear para os coeficientes  c_i","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"  beginbmatrix\n    1  t_1  cdots  t_1^n-2  t_1^n-1 \n    1  t_2  cdots  t_2^n-2  t_2^n-1 \n    1  t_3  cdots  t_3^n-2  t_3^n-1 \n    vdots  vdots    vdots  vdots \n    1  t_n  cdots  t_n^n-2  t_n^n-1 \n  endbmatrix\n  beginbmatrix\n    c_1  \n    c_2  \n    c_3 \n    vdots \n    c_n\n  endbmatrix\n  =\n  beginbmatrix\n    y_1  \n    y_2  \n    y_3 \n    vdots \n    y_n\n  endbmatrix\n  \n\nou simplesmente mathbfV mathbfc = mathbfy A Matrix mathbfV é de um tipo especial chamado de Vandermonde\n\nA interpolação polinomial pode portanto ser formulada como um sistema linear de equações com uma matriz de Vandermonde\nCriamos dois vetores para dados sobre a população da China O primeiro tem os anos dos dados do censo e o outro tem a população em milhões de pessoas\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia year = [1982,2000,2010,2015]; pop = [1008.18, 1262.64, 1337.82, 1374.62]; t = year .- 1980.0 y = pop; V = [ t[i]^j for i=1:4, j=0:3 ] #4×4 Matrix{Float64}:  #1.0   2.0     4.0      8.0  #1.0  20.0   400.0   8000.0  #1.0  30.0   900.0  27000.0  #1.0  35.0  1225.0  42875.0  c = V \\ y   #4-element Vector{Float64}:","category":"page"},{"location":"02-interpola/#962.2387878787877","page":"Interpolação","title":"962.2387878787877","text":"","category":"section"},{"location":"02-interpola/#24.12775468975476","page":"Interpolação","title":"24.12775468975476","text":"","category":"section"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"#-0.592262049062053    #0.006843867243867301","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"using Polynomials p = Polynomial(c)    p(2005-1980)         ","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nO valor oficial da população para 2005 foi 1303,72, então nosso resultado é bastante bom.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia using Plots scatter(t,y, label=\"real\", legend=:topleft, xlabel=\"anos desde 1980\", ylabel=\"população (milhões)\", title=\"População da China\")","category":"page"},{"location":"02-interpola/#interpole-em-500-pontos-no-intervalo-[0,35].","page":"Interpolação","title":"interpole em 500 pontos no intervalo [0,35].","text":"","category":"section"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"tt = range(0,35,length=500)   ","category":"page"},{"location":"02-interpola/#avalie-o-polinômio-nesses-pontos","page":"Interpolação","title":"avalie o polinômio nesses pontos","text":"","category":"section"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"yy = p.(tt) plot!(tt,yy,label=\"interpolante\")","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\n## Exercícios\n\n1. Suponha que você queira interpolar os pontos (-1,0), (0,1), (2,0), (3,1) e (4,2) por um polinômio de grau o mais baixo possível.\n    \n    **(a)** ✍ Qual é o grau máximo necessário desse polinômio?\n    \n    **(b)** ✍ Escreva um sistema linear de equações para os coeficientes do polinômio interpolador.\n    \n    **(c)** ⌨ Use Julia para resolver numericamente o sistema em (b).\n    \n2. **(a)** ✍ Suponha que você quer encontrar um polinômio cúbico $p$ tal que $p(-1) = -2$, $p'(-1) = 1$, $p(1) = 0$, e $p'(1) = -1$. (Isso é conhecido como um *Interpolador de Hermite.*) Escreva um sistema linear de equações para os coeficientes de $p$.\n    \n    **(b)** ⌨ Use Julia para resolver o sistema linear na parte (a), e faça um gráfico de $p$ sobre $-1 \\le x \\le 1$.\n    \n\n# Continuando com interpolação\n\nDado $n+1$ pontos distintos $(t_0,y_0)$, $(t_1,y_1),\\ldots,(t_n,y_n)$, com $t_0<t_1<\\ldots <t_n$ chamados de nós, o problema de interpolação é encontrar uma função $p(x)$, chamada de interpolante, tal que $p(t_k)=y_k$  para $k=0,\\dots,n$.\n\nAqui $t_k$ são os nós e $x$ denota a variável independente contínua.\n\nOs nós de interpolação são numerados de 0 a $n$. Isso é conveniente para nossas declarações matemáticas, mas menos em um idioma como Julia, no qual os índices vetoriais começam com 1. Os índices em um código de computador têm o mesmo significado que os nomeados idênticos nas fórmulas matemáticas e portanto, deve ser incrementado por um sempre que usado em um contexto de indexação.\n\nOs polinômios são o primeiro candidato óbvio a servir como funções interpolando. Eles são fáceis de trabalhar e, em vimos que um sistema linear de equações pode ser usado para determinar os coeficientes de um polinômio que passa por todos os membros de um conjunto de pontos. No entanto, não é difícil encontrar exemplos para os quais a interpolação polinomial leva a resultados inutilizáveis.\n\nAqui estão alguns pontos que poderíamos considerar ser observações de uma função desconhecida em [-1,1].\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia n = 5 t = range(-1,1,length=n+1) y = @. t^2 + t + 0.05sin(20t)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"scatter(t,y,label=\"dados\",leg=:top)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nO interpolante polinomial, calculado usando o `fit`, parece muito bom.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia p = Polynomials.fit(t,y,n)      plot!(p,-1,1,label=\"interpolant\")","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nMas agora considere um conjunto diferente de pontos gerados quase exatamente da mesma maneira.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia n = 18 t = range(-1,1,length=n+1) y = @. t^2 + t + 0.05sin(20t)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"scatter(t,y,label=\"data\",leg=:top)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nOs pontos em si não tem nada de especial. Mas dê uma olhada no que acontece com a interpolante polinomial.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia p = Polynomials.fit(t,y,n) x = range(-1,1,length=1000)     plot!(x,p.(x),label=\"interpolant\")","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nCertamente deve haver funções que são mais representativas desses pontos!\n\n## Interpolação por polinômios por partes\n\nPara manter pequenos graus de polinomial enquanto interpolam grandes conjuntos de dados, escolheremos interpolantes dos polinômios por partes. Especificamente, o interpolante p deve ser um polinômio em cada subintervalo $[t_ {k-1}, t_k]$ para  $k = 1, \\ldots, n.$\n\nGeralmente, designamos antecipadamente um grau máximo  para cada parte polinomial de p (x). \n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia scatter(t,y,label=\"data\",leg=:top) using Dierckx p1 = Spline1D(t,y;k=1)#grau 1 p2 = Spline1D(t,y;k=2)#grau 2  p3 = Spline1D(t,y;k=3)#grau 3 plot!(x->p1(x),-1,1,label=\"piecewise linear\") plot!(x->p2(x),-1,1,label=\"piecewise quadrático\") plot!(x->p3(x),-1,1,label=\"piecewise cúbico\")","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\n## Exercício\n\n1. Os dois vetores a seguir definem uma forma geometrica.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia x = [ 0,0.51,0.96,1.06,1.29,1.55,1.73,2.13,2.61,       2.19,1.76,1.56,1.25,1.04,0.58,0 ] y = [ 0,0.16,0.16,0.43,0.62,0.48,0.19,0.18,0,       -0.12,-0.12,-0.29,-0.30,-0.15,-0.16,0 ]","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nPodemos considerar x e y como funções de um parâmetro s, com os pontos sendo valores dados em  $s = 0,1, \\ldots, 15$.\n\n(a) Interpole os pontos usando spline1d e plote a imagem.\n\n(b) Uma desvantagem do resultado na parte (a) é o canto perceptível no lado esquerdo, que corresponde a s = 0 de cima e s = 15 de baixo. Teste adicionar a palavra-chave `periodic = true` à chamada de spline1d e plote o resultado.\n\n## **Estabilidade da interpolação polinomial**\n\nEscolhemos uma função em relação ao intervalo  $[0,1]$ .\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia f = x -> sin(exp(2*x)); plot(f,0,1,label=\"função\",legend=:bottomleft) t = (0:6)/6 y = f.(t) scatter!(t,y,label=\"nós\") p = Polynomials.fit(t,y) plot!(p,0,1,label=\"interpolante\",title=\"Interpolante equidistante, n=6\")","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nIsso parece bom. Queremos rastrear o comportamento do erro à medida que $N$ aumenta. Estimaremos o erro no interpolante contínuo, amostrando-o em um grande número de pontos e tomando a norma máxima.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia using LinearAlgebra n = 5:5:60;  err = zeros(size(n)) x = range(0,1,length=2001)      # pontos para medir o erro for (i,n) in enumerate(n) \tt = (0:n)/n                    \ty = f.(t)                      \tp = Polynomials.fit(t,y) \terr[i] = norm( (@. f(x)-p(x)), Inf ) end plot(n,err,m=:o,title=\"Erro de interpolação para nós equidistantes\", xaxis=(\"n\"),yaxis=(:log10,\"max error\"),)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nO erro diminui inicialmente como seria de esperar, mas começa a crescer. Ambas as fases ocorrem a taxas exponenciais em $n$, ou seja,  $O (k^n)$, aparecendo linear em um gráfico semi-log.\n\n## Fenômeno de Runge\n\nA decepcionante perda de convergência  é um sinal de mau condicionamento devido ao uso de nós igualmente espaçados. \n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia  using Plots,LaTeXStrings,LinearAlgebra","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"f = x -> 1/(x^2 + 16) plot(f,-1,1,title=\"Função teste\",legend=:none)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nEssa função possui infinitamente muitos derivadas contínuas em toda a linha real e parece fácil de aproximar em $[-1,1]$. Começamos fazendo interpolação polinomial equispacada para alguns pequenos valores de $n$.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia plot(xaxis=(L\"x\"),yaxis=(:log10,L\"|f(x)-p(x)|\",[1e-20,1]))","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"x = range(-1,1,length=2501) n = 4:4:12","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"for (k,n) in enumerate(n)     t = range(-1,1,length=n+1)           y = f.(t)                        \t\tp = Polynomials.fit(t,y)     err = @. abs(f(x)-p(x))     plot!(x,err,m=(1,:o,stroke(0)),label=\"grau n\") end title!(\"Erro para graus baixos\") ","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nA convergência até agora parece bastante boa, embora não seja uniformemente. No entanto, observe o que acontece à medida que continuamos aumentando o grau.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia n = @. 12 + 15*(1:3) plot(xaxis=(L\"x\"),yaxis=(:log10,L\"|f(x)-p(x)|\",[1e-20,1]))","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"for (k,n) in enumerate(n)     t = range(-1,1,length=n+1)           y = f.(t)                        \t\tp = Polynomials.fit(t,y)     err = @. abs(f(x)-p(x))     plot!(x,err,m=(1,:o,stroke(0)),label=\"grau n\") end title!(\"Erro para graus altos\") ","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nA convergência no meio não pode ficar melhor do que a precisão da máquina em relação aos valores da função. Portanto, a manutenção da lacuna crescente entre o centro e as extremidades empurra as curvas de erro exponencialmente rapidamente nas extremidades, destruindo a convergência.\n\nA observação da instabilidade é conhecida como o fenômeno runge. O fenômeno de Runge é uma instabilidade manifestada quando os nós do interpolante são igualmente espaçados e o grau do polinomial aumenta. \nSignificativamente, a convergência observada  é estável dentro de uma parte do intervalo. Ao redistribuir os nós de interpolação, sacrificaremos um pouco da convergência na parte do meio, a fim de melhorá-lo perto das extremidades e resgatar o processo globalmente.\n\nUma família de nós que fornece convergência estável para a interpolação polinomial é os pontos  Chebyshev do segundo tipo definido por:\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math  t_k = - \\cos\\left(\\frac{k \\pi}{n}\\right), \\qquad k=0,\\ldots,n.","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia plot(label=\"\",xaxis=(L\"x\"),yaxis=(:log10,L\"|f(x)-p(x)|\",[1e-20,1])) x = range(-1,1,length=2001) for (k,n) in enumerate([4,10,16,40])     t = [ -cos(pi*k/n) for k in 0:n ]     y = f.(t)                            \t\tp = Polynomials.fit(t,y)     err = @.abs(f(x)-p(x))     plot!(x,err,m=(1,:o,stroke(0)),label=\"degree n\") end title!(\"Erro com os pontos de Chebyshev\")","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nA partir do grau 16, o erro está dentro da precisão de máquina e ele permanece lá à medida que $n$ aumenta. \n\n### Exercício\n\n1. Para cada caso, calcule o interpolante polinomial usando  $n$ nós de Chebyshev do segundo tipo em  $[-1,1]$  por  $n = 4,8,12, \\ldots, 60$ . Em cada valor de $n$, calcule o erro (ou seja,  $\\max | p (x) -f (x) |$  avaliado em 4000 valores de $x$. Usando uma escala log-linear, plote o erro em função de  $n$ e, em seguida, determine uma boa aproximação à constante $k$ de $O(n^{-k})$.\n(a) $f (x) = 1/(25x^2+1)$\n(b) $f (x) = \\tanh (5 x+2)$ \n(c)  $f (x) = \\cosh(\\sin x)$\n(d)  $f (x) = \\sin (\\cosh x)$ \n\n## Integração numérica\n\nA primitiva de $e^x$ é simples, isso torna a avaliação de $\\int_{-1}^1 e^xdx$  pelo teorema fundamental trivial.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia using FastGaussQuadrature, LinearAlgebra exato = exp(1)-exp(-1)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"x, w = gausslegendre(3) #([-0.7745966692414834, 0.0, 0.7745966692414834], [0.5555555555555556, 0.8888888888888888, 0.5555555555555556])","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"f(x) = exp(x)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"In = dot(w, f.(x)) exato-In","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nA abordagem numérica é muito robusta. Por exemplo, $e^{\\sin x}$ não tem primitiva conhecida. Mas numericamente, sua integral não é mais difícil de ser calculada.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia f(x) = exp(sin(x)) In = dot(w, f.(x))","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nQuando você olha para os gráficos dessas funções, o que é notável é que uma dessas áreas é muito simples, enquanto o outro é analiticamente muito difícil. Do ponto de vista numérico, eles são praticamente o mesmo problema.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia  using Plots,LaTeXStrings plot([exp,x->exp(sin(x))],-1,1,fill=0,layout=(2,1),     xlabel=L\"x\",ylabel=[L\"e^x\" L\"e^{\\sin(x)}\"],ylim=[0,2.7])","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nA integração numérica, que também passa pelo nome mais antigo quadratura, é executado pela combinação de valores do integrando amostrados nos nós. Nesta seção, assumiremos nós igualmente espaçados:\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math   t_i = a +i h, \\quad h=\\frac{b-a}{n}, \\qquad i=0,\\ldots,n.","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nA Integração numérica consiste em uma lista de pesos $w_0, \\ldots, w_N$ escolhidos de modo que:\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math     \\inta^b f(x)\\, dx \\approx h \\sum{i=0}^n wif(ti) =  h \\bigl[ w0f(t0)+w1f(t1)+\\cdots wnf(tn) \\bigr].","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nUma maneira direta de derivar fórmulas de integração é encontrar um interpolante e operar exatamente nele.\n\n### Regra do trapézio\n\nUma das fórmulas de integração mais importantes resulta da integração do interpolante linear por partes. Geometricamente, a fórmula trapezoidal de áreas de trapezoides que se aproximam da região sob a curva y = f (x)\n\n![Interpolação linear](linear.png)\n\nUsando áreas de triângulos, é trivial derivar que\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math w_i = \\begin{cases}1, & i=1,\\ldots,n-1,\\\\frac{1}{2}, & i=0,n.\\end{cases}","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia \"\"\"     trapezoidal(f,a,b,n)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"Aplique a fórmula de integração do trapezoidal no intervalo [a,b], quebrado em ppartes iguais.Retorna a estimativa, um vetor de nós e um vetor de valores do integrando nos nós. \"\"\"","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"function trapezoidal(f,a,b,n)     h = (b-a)/n     t = range(a,b,length=n+1)     y = f.(t)     T = h * ( sum(y[2:n]) + 0.5*(y[1] + y[n+1]) )     return T,t,y end","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nVamos aproximar $f(x)=e^{\\sin 7x}$ no intervalo $[0,2]$. \n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia using PrettyTables f = x -> exp(sin(7*x)); a = 0;  b = 2;","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"Integral = 2.6632197827615394 #exato T,t,y = trapezoidal(f,a,b,40) @show (T,Integral-T);","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"n = [ 10^n for n in 1:5 ] err = [] for n in n     T,t,y = trapezoidal(f,a,b,n)     push!(err,Integral-T) end","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"pretty_table([n err],[\"n\",\"erro\"])","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nCada aumento em um fator de 10 em $n$ reduz o erro em um fator de cerca de 100, o que é consistente com a convergência de segunda ordem. \n\n### Quadratura de Gauss\n\nVamos considerar a fórmula de integração numérica genérica:\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math \\int{-1}^1f(x) dx\\approx\\sum{k=1}^nwkf(tk)=Q_n[f],","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nComo existem  $n$  nós e $n$  pesos disponíveis para escolher, parece plausível esperar  que a quadratura consiga representar exatamente os polinômios de grau $m = 2n-1$ , e essa intuição acaba sendo correta. \n\nVamos testar isso na integral:\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math \\int_{-1}^1\\frac1{1+4x^2}dx=\\arctan(2).","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia f = x->1/(1+4*x^2); exato = atan(2);","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"n = 8:4:96 errT = zeros(size(n)) errG = zeros(size(n)) for (k,n) in enumerate(n)   errT[k] = abs(exato - trapezoidal(f,-1,1,n)[1])   x, w = gausslegendre(n)   errG[k] = abs(exato - dot(w, f.(x))) end","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"errT[iszero.(errT)] .= NaN errG[iszero.(errG)] .= NaN plot(n,[errT errG],m=:o,label=[\"T\" \"GL\"],     xaxis=(\"nós\"), yaxis=(:log10,\"error\",[1e-16,1]),      title=\"integração numérica\")","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nE agora com uma integral com um integrando mais pontudo:\n\n$\\int_{-1}^1 \\frac{1}{1+16x^2} \\, dx = \\frac{1}{2}\\arctan(4).$\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia f = x->1/(1+16*x^2); exato = atan(4)/2;","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"n = 8:4:96 errT = zeros(size(n)) errG = zeros(size(n)) for (k,n) in enumerate(n)   errT[k] = abs(exato - trapezoidal(f,-1,1,n)[1])   x, w = gausslegendre(n)   errG[k] = abs(exato - dot(w, f.(x))) end","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"errT[iszero.(errT)] .= NaN errG[iszero.(errG)] .= NaN plot(n,[errT errG],m=:o,label=[\"T\" \"GL\"],     xaxis=(\"nós\"), yaxis=(:log10,\"error\",[1e-16,1]),      title=\"integração numérica\")","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\n### Exercícios\n\n1. Usando a mudança de variável:     $z = \\phi(x) = a + (b-a)\\frac{(x+1)}{2}$ a integral pode ser reescrita como:     $\\int_{a}^b f(z) \\, d z= \\frac{b-a}{2} \\int_{-1}^{1} f( \\phi(x) ) \\, d x .$ Sabendo disso, use a quadratura de Gauss para integrar     $\\int_{\\pi/2}^{\\pi} x^2 \\sin 8x \\, d x = -\\frac{3 \\pi^2}{32}.$ Mostre resultados para diferentes valores de $n$ até que se obtenha uma convergência de 10 digitos.\n2. Integre  numericamente a  função  $f(x) =  -x\\log(|x-1/2|)$ no intervalo $[0,1/2]$ usando  a quadratura de Gauss. Use 5, 10, 15 e 20 pontos de Gauss.\n    \n    ```math\n    I_a=\\int_{0}^{1/2}-x\\log(|x-\\frac{1}{2}|) dx=\\frac{1}{16}\\left(3+2\\log 2\\right)=0,274143\n    ```\n    \n\n## Integrais singulares ou quasi-singulares\n\nA última função integrada tem uma singularidade quando $x=1/2$. Mesmo com essa singularidade, e tendendo a infinito nesse ponto, essa função pode ser integrada analiticamente. Numericamente é interessante usar técnicas especiais para tratar de integrais desses tipo. \n\nConsidere uma integral do tipo:\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math Is=\\int{-1}^{1}\\frac{g(\\xi)}{(\\xi-a)^{2}+b^{2}} \\mathrm{d}\\xi","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nUma ideia para avaliar numericamente integrais singulares($b=0$) ou quasi-singulares($b\\neq 0$) é  encontrar uma transformação cujo Jacobiano seja zero ou bem próximo de zero no ponto singular. Por exemplo, para integrais quasi-singulares podemos usar:\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math \\xi=a+b\\sinh(\\mu s-\\eta)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nonde \n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math \\mu=\\frac12\\left{\\operatorname{arcsinh}\\left(\\frac{1+a}b\\right)+\\operatorname{arcsinh}\\left(\\frac{1-a}b\\right)\\right}\\\\eta=\\frac12\\left{\\operatorname{arcsinh}\\left(\\frac{1+a}b\\right)-\\operatorname{arcsinh}\\left(\\frac{1-a}b\\right)\\right}","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\ne seu jacobiano é dado por:\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math \\frac{\\mathrm{d}\\xi}{\\mathrm{d}s}=b\\mu\\cosh(\\mu s-\\eta)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nAplicando essa transformação, obtém-se:\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math Is=\\int{-1}^{1}\\frac{g(s(\\xi))}{(s(\\xi)-a)^{2}+b^{2}} \\frac{\\mathrm{d}\\xi}{\\mathrm{d}s}\\mathrm{d}s","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\nessa transformação suaviza o integrando e acelera a convergência da quadratura.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"function sinhtrans(u, a, b)     μ = 1 / 2 * (asinh((1 + a) / b) + asinh((1 - a) / b))     η = 1 / 2 * (asinh((1 + a) / b) - asinh((1 - a) / b))","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"x = a .+ b * sinh.(μ * u .- η)\nJ = b * μ * cosh.(μ * u .- η)\nx, J","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"end","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia x=range(-1,1,length=100)     xt,jac=sinhtrans(x, 0.5, 0.01) plot(xt,[x,jac],layout=(2,1),xlabel=L\"s\",ylabel=[L\"\\xi\" L\"\\frac{d\\xi}{ds}\"],legend=false)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\naplicando essa técnica para a integral do último exemplo pode-se observar uma redução significativa do erro para a mesma quantidade de pontos.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia f = x->1/(1+16*x^2); exato = atan(4)/2;","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"n = 8","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"x, w = gausslegendre(n)  xt,J= sinhtrans(x, 0, 1/4)  errG = abs(exato - dot(w, f.(x)))  errGt = abs(exato - dot(w, J.*f.(xt)))","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\n### Exercício\n\n1. Integre, outra vez , numericamente a  função  $f(x) =  -x\\log(|x-1/2|)$ no intervalo $[0,1/2]$ usando  a quadratura de Gauss mas agora usando a transformada de Monegato com graus 3, 4 e 5. Use 5, 10, 15 e 20 pontos de Gauss e compare com os resultados.\n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"julia \"\"\" transformada de Monegato de grau q singularidade em s0 \"\"\" function Monegato(t, s0, q=5.0)     δ = 2^(-q) * ((1 + s0)^(1 / q) + (1 - s0)^(1 / q))^q     t0 = ((1 + s0)^(1 / q) - (1 - s0)^(1 / q)) / ((1 + s0)^(1 / q) + (1 - s0)^(1 / q))     s = s0 .+ δ * (t .- t0) .^ q     ds = q * δ * (t .- t0) .^ (q - 1)     s, ds end","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"\n1. Use 10 pontos de Gauss para calcular as integrais abaixo. Compare com a solução analítica. Quais integrais tiveram os maiores erros? Por que? \n","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"math \\begin{array}{|c|c|}\\hline\\int{-2}^{+3}\\left(x^6-2x^5+7\\right)\\mathrm{d}x&144.04761904761904\\\\hline\\int{0}^{+3}2\\ln(x+1)\\mathrm{d}x&5.090354888959125\\\\hline\\int{0}^{+3}\\ln(x)\\mathrm{d}x&0.2958368660043291\\\\hline\\int{0}^{\\pi}\\left(\\sin(x)\\right.\\times\\cos(2x)) \\mathrm{d}x&-\\frac{2}{3}=-0.66666666666667\\\\hline\\int{0}^{\\pi}\\left(\\sin(3x)\\cdot\\cos(2x)+2x^3+3x\\sin(x)\\right)\\mathrm{d}x&59.3293234777059\\\\hline\\int{0}^{1}\\frac{1}{x+1}\\mathrm{d}x&\\ln(2)=0.6931471805599453\\\\hline\\int_{0}^{1}\\frac{1}{x+0.1}\\mathrm{d}x&\\ln(11)=2.3978952727983707\\\\hline\\end{array} ```","category":"page"},{"location":"02-interpola/#Desafio","page":"Interpolação","title":"Desafio","text":"","category":"section"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"Considere o resfriamento de uma aleta circular por meio de transferência de calor por convecção ao longo de seu comprimento. A convecção dá origem a uma perda de calor ou termo de sumidouro dependente da temperatura na equação governante. Mostrada na Figura está uma aleta cilíndrica com área de seção transversal uniforme A. A base está a uma temperatura de 100C (TB) e a extremidade direita está isolada. A aleta está exposta a uma temperatura ambiente de 20C. A transferência de calor unidimensional nesta situação é governada porfracmathrmdmathrmdxBigg(kAfracmathrmdTmathrmdxBigg)-hP(T-T_infty)=0","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"onde h é o coeficiente de transferência de calor por convecção, P o perímetro, k a condutividade térmica do material e T— a temperatura ambiente. Calcule usando BEM a distribuição de temperatura ao longo da aleta e compare os resultados com a solução analítica fornecida por fracT-T_inftyT_B-T_infty=fraccoshn(L-x)cosh(nL)","category":"page"},{"location":"02-interpola/","page":"Interpolação","title":"Interpolação","text":"(Image: convecção)","category":"page"},{"location":"03-diferenciais/#Equações-diferenciais","page":"Equações diferenciais","title":"Equações diferenciais","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Quantidades que mudam continuamente no tempo ou no espaço são frequentemente modeladas por equações diferenciais.  As equações diferenciais precisam de condições suplementares para definir de maneira única tanto a situação de modelagem quanto as soluções teóricas. O problema de valor inicial (PVI), no qual todas as condições são dadas em um único valor da variável independente, é a situação mais simples. Muitas vezes, a variável independente neste caso representa o tempo.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Os métodos para PVIs geralmente começam a partir do valor inicial conhecido e iteram ou \"avançam\" a partir daí. Há um grande número desses métodos, em parte devido às diferenças em precisão, estabilidade e conveniência. ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Um problema de valor inicial escalar de primeira ordem (PVI) é","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"u(t) = f(tu(t)) qquad a le t le b  \n  u(a) =u_0","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Chamamos t de variável independente e u de variável dependente. Se u = f(tu) = g(t) + u h(t), a equação diferencial é linear; caso contrário, é não linear.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Uma solução de um problema de valor inicial é uma função u(t) que torna ambas as equações u(t)=fbigl(tu(t)bigr) e u(a)=u_0 verdadeiras.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Quando t representa o tempo, às vezes escrevemos dotu (lê-se \"u-ponto\") em vez de u.","category":"page"},{"location":"03-diferenciais/#Soluções-numéricas","page":"Equações diferenciais","title":"Soluções numéricas","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"O pacote DifferentialEquations oferece solucionadores para problemas de valor inicial (PVIs). Vamos usá-lo para definir e resolver um problema de valor inicial para u=sin(u+t)^2 sobre t in 04, tal que u(0)=1.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Como muitos problemas práticos vêm com parâmetros que são fixos dentro de uma instância, mas variam de uma instância para outra, a sintaxe para PVIs inclui um argumento de entrada p que permanece fixo durante toda a solução. Aqui não queremos usar esse argumento, mas ele deve estar na definição para que o solucionador funcione.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Para criar um problema de valor inicial para u(t), você deve fornecer uma função que calcula u, um valor inicial para u e os pontos finais do intervalo para t. O intervalo t deve ser definido como (a,b), onde pelo menos um dos valores é um float.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"using DifferentialEquations,LaTeXStrings\nf = (u,p,t) -> sin((t+u)^2)     # define du/dt, deve incluir o argumento p\nu₀ = 1.0                       # valor inicial\ntspan = (0.0,4.0)               # intervalo t ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Com os dados acima, definimos um objeto de problema de PVI e depois o resolvemos. Aqui, informamos ao solucionador para usar o método Tsit5, que é uma boa escolha inicial para a maioria dos problemas.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"ivp = ODEProblem(f,u₀,tspan)\nsol = solve(ivp,Tsit5());","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"O objeto solução resultante pode ser mostrado usando plot.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"plot(sol,label=\"solução\",legend=:bottom,\n    xlabel=\"t\",ylabel=L\"u(t)\",title=L\"u'=\\\\sin((t+u)^2)\") ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"A solução também funciona como qualquer função que pode ser avaliada em diferentes valores de t.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"@show sol(1.0); ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Nos bastidores, o objeto solução contém algumas informações sobre como os valores e o gráfico são produzidos:","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"[sol.t sol.u]","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"O solucionador inicialmente encontra valores aproximados da solução (segunda coluna acima) em alguns tempos escolhidos automaticamente (primeira coluna acima). Para calcular a solução em outros momentos, o objeto realiza uma interpolação nesses valores. Este capítulo trata de como os valores discretos de t e u são calculados. Por enquanto, apenas observe como podemos extraí-los do objeto solução.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"scatter!(sol.t,sol.u,label=\"valores discretos\") ","category":"page"},{"location":"03-diferenciais/#Método-de-Euler","page":"Equações diferenciais","title":"Método de Euler","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Considere um problema de valor inicial de primeira ordem. Representamos uma solução numérica de um PVI por seus valores em uma coleção finita de nós, que por enquanto exigimos que sejam igualmente espaçados:","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"t_i = a + ih quad h=fracb-an quad i=0ldotsn ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"h","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"é chamado de tamanho do passo.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Como não obtemos valores exatamente corretos da solução nos nós, precisamos ter algum cuidado com a notação. A partir de agora, deixamos hatu(t)  denotar a solução exata do PVI. O valor aproximado em t_i  calculado por nossos métodos numéricos será denotado por u_iapprox hatu(t_i). ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Considere um interpolador linear por partes para os valores (ainda desconhecidos) u_0u_1ldots u_n. Para t_i  t  t_i+1, sua inclinação é","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"fracu_i+1 - u_it_i+1-t_i = fracu_i+1-u_ih ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Podemos conectar essa derivada à equação diferencial seguindo o modelo de u=f(tu):","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"fracu_i+1-u_ih = f(t_iu_i) quad i=0ldotsn-1 ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Podemos ver o lado esquerdo como uma aproximação para u(t) em t=t_i. Podemos reorganizar a equação para obter o método de Euler, nosso primeiro método para PVIs.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"O método de Euler avança em t, obtendo a solução em um novo nível de tempo explicitamente em termos do valor mais recente   u_i+1=u_i + h f(t_iu_i).","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"\"\"\"\n    euler(ivp,n)\n\nAplique o método de Euler para resolver o PVI dado usando `n` passos de tempo.\nRetorna um vetor de tempos e um vetor de valores da solução.\n\"\"\"\nfunction euler(ivp,n)\n    # Discretização do tempo.\n    a,b = ivp.tspan\n    h = (b-a)/n\n    t = [ a + i*h for i in 0:n ]\n\n    # Condição inicial e configuração de saída.\n    u = fill(float(ivp.u0),n+1)\n\n    # A iteração de passos de tempo.\n    for i in 1:n\n        u[i+1] = u[i] + h*ivp.f(u[i],ivp.p,t[i])\n    end\n    return t,u\nend\n","category":"page"},{"location":"03-diferenciais/#Exemplo","page":"Equações diferenciais","title":"Exemplo","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Consideramos o PVI u=sin(u+t)^2 sobre 0le t le 4, com u(0)=-1.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"f = (u,p,t) -> sin((t+u)^2);\ntspan = (0.0,4.0);\nu0 = -1.0;\n\nivp = ODEProblem(f,u0,tspan)\nt,u = euler(ivp,20)\n\nplot(t,u,m=2,label=\"n=20\",\n    xlabel=L\"t\",ylabel=L\"u(t)\",title=\"Solução por Euler\" )\n","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Poderíamos definir um interpolador diferente para obter uma imagem mais suave acima, mas a derivação do método de Euler assumiu um interpolador linear por partes. Podemos, em vez disso, solicitar mais passos para fazer o interpolador parecer mais suave.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"t,u = euler(ivp,50)\nplot!(t,u,m=2,label=\"n=50\")","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Aumentar n mudou a solução de maneira notável. Como sabemos que interpoladores e diferenças finitas se tornam mais precisos à medida que hto 0, devemos antecipar o mesmo comportamento do método de Euler. Não temos uma solução exata para comparar, então usaremos um solucionador DifferentialEquations para construir uma solução de referência precisa.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"u_exact = solve(ivp,Tsit5(),reltol=1e-14,abstol=1e-14)\n\nplot!(u_exact,l=(2,:black),label=\"referência\")","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Agora podemos realizar um estudo de convergência.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"n = [ round(Int,5*10^k) for k in 0:0.5:3 ]\nerr = []\nfor n in n\n    t,u = euler(ivp,n)\n    push!( err, norm(u_exact.(t)-u,Inf) )\nend\n\npretty_table((n=n,err=err),header=[\"n\",\"Inf-norm error\"])\n","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"O erro é aproximadamente reduzido por um fator de 10 para cada aumento em n pelo mesmo fator. ","category":"page"},{"location":"03-diferenciais/#Sistemas-de-equações","page":"Equações diferenciais","title":"Sistemas de equações","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Poucas aplicações envolvem um problema de valor inicial com apenas uma única variável dependente. Geralmente, existem múltiplas incógnitas e um sistema de equações para defini-las.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"A generalização de qualquer solucionador escalar de PVI para lidar com sistemas é direta. Considere o método de Euler, que na forma de sistema se torna","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"    mathbfu_i+1 = mathbfu_i + hmathbff(t_imathbfu_i) qquad i=0ldotsn-1","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"A equação de diferenças vetoriais é apenas a fórmula de Euler aplicada simultaneamente a cada componente do sistema de EDO. Como operações como adição e multiplicação se traduzem facilmente de escalares para vetores, a função que escrevemos para PVIs escalares funciona para sistemas também. Praticamente falando, as únicas mudanças que devem ser feitas são que a condição inicial e a função de EDO têm que ser codificadas para usar vetores.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Felizmente, a capacidade de resolver sistemas de de primeira ordem implica também a capacidade de resolver sistemas de ordem diferencial mais alta. A razão é que existe uma maneira sistemática de transformar um problema de ordem superior em um de primeira ordem de dimensão superior.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Dois pêndulos idênticos suspensos na mesma barra e oscilando em planos paralelos podem ser modelados como o sistema de segunda ordem","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"(Image: massa-mola)","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"  theta_1(t) +gamma theta_1 + fracgL sin theta_1 +  k(theta_1-theta_2) = 0  theta_2(t) +gamma theta_2 + fracgL sin theta_2 +  k(theta_2-theta_1) = 0","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"onde theta_1 e theta_2  são os ângulos feitos pelos dois pêndulos, L  é o comprimento de cada pêndulo, gamma é um parâmetro de fricção, e k é um parâmetro que descreve um torque produzido pela barra quando ela é torcida. Podemos converter este problema em um sistema de primeira ordem usando as substituições ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"  u_1 = theta_1 quad u_2 = theta_2 quad u_3 = theta_1 quad  u_4 = theta_2","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Com essas definições, o sistema se torna","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"  u_1 = u_3   u_2 = u_4   u_3 = -gamma u_3 - fracgLsin u_1 + k(u_2-u_1)   u_4 = -gamma u_4 - fracgLsin u_2 + k(u_1-u_2)","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"que é um sistema de primeira ordem em quatro dimensões. Para completar a descrição do problema, é necessário especificar valores para theta_1(0), theta_1(0), theta_2(0) e theta_2(0). ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"O truque ilustrado nos exemplos anteriores está sempre disponível. Para cada variável dependente escalar no sistema, introduza novos componentes até a derivada mais alta que aparece para y. As equações do sistema de primeira ordem vêm das relações triviais entre todas as derivadas inferiores e das equações originais de alta ordem. No final, deve haver tantas equações de componentes escalares quanto variáveis desconhecidas de primeira ordem.","category":"page"},{"location":"03-diferenciais/#Exemplo-2","page":"Equações diferenciais","title":"Exemplo","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"function couple(u,p,t)\n    γ,L,k = p\n    g = 9.8\n    udot = similar(u)\n    udot[1:2] .= u[3:4]\n    udot[3] = - γ*u[3] - (g/L)*sin(u[1]) + k*(u[2]-u[1])\n    udot[4] = - γ*u[4] - (g/L)*sin(u[2]) + k*(u[1]-u[2])\n    return udot \nend\nu₀ = [1.25,-0.5,0,0]\ntspan = (0.,50.);\nγ,L,k = 0,0.5,0\nivp = ODEProblem(couple,u₀,tspan,[γ,L,k])\nsol = solve(ivp,Tsit5())\nplot(sol,vars=[1,2],label=[L\"\\theta_1\" L\"\\theta_2\"],\n    xlims=[20,50],title=\"k=0\")\n    \nk = 1\nivp = ODEProblem(couple,u₀,tspan,[γ,L,k])\nsol = solve(ivp,Tsit5())\nplot(sol,vars=[1,2],label=[L\"\\theta_1\" L\"\\theta_2\"],\n    xlims=[20,50],title=\"k=1\")   \n    ","category":"page"},{"location":"03-diferenciais/#Runge-Kutta","page":"Equações diferenciais","title":"Runge-Kutta","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Chegamos agora a um dos principais e mais utilizados tipos de métodos para problemas de valor inicial: métodos Runge-Kutta. São métodos de uma etapa, embora eles não sejam frequentemente escritos nessa forma. Os métodos RK aumentam a precisão da primeira ordem, avaliando a função da EDO f (t u) mais de uma vez por etapa do tempo.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Método de segunda ordem\nConsidere uma expansão em série da solução exata para u=f(tu)\nmath   \\hat{u}(t_{i+1}) = \\hat{u}(t_i) + h \\hat{u}'(t_i) + \\frac{1}{2}h^2 \\hat{u}''(t_i) + O(h^3) .\nSe substituirmos hatu por f e mantivermos apenas os dois primeiros termos no lado direito, obteremos o método de Euler. Para obter mais precisão, precisaremos calcular ou estimar o terceiro termo também. Observe que\nmath   \\hat{u}'' = f' = \\frac{d f}{d t} = \\frac{\\partial f}{\\partial t} + \\frac{\\partial f}{\\partial u} \\frac{d u}{d t} = f_t + f_u f,\nonde aplicamos a regra da cadeia multidimensional à derivada, porque ambos os argumentos de f dependem de t. Usando essa expressão, obtemos\nmath   \\hat{u}(t_{i+1}) = \\hat{u}(t_i) + h\\left[f\\bigl(t_i,\\hat{u}(t_i)\\bigr) +    \\frac{h}{2}f_t\\bigl(t_i,\\hat{u}(t_i)\\bigr) +    \\frac{h}{2}f\\bigl(t_i,\\hat{u}(t_i)\\bigr)\\,f_u\\bigl(t_i,\\hat{u}(t_i)\\bigr)\\right] \\\\  + O(h^3).\nUma aproximação dessas derivadas parciais de f é necessária. Observe que\nmath     f\\bigl(t_i+\\alpha,\\hat{u}(t_i)+\\beta\\bigr) = f\\bigl(t_i,\\hat{u}(t_i)\\bigr) +  \\alpha f_t\\bigl(t_i,\\hat{u}(t_i)\\bigr) + \\beta f_u\\bigl(t_i,\\hat{u}(t_i)\\bigr) +  O\\bigl(\\alpha^2 + |\\alpha\\beta| + \\beta^2\\bigr).\nCorrespondendo esta expressão ao termo entre colchetes e selecionando alpha = h2  e beta = frac12h fbigl(t_ihatu(t_i)bigr) Fazendo isso, encontramos\nmath   \\hat{u}(t_{i+1}) = \\hat{u}(t_i) + h\\left[f\\bigl(t_i+\\alpha,\\hat{u}(t_i)+\\beta\\bigr)\\right] +  O(h\\alpha^2 + h|\\alpha \\beta| + h\\beta^2 + h^3).\nTruncar a série aqui resulta em um novo método de uma etapa.","category":"page"},{"location":"03-diferenciais/#Método-de-Euler-Melhorado","page":"Equações diferenciais","title":"Método de Euler Melhorado","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"O método de Euler melhorado é a fórmula de uma etapa","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"u_i+1 = u_i +  hfleft(t_i+tfrac12hu_i+tfrac12h f(t_iu_i)right)","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Graças às definições acima a ordem de precisão do Euler melhorado é dois. Em um primeiro estágio, o método faz meio passo de Euler h2","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"  k_1 = h f(t_iu_i)   v = u_i + tfrac12k_1","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"e no segundo estágio ele usa o passo inteiro de Euler mas usa o valor obtido no primeiro estágio para a inclinação.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"  k_2 = h fleft(t_i+tfrac12hvright)  u_i+1 = u_i + k_2","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"\"\"\"\n    euler2(ivp,n)\n\nAplique o método de Euler Melhorado para resolver o PVI dado usando `n`\npassos de tempo. Retorna um vetor de tempos e um vetor de valores da solução.\n\"\"\"\nfunction me2(ivp,n)\n    # Discretização do tempo.\n    a,b = ivp.tspan\n    h = (b-a)/n\n    t = [ a + i*h for i in 0:n ]\n\n    # Inicializar saída.\n    u = fill(float(ivp.u0),n+1)\n\n    # Iteração de passos de tempo.\n    for i in 1:n\n        uhalf = u[i] + h/2*ivp.f(u[i],ivp.p,t[i]);\n        u[i+1] = u[i] + h*ivp.f(uhalf,ivp.p,t[i]+h/2);\n    end\n    return t,u\nend\n","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Esse procedimento pode ser feito para ordens mais altas mas a complexidade aumenta rapidamente. ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"O método de Runge-Kutta mais comumente usado, e talvez o método mais popular de todos, é o de quarta ordem, dado por:","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"    k_1 = hf(t_iu_i)     k_2 = hf(t_i+h2u_i+k_12)    k_3 = hf(t_i+h2u_i+k_22)    k_4 = hf(t_i+hu_i+k_3)    u_i+1 = u_i + frac16 k_1 + frac13 k_2 + frac13 k_3 + frac16 k_4","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"\"\"\"\n    rk4(ivp,n)\n\nAplique o método comum de Runge-Kutta de 4ª ordem para resolver o PVI dado\nusando `n` passos de tempo. Retorna um vetor de tempos e um vetor de\nvalores da solução.\n\"\"\"\nfunction rk4(ivp,n)\n    # Discretização do tempo.\n    a,b = ivp.tspan\n    h = (b-a)/n\n    t = [ a + i*h for i in 0:n ]\n\n    # Inicializar saída.\n    u = fill(float(ivp.u0),n+1)\n\n    # Iteração de passos de tempo.\n    for i in 1:n\n        k₁ = h*ivp.f( u[i],      ivp.p, t[i]     )\n        k₂ = h*ivp.f( u[i]+k₁/2, ivp.p, t[i]+h/2 )\n        k₃ = h*ivp.f( u[i]+k₂/2, ivp.p, t[i]+h/2 )\n        k₄ = h*ivp.f( u[i]+k₃,   ivp.p, t[i]+h   )\n        u[i+1] = u[i] + (k₁ + 2(k₂+k₃) + k₄)/6\n    end\n    return t,u\nend","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"f = (u,p,t) -> sin((t+u)^2)\nivp = ODEProblem(f,u0,tspan)\ntspan = (0.0,4.0)\nu₀ = -1.0\nu_ref = solve(ivp,Tsit5(),reltol=1e-14,abstol=1e-14);\n\nn = [ round(Int,2*10^k) for k in 0:0.5:3 ]\nerr_IE2,err_RK4 = [],[]\nfor n in n\n    t,u = euler2(ivp,n)\n    push!( err_IE2, maximum( @.abs(u_ref(t)-u) ) )\n    t,u = rk4(ivp,n)\n    push!( err_RK4, maximum( @.abs(u_ref(t)-u) ) )\nend\n\npretty_table([n err_IE2 err_RK4],header=[\"n\",\"IE2 erro\",\"RK4 erro\"])","category":"page"},{"location":"03-diferenciais/#Métodos-de-múltiplos-passos","page":"Equações diferenciais","title":"Métodos de múltiplos passos","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Nos métodos de Runge–Kutta, começamos em u_i  para encontrar u_i+1, realizando múltiplas avaliações de f (estágios) para alcançar alta precisão. Em contraste, os métodos de múltiplos passos aumentam a precisão utilizando mais do histórico da solução, aproveitando informações do passado recente. Para a discussão nesta e nas seções seguintes, introduzimos a notação abreviada f_i = f(t_i u_i)","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Um método de múltiplos passos (ou método linear de múltiplos passos) de k passos é dado pela equação u_i+1 = a_k-1u_i + cdots + a_0 u_i-k+1 qquad \nqquad + h ( b_kf_i+1 + cdots + b_0 f_i-k+1)","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"onde a_j e b_j  são constantes. Se b_k=0, o método é explícito; caso contrário, é implícito.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"As quantidades u e f são mostradas como escalares, mas em geral podem ser vetores.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Para usar como um método numérico, iteramos através de i=k-1ldotsn-1. O valor u_0  é determinado pela condição inicial, mas também precisamos de alguma forma de gerar os valores iniciais u_1=alpha_1 quad ldots quad u_k-1=alpha_k-1","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"A fórmula define u_i+1 em termos de valores conhecidos da solução e sua derivada do passado. No caso explícito com b_k=0, a Equação imediatamente fornece uma fórmula para a quantidade desconhecida u_i+1 em termos de valores no nível de tempo t_i e anteriores. Assim, apenas uma nova avaliação de f é necessária para fazer um passo de tempo, desde que armazenemos o histórico recente.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Por exemplo a formula do Adams-Bashforth de quarta ordem é dada por:","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"mathbfu_i+1 = mathbfu_i + h ( tfrac5524mathbff_i - tfrac5924 mathbff_i-1 + tfrac3724mathbff_i-2 - tfrac924mathbff_i-3) quad i=3ldotsn-1","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"function ab4(ivp,n)\n    # Discretização do tempo.\n    a,b = ivp.tspan\n    h = (b-a)/n\n    t = [ a + i*h for i in 0:n ]\n\n    # Constantes no método AB4.\n    k = 4;   σ = [-9,37,-59,55]/24;\n\n    # Encontrar valores iniciais usando RK4.\n    u = fill(float(ivp.u0),n+1)\n    rkivp = ODEProblem(ivp.f,ivp.u0,(a,a+(k-1)*h),ivp.p)\n    ts,us = rk4(rkivp,k-1)\n    u[1:k] .= us\n\n    # Calcular histórico dos valores de u', do mais recente ao mais antigo.\n    f = [ ivp.f(u[i],ivp.p,t[i]) for i in 1:k ]\n    # Iteração de passos de tempo.\n    for i in k+1:n+1\n        u[i] = u[i-1] + h*dot(f,σ)  # avançar um passo\n        f = [ f[2:k];ivp.f(u[i],ivp.p,t[i]) ]   # novo valor de du/dt\n    end\n    return t,u\nend","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Agora fazemos um estudo de convergência:","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"err_AB4 = []\nfor n in n\n    t,u = ab4(ivp,n)\n    push!( err_AB4, maximum( @.abs(u_ref(t)-u) ) )\nend\n\npretty_table([n err_IE2 err_RK4 err_AB4],[\"n\",\"IE2 erro\",\"RK4 erro\",\"AB4 erro\"])","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Os métodos de Adams-Moulton são métodos implícitos e, portanto, não podem ser resolvidos como fazemos no caso dos métodos de Adams-Bashforth.  Portanto, para obter o valor aproximado de u_i+1, podemos usar um método de dois passos chamado método preditor-corretor. ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"No passo 1, usamos um método explícito, como o método de Adams-Bashforth, chamado preditor, para obter um valor aproximado inicial e no passo 2, chamado corretor, melhoramos a estimativa inicial. ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"O método Adams-Moulton implícito de quarta ordem é dado por:","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"mathbfu_i+1^k = mathbfu_i + h (tfrac924redmathbff_i+1^k-1+ tfrac1924mathbff_i - tfrac524 mathbff_i-1 + tfrac124mathbff_i-2 )","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"esse passo pode ser repetido até obter  u_i+1^(k) - u_i+1^(k-1) leq epsilon u_i+1^(k-1) ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"function am4(ivp, n; tol=1e-8, max_iter=10)\n    # Discretização do tempo.\n    a, b = ivp.tspan\n    h = (b - a) / n\n    t = [a + i * h for i in 0:n]\n\n    # Constantes do método AM4.\n    k = 4\n    σ = [1, -5, 19,9] / 24\n    σb = [-9,37,-59,55]/24\n\n    # Encontrar valores iniciais usando RK4.\n    u = fill(float(ivp.u0), n + 1)\n    rkivp = ODEProblem(ivp.f, ivp.u0, (a, a + (k - 1) * h), ivp.p)\n    ts, us = rk4(rkivp, k - 1)\n    u[1:k] .= us\n\n    # Calcular histórico dos valores de u', do mais recente ao mais antigo.\n    f = [ ivp.f(u[i],ivp.p,t[i]) for i in 1:k ]\n    # Iteração de passos de tempo.\n    for i in k+1:n+1\n        u[i] = u[i-1] + h*dot(f,σb)  # avançar um passo\n        f = [ f[2:k];ivp.f(u[i],ivp.p,t[i]) ]   # novo valor de du/dt\n\n        # Método de correção.\n        u_corr=0\n        for iter in 1:max_iter\n            u_corr = u[i-1] + h*dot(f,σ)  # avançar um passo\n            # @show iter,abs(u[i] - u_corr) , tol * abs(u_corr)\n            if abs(u[i] - u_corr) <= tol * abs(u_corr)\n                break\n            end\n            f[4] = ivp.f(u_corr,ivp.p,t[i])   # novo valor de du/dt\n            u[i ] = u_corr\n        end\n    end\n\n    return t, u\nend\n","category":"page"},{"location":"03-diferenciais/#Exercícios","page":"Equações diferenciais","title":"Exercícios","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"1- Escolha 5 PVI, use as funções   rk4 ,ab4  e  am4 e resolva para n=10cdot2^d e d=1ldots10. Faça um gráfico de convergência log-log para os erros no tempo final u_n-hatu(t_n) por n, e adicione uma linha reta indicando a convergência de quarta ordem. Com n=100, trace a solução e o erro u-hatu em gráficos separados.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"u = -2t u  0 le t le 2  u(0) = 2  hatu(t) = 2e^-t^2\nu = u + t  0 le t le 1  u(0) = 2  hatu(t) = 1-t+e^t\nu = x^2u(1+x^3) 0 le x le 3  u(0) =1 hatu(x) =1+(23)ln (1+x^3)^12\nu+ 9u = 9t  0 t 2pi  u(0) =1 u(0) = 1  hatu(t) = t+cos (3t)\nu+ 9u = sin(2t)  0 t 2pi  u(0) =2 u(0) = 1    quad hatu(t) = (15) sin(3t) + 2 cos (3t)+ (15) sin (2t)\nu- 9u = 9t  0 t 1  u(0) =2 u(0) = -1  hatu(t) = e^3t + e^-3t-t\nu+ 4u+ 4u = t  0 t 4  u(0) =1 u(0) = 34  hatu(t) = (3t+54)e^-2t + x^2 u +5xu + 4u = 0 1xe^2  u(1) =1  u(1) = -1  hatu(x) = x^-2( 1 + ln x)\n2 x^2 u +3xu - u = 0 1x16  u(1) =4  u(1) = -1    quad hatu(x) = 2(x^12 + x^-1)\nx^2 u -xu + 2u = 0 1xe^pi  u(1) =3  u(1) = 4    quad hatu(x) = x left 3 cos left( ln x right)+sin left( ln x right) right","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"2- O método de Houbolt é comumente usado em problemas de dinâmica estrutural. O método é conhecido por sua estabilidade e é especialmente eficaz em problemas onde é necessário lidar com altas frequências ou amortecimento. Ele descreve as derivadas de ordem 1 e 2 como:","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"beginalignedu_n+1=frac2u_n+1-5u_n+4u_n-1-u_n-2h^2u_n+1=frac11u_n+1-18u_n+9u_n-1-2u_n-26hendaligned","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"implemente esse método e o compare com um dos problemas resolvidos  na questão anterior.","category":"page"},{"location":"03-diferenciais/#Matrizes-de-diferenças-finitas","page":"Equações diferenciais","title":"Matrizes de diferenças finitas","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Primeiro discretizamos o intervalo  x in ab em pedaços iguais de comprimento h = fracb-an, levando aos nós x_i = a + i h qquad  i = 0 ldots n.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Nosso objetivo é encontrar um vetor mathbfg  tal que  g_i approx f(x_i)  para  i = 0 ldots n. Usando a fórmula de diferenças finitas:","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"g_n = fracf_n - f_n-1h.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Podemos resumir todo o conjunto de fórmulas definindo","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"mathbff =\nbeginbmatrix\nf(x_0)  f(x_1)  vdots  f(x_n-1)  f(x_n)\nendbmatrix","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":",","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"e então a equação vetorial","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"beginbmatrixf(x_0) 1mm f(x_1) 1mm vdots 1mm f(x_n-1) 1mm f(x_n)endbmatrixapproxmathbfD_x mathbff qquadmathbfD_x= frac1hbeginbmatrix-1  1    1mm -1  1   1mm  ddots  ddots  1mm   -1  1 1mm   -1  1endbmatrix","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Aqui, como em outros lugares, os elementos de mathbfD_x  que não são mostrados são zero. Chamamos mathbfD_x de matriz de diferenciação. Cada linha de mathbfD_x  fornece os pesos da fórmula de diferença finita usada em um dos nós.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"A matriz de diferenciação não é uma escolha única. Somos livres para usar quaisquer fórmulas de diferença finita que quisermos em cada linha. No entanto, faz sentido escolher linhas que sejam o mais semelhantes possível. Usando diferenças centradas de segunda ordem onde possível e fórmulas unilaterais de segunda ordem nos pontos de fronteira resulta em","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"mathbfD_x = frac1hbeginbmatrix-frac32  2     -frac12                     1mm-frac12  0     frac12                      1mm -frac12  0       frac12                     ddots  ddots  ddots                  -frac12    0       frac12 1mm               frac12     -2      frac32endbmatrix","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"As matrizes de diferenciação até agora são matrizes bandadas, ou seja, todos os valores não zero estão ao longo das diagonais próximas à diagonal principal.","category":"page"},{"location":"03-diferenciais/#Segunda-derivada","page":"Equações diferenciais","title":"Segunda derivada","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Da mesma forma, podemos definir matrizes de diferenciação para segundas derivadas. Por exemplo,","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"beginbmatrixf(x_0) 1mm f(x_1) 1mm f(x_2) 1mm vdots 1mm f(x_n-1) 1mm f(x_n)endbmatrixapproxfrac1h^2beginbmatrix2  -5  4       -1                  1mm1  -2  1                          1mm 1   -2      1                  1mm     ddots  ddots  ddots     1mm                 1       -2  1 1mm             -1   4       -5  2endbmatrixbeginbmatrixf(x_0) 1mm f(x_1) 1mm f(x_2) 1mm vdots 1mm f(x_n-1) 1mm f(x_n)endbmatrix = mathbfD_xx mathbff","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"\"\"\"\n    diff(n, xspan)\n\nConstrua matrizes de diferenciação de 2ª ordem, usando `n` nós únicos no intervalo\n`xspan`. Retorna um vetor de nós e as matrizes para as primeiras\ne segundas derivadas.\n\"\"\"\nfunction diffmat(n, xspan)\n\t\ta,b = xspan\n    h = (b-a)/n\n    x = [ a + i*h for i in 0:n ]   # nós\n\n    \n\t\t# Define a maior parte de Dₓ por suas diagonais.\n\t\tdp = fill(0.5/h,n)        # superdiagonal\n\t\tdm = fill(-0.5/h,n)       # subdiagonal\n\t\tDₓ = diagm(-1=>dm,1=>dp)\n\t\t\n\t\t# Corrigir as primeiras e últimas linhas.\n\t\tDₓ[1,1:3] = [-1.5,2,-0.5]/h\n\t\tDₓ[n+1,n-1:n+1] = [0.5,-2,1.5]/h\n\t\t\n\t\t# Define a maior parte de Dₓₓ por suas diagonais.\n\t\td0 =  fill(-2/h^2,n+1)    # diagonal principal\n\t\tdp =  ones(n)/h^2         # super- e subdiagonal\n\t\tDₓₓ = diagm(-1=>dp,0=>d0,1=>dp)\n\t\t\n\t\t# Corrigir as primeiras e últimas linhas.\n\t\tDₓₓ[1,1:4] = [2,-5,4,-1]/h^2\n\t\tDₓₓ[n+1,n-2:n+1] = [-1,4,-5,2]/h^2\n\t\t\n\t\treturn x,Dₓ,Dₓₓ\n\t\t\nend\n","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Usando essas matrizes para resolver o problema com condições de contorno ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"T(-1)=100T(1)=0","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"n=100\n x,dx,dxx=diffmat(n,[-1,1])\n dxx[1,:].=0 \n dxx[end,:].=0\n  dxx[1,1]=1 \n  dxx[end,end]=1\n  b=zeros(n+1)\n  b[1]=100\n  xdf=dxx\\b","category":"page"},{"location":"03-diferenciais/#A-equação-de-**difusão**","page":"Equações diferenciais","title":"A equação de difusão","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"A equação de difusão em uma dimensão é","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"u_t = k u_xx","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"onde  k é o coeficiente de difusão. A equação do calor é a equação diferencial típica para a classe conhecida como EDPs parabólicas. Um processo difusivo é aquele em que a velocidade é proporcional ao gradiente da solução. Assim, mudanças rápidas na solução se achatam rapidamente.","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Agora vamos resolver a equação de difusão em-11 usando diferenças finitas para aproximar a derivada em x. As condições de contorno são u(-1t)=0u(1t)=2 e a condição inicial é  1 + sin(πx2) + 3(1-x^2)e^-4x^2. ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"using DifferentialEquations,LaTeXStrings,Plots\n\nn=100\n x,dx,dxx=diffmat(n,[-1,1])\n \nf = (u,p,t) -> p[1]*[p[2];u[2:end-1];p[3]]\ninit = x -> 1 + sin(π*x/2) + 3*(1-x^2)*exp(-4x^2);\nu0=init.(x)\ntspan=(0,0.75)\nivp = ODEProblem(f,u0,tspan,[dxx,0,2])\nsol = solve(ivp,Tsit5());\n\nplt = plot(xlabel=L\"x\",ylabel=L\"u(x,t)\",legend=:topleft,\n          title=\"Solução da equação de calor\")\nfor t in 0:0.1:0.7\n    plot!(x[1:end-1],sol(t)[1:end-1],label=\"t=$t\")\nend\nplt\n\nanim = @animate for t in range(0,0.75,length=201) \n    plot(x[1:end-1],sol(t)[1:end-1],label=\"t=$t\",\n        xaxis=(L\"x\"), yaxis=(L\"u(x,t)\",(0,4.2)), \n        title=\"Difusão\",leg=:topleft,dpi=100)\nend\nmp4(anim,\"calor.mp4\",fps=30)","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"boundaries-heat.mp4","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Aqui as estratégias de passo no tempo apresentadas anteriormente também poderiam ser utilizadas.","category":"page"},{"location":"03-diferenciais/#Exercício","page":"Equações diferenciais","title":"Exercício","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"1 - Usando o BEM resolva o mesmo problema de difusão e compare com o MDF. Como o termo transiente aparece na equação integral? O que precisa ser feito para descrever u_t em termos das matrizes do BEM?","category":"page"},{"location":"03-diferenciais/#Equação-da-onda","page":"Equações diferenciais","title":"Equação da onda","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"A equação da onda é dada por     u_tt - c^2 u_xx = 0 Usaremos x in 01 e t 0 como o domínio. ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Para reduzir a ordem desse problema podemos definir: ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"u_t = y   y_t = c^2 u_xx","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"o que resultaria no sistema matricial:","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"beginbmatrix    mathbfu(t) 2mm  mathbfy(t)  endbmatrix  =  beginbmatrix    boldsymbol0  I 2mm c^2 mathbfD_xx  boldsymbol0  endbmatrix  beginbmatrix    mathbfu(t) 2mm mathbfy(t)  endbmatrix","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Usaremos velocidade c=2, as condições de Dirichlet u(0t) = u(1t) = 0 e duas condições iniciais: ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"u(x0) = e^-100(x+05)^2\n qquad 0 le x le 1  u_t(x0) = -u(x0) qquad 0 le x le 1","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"n=100\n x,dx,dxx=diffmat(n,[-1,1])\n\nf = (u,p,t) -> p[1]*[p[2];u[2:p[4]-1];p[3];u[p[4]+1:end]]\ninit = x -> exp(-100*(x+0.5)^2);\nu0=[init.(x); -init.(x)]\ntspan=(0,2)\nc=2\nivp = ODEProblem(f,u0,tspan,[[zeros(n+1,n+1) I;c^2*dxx zeros(n+1,n+1)],0,0,n+1])\nsol = solve(ivp,Tsit5());\n\nplt = plot(xlabel=L\"x\",ylabel=L\"u(x,t)\",legend=:topleft,\n          title=\"Solução da equação da onda\")\nfor t in 0:0.2:2\n    plot!(x[1:n-1],sol(t)[1:n-1],label=\"t=$t\")\nend\nplt\n\nanim = @animate for t in range(0,2,length=201) \n    plot(x[1:n-1],sol(t)[1:n-1],label=\"t=$t\",\n        xaxis=(L\"x\"), yaxis=(L\"u(x,t)\",(-1.1,1.1)), \n        title=\"onda\",leg=:topleft,dpi=100)\nend\nmp4(anim,\"onda.mp4\",fps=30)","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"onda.mp4","category":"page"},{"location":"03-diferenciais/#Desafio","page":"Equações diferenciais","title":"Desafio","text":"","category":"section"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"Usando o BEM resolva o mesmo problema e compare com o MDF. ","category":"page"},{"location":"03-diferenciais/","page":"Equações diferenciais","title":"Equações diferenciais","text":"x0=0\nxf=1\nl=xf-x0\nH=[0.5 -.5\n-.5 .5]\nG=-[0 l/2\n-l/2 0]\n#T=0.5*(x1[1]+x1[2]).+(xs.-x0)/2*x1[3].+(xs.-xf)/2*x1[4]\n\nHi=[0.5 0.5]\nGi=[(xs.-x0)/2 (xs.-xf)/2]\n\nHt=[H zeros(2,2);Hi -I]\nGt=[G ;Gi ]\n","category":"page"},{"location":"91-developer/#dev_docs","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"note: Contributing guidelines\nIf you haven't, please read the Contributing guidelines first.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"If you want to make contributions to this package that involves code, then this guide is for you.","category":"page"},{"location":"91-developer/#First-time-clone","page":"Developer documentation","title":"First time clone","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"tip: If you have writing rights\nIf you have writing rights, you don't have to fork. Instead, simply clone and skip ahead. Whenever upstream is mentioned, use origin instead.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"If this is the first time you work with this repository, follow the instructions below to clone the repository.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Fork this repo\nClone your repo (this will create a git remote called origin)\nAdd this repo as a remote:\ngit remote add upstream https://github.com/l-s-campos/BEM.jl","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"This will ensure that you have two remotes in your git: origin and upstream. You will create branches and push to origin, and you will fetch and update your local main branch from upstream.","category":"page"},{"location":"91-developer/#Linting-and-formatting","page":"Developer documentation","title":"Linting and formatting","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Install a plugin on your editor to use EditorConfig. This will ensure that your editor is configured with important formatting settings.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"We use https://pre-commit.com to run the linters and formatters. In particular, the Julia code is formatted using JuliaFormatter.jl, so please install it globally first:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"julia> # Press ]\npkg> activate\npkg> add JuliaFormatter","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"To install pre-commit, we recommend using pipx as follows:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"# Install pipx following the link\npipx install pre-commit","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"With pre-commit installed, activate it as a pre-commit hook:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"pre-commit install","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"To run the linting and formatting manually, enter the command below:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"pre-commit run -a","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Now, you can only commit if all the pre-commit tests pass.","category":"page"},{"location":"91-developer/#Testing","page":"Developer documentation","title":"Testing","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"As with most Julia packages, you can just open Julia in the repository folder, activate the environment, and run test:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"julia> # press ]\npkg> activate .\npkg> test","category":"page"},{"location":"91-developer/#Working-on-a-new-issue","page":"Developer documentation","title":"Working on a new issue","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"We try to keep a linear history in this repo, so it is important to keep your branches up-to-date.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Fetch from the remote and fast-forward your local main\ngit fetch upstream\ngit switch main\ngit merge --ff-only upstream/main\nBranch from main to address the issue (see below for naming)\ngit switch -c 42-add-answer-universe\nPush the new local branch to your personal remote repository\ngit push -u origin 42-add-answer-universe\nCreate a pull request to merge your remote branch into the org main.","category":"page"},{"location":"91-developer/#Branch-naming","page":"Developer documentation","title":"Branch naming","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"If there is an associated issue, add the issue number.\nIf there is no associated issue, and the changes are small, add a prefix such as \"typo\", \"hotfix\", \"small-refactor\", according to the type of update.\nIf the changes are not small and there is no associated issue, then create the issue first, so we can properly discuss the changes.\nUse dash separated imperative wording related to the issue (e.g., 14-add-tests, 15-fix-model, 16-remove-obsolete-files).","category":"page"},{"location":"91-developer/#Commit-message","page":"Developer documentation","title":"Commit message","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Use imperative or present tense, for instance: Add feature or Fix bug.\nHave informative titles.\nWhen necessary, add a body with details.\nIf there are breaking changes, add the information to the commit message.","category":"page"},{"location":"91-developer/#Before-creating-a-pull-request","page":"Developer documentation","title":"Before creating a pull request","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"tip: Atomic git commits\nTry to create \"atomic git commits\" (recommended reading: The Utopic Git History).","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Make sure the tests pass.\nMake sure the pre-commit tests pass.\nFetch any main updates from upstream and rebase your branch, if necessary:\ngit fetch upstream\ngit rebase upstream/main BRANCH_NAME\nThen you can open a pull request and work with the reviewer to address any issues.","category":"page"},{"location":"91-developer/#Building-and-viewing-the-documentation-locally","page":"Developer documentation","title":"Building and viewing the documentation locally","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Following the latest suggestions, we recommend using LiveServer to build the documentation. Here is how you do it:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Run julia --project=docs to open Julia in the environment of the docs.\nIf this is the first time building the docs\nPress ] to enter pkg mode\nRun pkg> dev . to use the development version of your package\nPress backspace to leave pkg mode\nRun julia> using LiveServer\nRun julia> servedocs()","category":"page"},{"location":"91-developer/#Making-a-new-release","page":"Developer documentation","title":"Making a new release","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"To create a new release, you can follow these simple steps:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Create a branch release-x.y.z\nUpdate version in Project.toml\nUpdate the CHANGELOG.md:\nRename the section \"Unreleased\" to \"[x.y.z] - yyyy-mm-dd\" (i.e., version under brackets, dash, and date in ISO format)\nAdd a new section on top of it named \"Unreleased\"\nAdd a new link in the bottom for version \"x.y.z\"\nChange the \"[unreleased]\" link to use the latest version - end of line, vx.y.z ... HEAD.\nCreate a commit \"Release vx.y.z\", push, create a PR, wait for it to pass, merge the PR.\nGo back to main screen and click on the latest commit (link: https://github.com/l-s-campos/BEM.jl/commit)\nAt the bottom, write @JuliaRegistrator register","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"After that, you only need to wait and verify:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Wait for the bot to comment (should take < 1m) with a link to a PR to the registry\nFollow the link and wait for a comment on the auto-merge\nThe comment should said all is well and auto-merge should occur shortly\nAfter the merge happens, TagBot will trigger and create a new GitHub tag. Check on https://github.com/l-s-campos/BEM.jl/releases\nAfter the release is create, a \"docs\" GitHub action will start for the tag.\nAfter it passes, a deploy action will run.\nAfter that runs, the stable docs should be updated. Check them and look for the version number.","category":"page"},{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#BEM.AbstractCompressor","page":"Reference","title":"BEM.AbstractCompressor","text":"abstract type AbstractCompressor\n\nTypes used to compress matrices.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.AbstractKernelMatrix","page":"Reference","title":"BEM.AbstractKernelMatrix","text":"abstract type AbstractKernelMatrix{T} <: AbstractMatrix{T}\n\nInterface for abstract matrices represented through a kernel function f, target elements X, and source elements Y. The matrix entry i,j is given by f(X[i],Y[j]). Concrete subtypes should implement at least\n\n`Base.getindex(K::AbstractKernelMatrix,i::Int,j::Int)`\n\nIf a more efficient implementation of getindex(K,I::UnitRange,I::UnitRange), getindex(K,I::UnitRange,j::Int) and getindex(adjoint(K),I::UnitRange,j::Int) is available (e.g. with SIMD vectorization), implementing such methods can improve the speed of assembling an HMatrix.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.AbstractSplitter","page":"Reference","title":"BEM.AbstractSplitter","text":"abstract type AbstractSplitter\n\nAn AbstractSplitter is used to split a ClusterTree. The interface requires the following methods:\n\nshould_split(clt,splitter) : return a Bool determining if the ClusterTree should be further divided\nsplit!(clt,splitter) : perform the splitting of the ClusterTree handling the necessary data sorting.\n\nSee GeometricSplitter for an example of an implementation.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.CardinalitySplitter","page":"Reference","title":"BEM.CardinalitySplitter","text":"struct CardinalitySplitter <: AbstractSplitter\n\nUsed to split a ClusterTree along the largest dimension if length(tree)>nmax. The split is performed so the data is evenly distributed amongst all children.\n\nSee also: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.ClusterTree","page":"Reference","title":"BEM.ClusterTree","text":"ClusterTree(elements,splitter;[copy_elements=true, threads=false])\n\nConstruct a ClusterTree from the  given elements using the splitting strategy encoded in splitter. If copy_elements is set to false, the elements argument are directly stored in the ClusterTree and are permuted during the tree construction.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.ClusterTree-2","page":"Reference","title":"BEM.ClusterTree","text":"mutable struct ClusterTree{N,T}\n\nTree structure used to cluster poitns of type SVector{N,T} into HyperRectangles.\n\nFields:\n\n_elements::Vector{SVector{N,T}} : vector containing the sorted elements.\ncontainer::HyperRectangle{N,T} : container for the elements in the current node.\nindex_range::UnitRange{Int} : indices of elements contained in the current node.\nloc2glob::Vector{Int} : permutation from the local indexing system to the original (global) indexing system used as input in the construction of the tree.\nglob2loc::Vector{Int} : inverse of loc2glob permutation.\nchildren::Vector{ClusterTree{N,T}}\nparent::ClusterTree{N,T}\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.DHMatrix","page":"Reference","title":"BEM.DHMatrix","text":"mutable struct DHMatrix{R,T} <: AbstractMatrix{T}\n\nConcrete type representing a hierarchical matrix with data distributed amongst various workers. Its structure is very similar to HMatrix, except that the leaves store a RemoteHMatrix object.\n\nThe data on the leaves of a DHMatrix may live on a different worker, so calling fetch on them should be avoided whenever possible.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.DHMatrix-Union{Tuple{T}, Tuple{R}, Tuple{R, R}} where {R, T}","page":"Reference","title":"BEM.DHMatrix","text":"DHMatrix{T}(rowtree,coltree;partition_strategy=:distribute_columns)\n\nConstruct the block structure of a distributed hierarchical matrix covering rowtree and coltree. Returns a DHMatrix with leaves that are empty.\n\nThe partition_strategy keyword argument determines how to partition the blocks for distributed computing. Currently, the only available options is distribute_columns, which will partition the columns of the underlying matrix into floor(log2(nw)) parts, where nw is the number of workers available.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.GeometricSplitter","page":"Reference","title":"BEM.GeometricSplitter","text":"struct GeometricSplitter <: AbstractSplitter\n\nUsed to split a ClusterTree in half along the largest axis. The children boxes are shrank to tighly fit the data.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.HMatrix","page":"Reference","title":"BEM.HMatrix","text":"mutable struct HMatrix{R,T} <: AbstractMatrix{T}\n\nA hierarchial matrix constructed from a rowtree and coltree of type R and holding elements of type T.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.HMatrix-Union{Tuple{T}, Tuple{R}, Tuple{R, R, Any}} where {R, T}","page":"Reference","title":"BEM.HMatrix","text":"HMatrix{T}(rowtree,coltree,adm)\n\nConstruct an empty HMatrix with rowtree and coltree using the admissibility condition adm. This function builds the skeleton for the hierarchical matrix, but does not compute data field in the blocks. See assemble_hmatrix for assembling a hierarhical matrix.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.HyperRectangle","page":"Reference","title":"BEM.HyperRectangle","text":"struct HyperRectangle{N,T}\n\nAxis-aligned hyperrectangle in N dimensions given by low_corner::SVector{N,T} and high_corner::SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.KernelMatrix","page":"Reference","title":"BEM.KernelMatrix","text":"KernelMatrix{Tf,Tx,Ty,T} <:: AbstractKernelMatrix{T}\n\nGeneric kernel matrix representing a kernel function acting on two sets of elements. If K is a KernelMatrix, then K[i,j] = f(X[i],Y[j]) where f::Tf=kernel(K), X::Tx=rowelements(K) and Y::Ty=colelements(K).\n\nExamples\n\nX = rand(SVector{2,Float64},2)\nY = rand(SVector{2,Float64},2)\nK = KernelMatrix(X,Y) do x,y\n    sum(x+y)\nend\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.MulLinearOp","page":"Reference","title":"BEM.MulLinearOp","text":"struct MulLinearOp{R,T} <: AbstractMatrix{T}\n\nAbstract matrix representing the following linear operator:\n\n    L = R + P + a * ∑ᵢ Aᵢ * Bᵢ\n\nwhere R and P are of type RkMatrix{T}, Aᵢ,Bᵢ are of type HMatrix{R,T} and a is scalar multiplier. Calling compressor(L) produces a low-rank approximation of L, where compressor is an AbstractCompressor.\n\nNote: this structure is used to group the operations required when multiplying hierarchical matrices so that they can later be executed in a way that minimizes recompression of intermediate computations.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.PartialACA","page":"Reference","title":"BEM.PartialACA","text":"struct PartialACA\n\nAdaptive cross approximation algorithm with partial pivoting. This structure can be used to generate an RkMatrix from a matrix-like object M as follows:\n\nusing LinearAlgebra\nrtol = 1e-6\ncomp = PartialACA(;rtol)\nA = rand(10,2)\nB = rand(10,2)\nM = A*adjoint(B) # a low-rank matrix\nR = comp(M, axes(M)...) # compress the entire matrix `M`\nnorm(Matrix(R) - M) < rtol*norm(M) # true\n\n# output\n\ntrue\n\n\nBecause it uses partial pivoting, the linear operator does not have to be evaluated at every i,j. This is usually much faster than TSVD, but due to the pivoting strategy the algorithm may fail in special cases, even when the underlying linear operator is of low rank.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.PermutedMatrix","page":"Reference","title":"BEM.PermutedMatrix","text":"PermutedMatrix{K,T} <: AbstractMatrix{T}\n\nStructured used to reprensent the permutation of a matrix-like object. The original matrix is stored in the data::K field, and the permutations are stored in rowperm and colperm.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.PrincipalComponentSplitter","page":"Reference","title":"BEM.PrincipalComponentSplitter","text":"struct PrincipalComponentSplitter <: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.RemoteHMatrix","page":"Reference","title":"BEM.RemoteHMatrix","text":"struct RemoteHMatrix{S,T}\n\nA light wrapper for a Future storing an HMatrix.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.RkMatrix","page":"Reference","title":"BEM.RkMatrix","text":"mutable struct RkMatrix{T}\n\nRepresentation of a rank r matrix M in outer product format M = A*adjoint(B) where A has size m × r and B has size n × r.\n\nThe internal representation stores A and B, but R.Bt or R.At can be used to get the respective adjoints.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.StrongAdmissibilityStd","page":"Reference","title":"BEM.StrongAdmissibilityStd","text":"struct StrongAdmissibilityStd\n\nTwo blocks are admissible under this condition if the minimum of their diameter is smaller than eta times the distance between them, where eta::Float64 is a parameter.\n\nUsage:\n\nadm = StrongAdmissibilityStd(;eta=2.0)\nadm(Xnode,Ynode)\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.TSVD","page":"Reference","title":"BEM.TSVD","text":"struct TSVD\n\nCompression algorithm based on a posteriori truncation of an SVD. This is the optimal approximation in Frobenius norm; however, it also tends to be very expensive and thus should be used mostly for \"small\" matrices.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.VectorOfVectors","page":"Reference","title":"BEM.VectorOfVectors","text":"struct VectorOfVectors{T}\n\nA simple structure which behaves as a Vector{Vector{T}} but stores the entries in a contiguous data::Vector{T} field. All vectors in the VectorOfVectors are assumed to be of size m, and there are k of them, meaning this structure can be used to represent a m × k matrix.\n\nSimilar to a vector-of-vectors, calling A[i] returns a view to the i-th column.\n\nSee also: newcol!\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.WeakAdmissibilityStd","page":"Reference","title":"BEM.WeakAdmissibilityStd","text":"struct WeakAdmissibilityStd\n\nTwo blocks are admissible under this condition if the distance between them is positive.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.kernelH","page":"Reference","title":"BEM.kernelH","text":"KH=kernelH(dad,BEM.calc_normais(dad))\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#Base.Matrix-Tuple{Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}}","page":"Reference","title":"Base.Matrix","text":"Matrix(H::HMatrix;global_index=true)\n\nConvert H to a Matrix. If global_index=true (the default), the entries are given in the global indexing system (see HMatrix for more information); otherwise the local indexing system induced by the row and columns trees are used.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.Bernsteins-Tuple{Any, Any}","page":"Reference","title":"BEM.Bernsteins","text":"Bernsteins(p, t)\n\nCalcula os polinômios de Bernstein para um dado grau p e parâmetro t.\n\nParâmetros\n\np::Int: Grau do polinômio de Bernstein.\nt::Float64: Parâmetro no qual o polinômio de Bernstein será avaliado.\n\nRetorno\n\nh::Float64: Resultado da avaliação do polinômio de Bernstein.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.Contato_NL_newton2-NTuple{5, Any}","page":"Reference","title":"BEM.Contato_NL_newton2","text":"Resolve numericamente um problema não-linear com condições de contato utilizando o método de Newton.\n\nArgumentos:\n\ndad: Estrutura de dados\nx0: Chute inicial para a solução.\nA2: Matriz do BEM\nb2: Vetor do BEM\nh: variável com as informações sobre o contato\nmaxiter (opcional): Número máximo de iterações do método de Newton.\ntol (opcional): Tolerância para o erro, utilizada como critério de parada.\n\nRetorno:\n\nx: Solução aproximada do problema, ou o último chute se o critério de parada não for satisfeito.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.FeD-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.FeD","text":"A função FeD calcula duas matrizes, F e D, com base nas coordenadas dos nós fornecidos.\n\nParâmetros\n\ndad: Estrutura de dados k.\nnodes: Matriz n x 2 onde cada linha representa as coordenadas (x, y) de um nó.\n\nRetorno\n\nF: Matriz n x n onde cada elemento F[i, j] é o resultado da função interpola aplicada à distância entre os nós i e j.\nD: Matriz n x n onde cada elemento D[i, j] é o valor -log(r) / (2 * π * dad.k), sendo r a distância entre os nós i e j.\n\nNotas\n\nA função ignora a diagonal principal das matrizes F e D (onde i == j).\nA função interpola deve ser definida em outro lugar no código.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.FeD2-Tuple{Any, Any}","page":"Reference","title":"BEM.FeD2","text":"A função FeD calcula duas matrizes, F e D, com base nas coordenadas dos nós fornecidos.\n\nParâmetros\n\ndad: Estrutura de dados k.\nnodes: Matriz n x 2 onde cada linha representa as coordenadas (x, y) de um nó.\n\nRetorno\n\nF: Matriz n x n onde cada elemento F[i, j] é o resultado da função interpola aplicada à distância entre os nós i e j.\nD: Matriz n x n onde cada elemento D[i, j] é o valor -log(r) / (2 * π * dad.k), sendo r a distância entre os nós i e j.\n\nNotas\n\nA função ignora a diagonal principal das matrizes F e D (onde i == j).\nA função interpola deve ser definida em outro lugar no código.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.Monta_M_RIMd-Tuple{potencial, Any}","page":"Reference","title":"BEM.Monta_M_RIMd","text":"Monta_M_RIMd(dad::potencial, npg)\n\nFunção que monta a matriz M utilizando o DIBEM (Direct interpolation method).\n\nParâmetros\n\ndad::potencial: Estrutura de dados contendo as informações do problema potencial.\nnpg: Número de pontos de Gauss para integração.\n\nRetorno\n\nMatriz A resultante da montagem utilizando o método RIMd.\n\nDescrição\n\nA função realiza os seguintes passos:\n\nCalcula o número de nós (n_nos), elementos (nelem) e nós internos (n_noi).\nCalcula as matrizes de funções radiais F  e das soluções fundamentais D utilizando a função FeD.\nCalcula as matrizes M e M1 utilizando a função calcMs.\nMonta a matriz A utilizando as matrizes M, F e D.\nAjusta os elementos da diagonal principal de A.\nRetorna a matriz A somada com a matriz diagonal M1.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.Monta_M_RIMd_hermite-Tuple{potencial, Any}","page":"Reference","title":"BEM.Monta_M_RIMd_hermite","text":"Monta_M_RIMd(dad::potencial, npg)\n\nFunção que monta a matriz M utilizando o DIBEM (Direct interpolation method).\n\nParâmetros\n\ndad::potencial: Estrutura de dados contendo as informações do problema potencial.\nnpg: Número de pontos de Gauss para integração.\n\nRetorno\n\nMatriz A resultante da montagem utilizando o método RIMd.\n\nDescrição\n\nA função realiza os seguintes passos:\n\nCalcula o número de nós (n_nos), elementos (nelem) e nós internos (n_noi).\nCalcula as matrizes de funções radiais F  e das soluções fundamentais D utilizando a função FeD.\nCalcula as matrizes M e M1 utilizando a função calcMs.\nMonta a matriz A utilizando as matrizes M, F e D.\nAjusta os elementos da diagonal principal de A.\nRetorna a matriz A somada com a matriz diagonal M1.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.Nlinear-Tuple{Any}","page":"Reference","title":"BEM.Nlinear","text":"Calcula as funções de forma lineares contínuas N1 e N2\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._aca_partial","page":"Reference","title":"BEM._aca_partial","text":"_aca_partial(K,irange,jrange,atol,rmax,rtol,istart=1)\n\nInternal function implementing the adaptive cross-approximation algorithm with partial pivoting. The returned R::RkMatrix provides an approximation to K[irange,jrange] which has either rank is expected to satisfy|M - R| < max(atol,rtol*|M|)`, but this inequality may fail to hold due to the various errors involved in estimating the error and |M|.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM._aca_partial_pivot-Tuple{Any, Any}","page":"Reference","title":"BEM._aca_partial_pivot","text":"_aca_partial_pivot(v,I)\n\nFind in the valid set I the index of the element x ∈ v maximizing its smallest singular value. This is equivalent to minimizing the spectral norm of the inverse of x.\n\nWhen x is a scalar, this is simply the element with largest absolute value.\n\nThis general implementation should work for both scalar as well as tensor-valued kernels; see (https://www.sciencedirect.com/science/article/pii/S0021999117306721)[https://www.sciencedirect.com/science/article/pii/S0021999117306721] for more details.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._assemble_cpu!-NTuple{4, Any}","page":"Reference","title":"BEM._assemble_cpu!","text":"_assemble_cpu!(hmat::HMatrix,K,comp)\n\nAssemble data on the leaves of hmat. The admissible leaves are compressed using the compressor comp. This function assumes the structure of hmat has already been intialized, and therefore should not be called directly. See HMatrix information on constructors.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._assemble_hmat_distributed-Tuple{Any, Any, Any}","page":"Reference","title":"BEM._assemble_hmat_distributed","text":"_assemble_hmat_distributed(K,rtree,ctree;adm=StrongAdmissibilityStd(),comp=PartialACA();global_index=true,threads=false)\n\nInternal methods called after the DHMatrix structure has been initialized in order to construct the HMatrix on each of the leaves of the DHMatrix.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._assemble_threads!-Tuple{Any, Any, Any}","page":"Reference","title":"BEM._assemble_threads!","text":"_assemble_threads!(hmat::HMatrix,K,comp)\n\nLike _assemble_cpu!, but uses threads to assemble the leaves. Note that the threads are spawned using Threads.@spawn, which means they are spawned on the same worker as the caller.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._build_block_structure!-Union{Tuple{T}, Tuple{R}, Tuple{Any, HMatrix{R, T}}} where {R, T}","page":"Reference","title":"BEM._build_block_structure!","text":"_build_block_structure!(adm_fun,current_node)\n\nRecursive constructor for HMatrix block structure. Should not be called directly.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._hgemv_recursive!-Tuple{AbstractVector, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, AbstractVector, Any}","page":"Reference","title":"BEM._hgemv_recursive!","text":"_hgemv_recursive!(C,A,B,offset)\n\nInternal function used to compute C[I] <-- C[I] + A*B[J] where I = rowrange(A) - offset[1] and J = rowrange(B) - offset[2].\n\nThe offset argument is used on the caller side to signal if the original hierarchical matrix had a pivot other than (1,1).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._update_frob_norm-Tuple{Any, Any, Any}","page":"Reference","title":"BEM._update_frob_norm","text":"_update_frob_norm(acc,A,B)\n\nGiven the Frobenius norm of Rₖ = A[1:end-1]*adjoint(B[1:end-1]) in acc, compute the Frobenius norm of Rₖ₊₁ = A*adjoint(B) efficiently.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato!-NTuple{5, Any}","page":"Reference","title":"BEM.aplica_contato!","text":"aplica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato2!-NTuple{5, Any}","page":"Reference","title":"BEM.aplica_contato2!","text":"aplica contato 2corpos\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato_incremental!-NTuple{8, Any}","page":"Reference","title":"BEM.aplica_contato_incremental!","text":"aplica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato_incremental2!-NTuple{7, Any}","page":"Reference","title":"BEM.aplica_contato_incremental2!","text":"aplica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.assemble_hmatrix-Tuple{AbstractKernelMatrix}","page":"Reference","title":"BEM.assemble_hmatrix","text":"assembel_hmatrix(K::AbstractKernelMatrix[; atol, rank, rtol, kwargs...])\n\nConstruct an approximation of K as an HMatrix using the partial ACA algorithm for the low rank blocks. The atol, rank, and rtol optional arguments are passed to the PartialACA constructor, and the remaining keyword arguments are forwarded to the main assemble_hmatrix function.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.assemble_hmatrix-Union{Tuple{T}, Tuple{Type{T}, Any, Any, Any}} where T","page":"Reference","title":"BEM.assemble_hmatrix","text":"assemble_hmatrix([T,], K, rowtree, coltree;\n    adm=StrongAdmissibilityStd(),\n    comp=PartialACA(),\n    threads=true,\n    distributed=false,\n    global_index=true)\n\nMain routine for assembling a hierarchical matrix. The argument K represents the matrix to be approximated, rowtree and coltree are tree structure partitioning the row and column indices, respectively, adm can be called on a node of rowtree and a node of coltree to determine if the block is compressible, and comp is a function/functor which can compress admissible blocks.\n\nIt is assumed that K supports getindex(K,i,j), and that comp can be called as comp(K,irange::UnitRange,jrange::UnitRange) to produce a compressed version of K[irange,jrange] in the form of an RkMatrix.\n\nThe type paramter T is used to specify the type of the entries of the matrix, by default is inferred from K using eltype(K).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.binary_split!-Union{Tuple{T}, Tuple{N}, Tuple{ClusterTree{N, T}, Function}} where {N, T}","page":"Reference","title":"BEM.binary_split!","text":"binary_split!(cluster::ClusterTree,predicate)\n\nSplit a ClusterTree into two, sorting all elements in the process according to predicate. cluster is assigned as parent to each children.\n\nEach point is sorted according to whether f(x) returns true (point sorted on the \"left\" node) or false (point sorted on the \"right\" node). At the end a minimal HyperRectangle containing all left/right points is created.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calcMs-Tuple{potencial, Any, Any}","page":"Reference","title":"BEM.calcMs","text":"calcMs(dad::potencial, npg)\n\nCalcula os valores das matrizes M e M1 para um dado potencial dad utilizando a quadratura de Gauss-Legendre com npg pontos.\n\nParâmetros\n\ndad::potencial: Estrutura contendo os dados do problema, incluindo nós (NOS), pontos internos (pontos_internos), elementos (ELEM) e constante k.\nnpg: Número de pontos de Gauss-Legendre a serem utilizados na quadratura.\n\nRetorno\n\nM: Vetor com as integrais das funções radiais calculados para cada ponto fonte.\nM1: Vetor com as integrais das soluções fundamentais calculados para cada ponto fonte.\n\nDescrição\n\nA função percorre todos os pontos radiais e elementos do problema, calculando os valores das matrizes M e M1 através da função calc_md, que utiliza a quadratura de Gauss-Legendre para integração numérica. Os resultados são acumulados nos vetores M e M1 e retornados ao final da execução.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calcPs-Tuple{potencial, Any}","page":"Reference","title":"BEM.calcPs","text":"calcPs(dad::potencial, npg)\n\nCalcula os valores das matrizes P e Pint para um dado potencial dad utilizando a quadratura de Gauss-Legendre com npg pontos.\n\nParâmetros\n\ndad::potencial: Estrutura contendo os dados do problema, incluindo nós (NOS), pontos internos (pontos_internos), elementos (ELEM) e constante k.\nnpg: Número de pontos de Gauss-Legendre a serem utilizados na quadratura.\n\nRetorno\n\nP: Vetor com as funções polinomiais para cada ponto fonte.\nPint: Vetor com as integrais de cada polinomio.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calc_Aeb","page":"Reference","title":"BEM.calc_Aeb","text":"calc_Aeb(dad::Union{potencial, helmholtz}, npg=8)\n\nCalcula a matriz A e o velor b para os dados fornecidos.\n\nParâmetros\n\ndad::Union{potencial, helmholtz}: Tipo de dado que pode ser potencial ou helmholtz.\nnpg: Número de pontos de Gauss (opcional, padrão é 8).\n\nRetorna\n\nA matriz A e o vetor b calculados com base nos parâmetros fornecidos.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_HeG","page":"Reference","title":"BEM.calc_HeG","text":"calc_HeG(dad::potencial, npg=8; Pint=false)\n\nCalcula as matrizes H e G para o problema de potencial usando o Método dos Elementos de Contorno (BEM).\n\nArgumentos\n\ndad::potencial: Os dados do problema de potencial, que incluem os elementos (ELEM) e nós (NOS).\nnpg::Int=8: O número de pontos de quadratura de Gauss-Legendre a serem usados para a integração numérica.\nPint::Bool=false: Uma flag para indicar se deve usar pontos internos (o padrão é falso).\n\nRetornos\n\nH::Matrix{Float64}: A matriz H.\nG::Matrix{Float64}: A matriz G.\n\nDescrição\n\nEsta função calcula as matrizes H e G para um dado problema de potencial usando o Método dos Elementos de Contorno (BEM).  Ela itera sobre os pontos fontes e elementos, realiza a integração numérica usando a quadratura de Gauss-Legendre,  e preenche as matrizes H e G com os valores computados.\n\nExemplo\n\n```julia H, G = calc_HeG(dad, 8)\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_HeG_hiper","page":"Reference","title":"BEM.calc_HeG_hiper","text":"calc_HeG_hiper(dad::potencial, npg=8)\n\nCalcula as matrizes H e G hiper-singulares para o problema de potencial usando o Método dos Elementos de Contorno (BEM).\n\nArgumentos\n\ndad::potencial: Os dados do problema de potencial, que incluem os elementos (ELEM) e nós (NOS).\nnpg::Int=8: O número de pontos de quadratura de Gauss-Legendre a serem usados para a integração numérica.\n\nRetornos\n\nH::Matrix{Float64}: A matriz H hiper-singular.\nG::Matrix{Float64}: A matriz G hiper-singular.\n\nDescrição\n\nEsta função calcula as matrizes H e G hiper-singulares para um dado problema de potencial usando o Método dos Elementos de Contorno (BEM).  Ela itera sobre os pontos fontes e elementos, realiza a integração numérica usando a quadratura de Gauss-Legendre,  e preenche as matrizes H e G com os valores computados.\n\nExemplo\n\n```julia H, G = calc_HeG(dad, 8)\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_Ti","page":"Reference","title":"BEM.calc_Ti","text":"calc_Ti(dad::potencial_iga, T, q, npg = 8)\n\nCalcula a matriz Ti com as temperaturas nos pontos internos para um dado problema de potencial com elementos de contorno isogeométricos.\n\nParâmetros\n\ndad::Union{potencial, helmholtz}: Estrutura contendo os dados do problema, incluindo elementos, nós e pontos internos.\nT: Vetor de temperaturas nos nós.\nq: Vetor de fluxos de calor nos nós.\nnpg: Número de pontos de Gauss para a quadratura (padrão é 8).\n\nRetorno\n\nTi: Vetor resultante após a integração dos elementos.\n\nDescrição\n\nA função percorre todos os pontos internos e elementos do contorno, calculando a contribuição de cada elemento para o vetor Ti utilizando a quadratura de Gauss. Para cada ponto interno, a função:\n\nObtém a coordenada do ponto fonte.\nPercorre todos os elementos do contorno.\nCalcula as coordenadas dos nós geométricos do elemento.\nCalcula a transformação de coordenadas e os fatores de forma.\nRealiza a integração dos elementos utilizando a quadratura de Gauss.\nAtualiza o vetor Ti com as contribuições de cada elemento.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_Ti-2","page":"Reference","title":"BEM.calc_Ti","text":"calc_Ti(dad::Union{potencial, helmholtz}, T, q, npg=8)\n\nCalcula a matriz Ti com as temperaturas nos pontos internos para um dado problema de potencial ou Helmholtz.\n\nParâmetros\n\ndad::Union{potencial, helmholtz}: Estrutura contendo os dados do problema, incluindo elementos, nós e pontos internos.\nT: Vetor de temperaturas nos nós.\nq: Vetor de fluxos de calor nos nós.\nnpg: Número de pontos de Gauss para a quadratura (padrão é 8).\n\nRetorno\n\nTi: Vetor resultante após a integração dos elementos.\n\nDescrição\n\nA função percorre todos os pontos internos e elementos do contorno, calculando a contribuição de cada elemento para o vetor Ti utilizando a quadratura de Gauss. Para cada ponto interno, a função:\n\nObtém a coordenada do ponto fonte.\nPercorre todos os elementos do contorno.\nCalcula as coordenadas dos nós geométricos do elemento.\nCalcula a transformação de coordenadas e os fatores de forma.\nRealiza a integração dos elementos utilizando a quadratura de Gauss.\nAtualiza o vetor Ti com as contribuições de cada elemento.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_fforma","page":"Reference","title":"BEM.calc_fforma","text":"calc_fforma(ξ, elem, deriv = true)\n\nCalcula as funções de forma polinomiais gerais.\n\nParâmetros\n\nξ: Ponto de avaliação.\nelem: Estrutura que contém os pontos nodais ξs.\nderiv: Booleano que indica se a derivada das funções de forma deve ser calculada. O padrão é true.\n\nRetorno\n\nSe deriv for true, retorna uma tupla (N, dN) onde N é o vetor das funções de forma e dN é o vetor das derivadas das funções de forma.\nSe deriv for false, retorna apenas N.\n\nNotas\n\nAs funções de forma são calculadas usando o interpolador de Lagrange.\nSe ξ for igual a algum dos pontos nodais ξs, um pequeno valor é adicionado a ξ para evitar divisão por zero.\n\nExemplo\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_fforma-Tuple{Any, BEM.bezier, Any}","page":"Reference","title":"BEM.calc_fforma","text":"calc_fforma(t, elem_j::bezier, w)\n\nCalcula a forma de função para um elemento de Bézier.\n\nParâmetros\n\nt: Ponto de avaliação.\nelem_j::bezier: Elemento de Bézier.\nw: Peso associado ao ponto de avaliação.\n\nRetorno\n\nRetorna a forma de função calculada no ponto t para o elemento elem_j com o peso w.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calc_fforma_gen","page":"Reference","title":"BEM.calc_fforma_gen","text":"calc_fforma_gen(ξ, ξs, deriv = true)\n\nCalcula as funções de forma gerais para elementos de um método numérico.\n\nParâmetros\n\nξ: Ponto de avaliação.\nξs: Vetor contendo as coordenadas dos nós.\nderiv: Booleano opcional que indica se a derivada das funções de forma deve ser calculada. O padrão é true.\n\nRetorno\n\nSe deriv for true, retorna uma tupla (N, dN), onde N é o vetor das funções de forma e dN é o vetor das derivadas das funções de forma.\nSe deriv for false, retorna apenas N.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_md-NTuple{7, Any}","page":"Reference","title":"BEM.calc_md","text":"calc_md(x, pf, k, qsi, w, elem)\n\nCalcula o potencial e a sua derivada normal em um ponto fonte pf devido a um elemento elem.\n\nParâmetros\n\nx::Vector{Float64}: Coordenadas dos nós do elemento.\npf::Vector{Float64}: Coordenadas do ponto fonte.\nk::Float64: Coeficiente de condutividade térmica.\nqsi::Vector{Float64}: Pontos de Gauss para integração.\nw::Vector{Float64}: Pesos de Gauss para integração.\nelem: Dados do elemento \n\nRetorna\n\nm_el::Float64: Integral no elemento da função de base radial.\nm_el1::Float64: Integral no elemento da soluçao fundamental.\n\nDescrição\n\nA função calc_md realiza a integração numérica utilizando a técnica dos pontos de Gauss para calcular o potencial e sua derivada normal em um ponto fonte pf devido a um elemento elem. A função utiliza as funções de forma N e suas derivadas dN_geo para interpolar os pontos de Gauss e calcular as distâncias e vetores normais necessários para a integração. O resultado é o potencial m_el e sua derivada normal m_el1 no ponto fonte pf.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calsolfund-Tuple{Any, Any, Union{potencial, potencial_iga}}","page":"Reference","title":"BEM.calsolfund","text":"calsolfund(r, n prob::Union{potencial,potencial_iga})\n\nCalcula a solução fundamental.\n\nParâmetros\n\nr: Distância radial.\nn: normal do ponto de integração.\nprob: Tipo de problema, pode ser potencial ou potencial_iga.\n\nRetorno\n\nRetorna a solução fundamental calculada com base nos parâmetros fornecidos.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calsolfund_hiper-Tuple{Any, Any, Any, Union{potencial, potencial_iga}}","page":"Reference","title":"BEM.calsolfund_hiper","text":"calsolfund_hiper(r, n, nf, prob::Union{potencial,potencial_iga})\n\nCalcula a solução fundamental hipersingular.\n\nParâmetros\n\nr: Distância radial.\nn: normal do ponto de integração.\nnf: normal do ponto fonte.\nprob: Tipo de problema, pode ser potencial ou potencial_iga.\n\nRetorno\n\nRetorna a solução fundamental hipersingular calculada com base nos parâmetros fornecidos.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.center-Tuple{HyperRectangle}","page":"Reference","title":"BEM.center","text":"center(Ω)\n\nCenter of the smallest ball containing Ω.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.compress!-Tuple{BEM.RkMatrix, TSVD}","page":"Reference","title":"BEM.compress!","text":"compress!(M::RkMatrix,tsvd::TSVD)\n\nRecompress the matrix R using a truncated svd of R. The implementation uses the qr-svd strategy to efficiently compute svd(R) when rank(R) ≪ min(size(R)).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.compress!-Tuple{Matrix, TSVD}","page":"Reference","title":"BEM.compress!","text":"compress!(M::Matrix,tsvd::TSVD)\n\nRecompress the matrix M using a truncated svd and output an RkMatrix. The data in M is invalidated in the process.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.compression_ratio-Tuple{Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}}","page":"Reference","title":"BEM.compression_ratio","text":"compression_ratio(H::HTypes)\n\nThe ratio of the uncompressed size of H to its compressed size. A compression_ratio of 10 means it would have taken 10 times more memory to store H as a dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.container-Tuple{ClusterTree}","page":"Reference","title":"BEM.container","text":"container(clt::ClusterTree)\n\nReturn the object enclosing all the elements of the clt.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.criatensoes-Tuple{Any, Any}","page":"Reference","title":"BEM.criatensoes","text":"tens_nt, tens= criatensoes(dad, [-1,0,0])\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.dBernsteins-Tuple{Any, Any}","page":"Reference","title":"BEM.dBernsteins","text":"dBernsteins(p, t)\n\nCalcula a derivada das funções de Bernstein de grau p no ponto t.\n\nParâmetros\n\np::Int: O grau das funções de Bernstein.\nt::Float64: O ponto no qual a derivada será calculada.\n\nRetorno\n\ndB::Vector{Float64}: Um vetor contendo os valores das derivadas das funções de Bernstein de grau p no ponto t.\n\nExemplo\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.depth","page":"Reference","title":"BEM.depth","text":"depth(tree,acc=0)\n\nRecursive function to compute the depth of node in a a tree-like structure.\n\nOverload this function if your structure has a more efficient way to compute depth (e.g. if it stores it in a field).\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.diameter-Tuple{HyperRectangle}","page":"Reference","title":"BEM.diameter","text":"diameter(Ω)\n\nLargest distance between x and y for x,y ∈ Ω.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.distance-Tuple{ClusterTree, ClusterTree}","page":"Reference","title":"BEM.distance","text":"distance(X::ClusterTree, Y::ClusterTree)\n\nDistance between the containers of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.distance-Union{Tuple{N}, Tuple{HyperRectangle{N}, HyperRectangle{N}}} where N","page":"Reference","title":"BEM.distance","text":"distance(Ω1,Ω2)\n\nMinimal Euclidean distance between a point x ∈ Ω1 and y ∈ Ω2.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.elements-Tuple{ClusterTree}","page":"Reference","title":"BEM.elements","text":"elements(clt::ClusterTree)\n\nIterable list of the elements inside clt.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.filter_tree","page":"Reference","title":"BEM.filter_tree","text":"filter_tree(f,tree,isterminal=true)\n\nReturn a vector containing all the nodes of tree such that f(node)==true.  The argument isterminal can be used to control whether to continue the search on children of nodes for which f(node)==true.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.filter_tree!","page":"Reference","title":"BEM.filter_tree!","text":"filter_tree!(filter,nodes,tree,[isterminal=true])\n\nLike filter_tree, but appends results to nodes.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.getblock!-NTuple{4, Any}","page":"Reference","title":"BEM.getblock!","text":"getblock!(block,K,irange,jrange)\n\nFill block with K[i,j] for i ∈ irange, j ∈ jrange, where block is of size length(irange) × length(jrange).\n\nA default implementation exists which relies on getindex(K,i,j), but this method can be overloaded for better performance if e.g. a vectorized way of computing a block is available.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.getcol!-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.getcol!","text":"getcol!(col, M, j)\n\nReturn the j-th column of M in col.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.getcol!-Union{Tuple{T}, Tuple{Any, BEM.RkMatrix, Int64}, Tuple{Any, BEM.RkMatrix, Int64, Val{T}}} where T","page":"Reference","title":"BEM.getcol!","text":"getcol!(col,M::AbstractMatrix,j)\n\nFill the entries of col with column j of M.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.getcol-Tuple{Any, Any}","page":"Reference","title":"BEM.getcol","text":"getcol(M, j)\n\nReturn the j-th column of M.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.glob2loc-Tuple{ClusterTree}","page":"Reference","title":"BEM.glob2loc","text":"glob2loc(clt::ClusterTree)\n\nThe inverse of loc2glob.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.greville","page":"Reference","title":"BEM.greville","text":"greville(knots, p, β = 0.0)\n\nCalcula os nós de Greville para uma dada sequência de nós e grau da B-spline.\n\nParâmetros\n\nknots::Vector{Float64}: Vetor contendo a sequência de nós.\np::Int: Grau da B-spline.\nβ::Float64: Parâmetro opcional para ajuste dos nós de Greville. O valor padrão é 0.0.\n\nRetorno\n\nVector{Float64}: Vetor contendo os nós de Greville calculados.\n\nExemplo\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.hmul!-Union{Tuple{T}, Tuple{T, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Any, Any, Any}, Tuple{T, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Vararg{Any, 4}}, Tuple{T, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Vararg{Any, 5}}} where T<:HMatrix","page":"Reference","title":"BEM.hmul!","text":"hmul!(C::HMatrix,A::HMatrix,B::HMatrix,a,b,compressor)\n\nSimilar to mul! : compute C <-- A*B*a + C*b, where A,B,C are hierarchical matrices and compressor is a function/functor used in the intermediate stages of the multiplication to avoid growring the rank of admissible blocks after addition is performed.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.index_range-Tuple{ClusterTree}","page":"Reference","title":"BEM.index_range","text":"index_range(clt::ClusterTree)\n\nIndices of elements in root_elements(clt) which lie inside clt.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.integraelem-Tuple{Any, Any, Any, Any, Any, Union{elastico, elastico_aniso}}","page":"Reference","title":"BEM.integraelem","text":"Funcao para calcular fazer integracao no contorno \n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.integraelem-Tuple{Any, Any, Any, Any, Any, Union{helmholtz, potencial}}","page":"Reference","title":"BEM.integraelem","text":"Função para integrar elementos.\n\nParâmetros\n\npf: Coordenadas do ponto de fonte.\nx: Coordenadas dos pontos pertencentes ao elemento.\neta: Coordenadas eta dos pontos de integração.\nw: Pesos dos pontos de integração.\nelem: Elemento a ser integrado. \n`dad:: estrutura: Estrutura contendo os dados do problema.\n\nRetorno\n\nh: Valor da integral de h no elemento.\ng: Valor da integral de g no elemento.\n\nDescrição\n\nEsta função realiza a integração dos elementos fornecidos utilizando os pontos de integração e pesos especificados.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.integraelem_hiper-Tuple{Any, Any, Any, Any, Any, Any, Union{helmholtz, potencial}}","page":"Reference","title":"BEM.integraelem_hiper","text":"Função para integrar elementos considerando a solução fundamental hipersingular.\n\nParâmetros\n\npf: Coordenadas do ponto de fonte.\nx: Coordenadas dos pontos pertencentes ao elemento.\neta: Coordenadas eta dos pontos de integração.\nw: Pesos dos pontos de integração.\nelem: Elemento a ser integrado. \n`dad:: estrutura: Estrutura contendo os dados do problema.\n\nRetorno\n\nh: Valor da integral de h no elemento.\ng: Valor da integral de g no elemento.\n\nDescrição\n\nEsta função realiza a integração dos elementos fornecidos utilizando os pontos de integração e pesos especificados.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.integraelem_hiper_sing","page":"Reference","title":"BEM.integraelem_hiper_sing","text":"Função para integrar elementos singulares considerando a solução fundamental hipersingular.\n\nParâmetros\n\npf: Coordenadas do ponto de fonte.\nnf: Normal do ponto de fonte.\nx: Coordenadas dos pontos pertencentes ao elemento.\nxi0: Coordenada eta dos ponto singular.\nelem: Elemento a ser integrado. \n`dad:: estrutura: Estrutura contendo os dados do problema.\nnpg::Int=20: Número de pontos de quadratura PTVSI a serem usados para a integração numérica.\n\nRetorno\n\nh: Valor da integral de h no elemento.\ng: Valor da integral de g no elemento.\n\nDescrição\n\nEsta função realiza a integração dos elementos singulares.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.integraelemd-NTuple{4, Any}","page":"Reference","title":"BEM.integraelemd","text":"Funcao para calcular a das funções de forma\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.isclean-Tuple{HMatrix}","page":"Reference","title":"BEM.isclean","text":"isclean(H::HMatrix)\n\nReturn true if all leaves of H have data, and if the leaves are the only nodes containing data. This is the normal state of an ℋ-matrix, but during intermediate stages of a computation data may be associated with non-leaf nodes for convenience.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.lagrange-NTuple{5, Any}","page":"Reference","title":"BEM.lagrange","text":"lagrange(pg, x1, n1, x2, n2)\n\nCalcula a matriz de interpolação de Lagrange para os pontos fornecidos.\n\nParâmetros\n\npg: Matriz de pontos de grade, onde cada linha representa um ponto e cada coluna representa uma dimensão.\nx1: Vetor de coordenadas na primeira dimensão.\nn1: Número de pontos na primeira dimensão.\nx2: Vetor de coordenadas na segunda dimensão.\nn2: Número de pontos na segunda dimensão.\n\nRetorno\n\nL: Matriz de interpolação de Lagrange de tamanho (ni, n1 * n2), onde ni é o número de pontos na grade pg.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.lagrange-NTuple{7, Any}","page":"Reference","title":"BEM.lagrange","text":"lagrange(pg, x1, n1, x2, n2, x3, n3)\n\nCalcula a matriz de interpolação de Lagrange para os pontos fornecidos.\n\nParâmetros\n\npg: Matriz de pontos de grade, onde cada linha representa um ponto e cada coluna representa uma dimensão.\nx1: Vetor de coordenadas na primeira dimensão.\nn1: Número de pontos na primeira dimensão.\nx2: Vetor de coordenadas na segunda dimensão.\nn2: Número de pontos na segunda dimensão.\nx3: Vetor de coordenadas na terceira dimensão.\nn3: Número de pontos na terceira dimensão.\n\nRetorno\n\nL: Matriz de interpolação de Lagrange de tamanho (ni, n1 * n2 * n3), onde ni é o número de pontos na grade pg.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.lagrange-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.lagrange","text":"lagrange(pg, x, n)\n\nCalcula o polinômio interpolador de Lagrange.\n\nParâmetros\n\npg: Vetor de pontos de interpolação.\nx: Ponto onde o polinômio será avaliado.\nn: Número de pontos de interpolação.\n\nRetorno\n\nValor do polinômio interpolador de Lagrange avaliado em x.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.leaves-Tuple{Any}","page":"Reference","title":"BEM.leaves","text":"leaves(tree)\n\nReturn a vector containing all the leaf nodes of tree.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.loc2glob-Tuple{ClusterTree}","page":"Reference","title":"BEM.loc2glob","text":"loc2glob(clt::ClusterTree)\n\nThe permutation from the (local) indexing system of the elements of the clt to the (global) indexes used upon the construction of the tree.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.newcol!-Tuple{BEM.VectorOfVectors}","page":"Reference","title":"BEM.newcol!","text":"newcol!(A::VectorOfVectors)\n\nAppend a new (unitialized) column to A, and return a view of it.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.nodes-Tuple{Any}","page":"Reference","title":"BEM.nodes","text":"leaves(tree)\n\nReturn a vector containing all the nodes of tree.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.nosproximoskmeans","page":"Reference","title":"BEM.nosproximoskmeans","text":"indc=nosproximoskmeans(X,k=9) qr1=pqrfact(M[:,indc],rtol=1e-8) qr2=pqrfact(:c,qr1.Q,rtol=1e-8) indl=qr2.p[1:size(qr2.Q,1)] A1=M[:,indc] A2=M[indl,indc]divide M[indl,:] M=A1*A2\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.novelquad","page":"Reference","title":"BEM.novelquad","text":"f->  funçao a ser integrada m->ordem da singularidade t->posição da singularidade n->Quantidade de pontos de integração https://link.springer.com/article/10.1007/s10092-021-00446-1 t = 0.3 f1(x) = (1 + x - x^2) / (x - t)^1 f2(x) = (1 + x - x^2) / (x - t)^2 f3(x) = (1 + x - x^2) / (x - t)^3 eta, w = BEM.novelquad(2, (t - 0.5) * 2, 32) F1(x)=-(t^2 - t - 1) log(x - t) - 1/2 x (2 t + x - 2) dot(f1.(eta / 2 .+ 0.5), w) / 2-1.22523041106851637258923008288999 dot(f2.(eta / 2 .+ 0.5), w) / 2+6.42298561774988045927786175929650 dot(f3.(eta / 2 .+ 0.5), w) / 2-2.73546857952209343844408750481721\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.radius-Tuple{HyperRectangle}","page":"Reference","title":"BEM.radius","text":"radius(Ω)\n\nHalf the diameter.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.reset!-Tuple{BEM.VectorOfVectors}","page":"Reference","title":"BEM.reset!","text":"reset!(A::VectorOfVectors)\n\nSet the number of columns of A to zero, and the number of rows to zero, but does not resize! the underlying data vector.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.root_elements-Tuple{ClusterTree}","page":"Reference","title":"BEM.root_elements","text":"root_elements(clt::ClusterTree)\n\nThe elements contained in the root of the tree to which clt belongs.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.should_split","page":"Reference","title":"BEM.should_split","text":"should_split(clt::ClusterTree, depth, splitter::AbstractSplitter)\n\nDetermine whether or not a ClusterTree should be further divided.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.split!","page":"Reference","title":"BEM.split!","text":"split!(clt::ClusterTree,splitter::AbstractSplitter)\n\nDivide clt using the strategy implemented by splitter. This function is reponsible of assigning the children and parent fields, as well as of permuting the data of clt.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.use_global_index-Tuple{}","page":"Reference","title":"BEM.use_global_index","text":"use_global_index()::Bool\n\nDefault choice of whether operations will use the global indexing system throughout the package.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.use_threads-Tuple{}","page":"Reference","title":"BEM.use_threads","text":"use_threads()::Bool\n\nDefault choice of whether threads will be used throughout the package.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.verifica_contato","text":"verifica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato2-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.verifica_contato2","text":"verifica contato 2corpos\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato_incremental-NTuple{6, Any}","page":"Reference","title":"BEM.verifica_contato_incremental","text":"verifica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato_incremental2-NTuple{5, Any}","page":"Reference","title":"BEM.verifica_contato_incremental2","text":"verifica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Base.parent-Tuple{ClusterTree}","page":"Reference","title":"Base.parent","text":"parent(t::ClusterTree)\n\nThe node's parent. If t is a root, then parent(t)==t.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Base.split-Union{Tuple{N}, Tuple{HyperRectangle{N}, Any, Any}} where N","page":"Reference","title":"Base.split","text":"split(rec::HyperRectangle,[axis]::Int,[place])\n\nSplit a hyperrectangle in two along the axis direction at the  position place. Returns a tuple with the two resulting hyperrectangles.\n\nWhen no place is given, defaults to splitting in the middle of the axis.\n\nWhen no axis and no place is given, defaults to splitting along the largest axis.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.cholesky!-Tuple{Hermitian{T, HMatrix{R, T}} where {R, T}, Any}","page":"Reference","title":"LinearAlgebra.cholesky!","text":"cholesky!(M::HMatrix,comp)\n\nHierarhical cholesky facotrization of M, using comp to generate the compressed blocks during the multiplication routines.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.cholesky!-Tuple{Hermitian{T, HMatrix{R, T}} where {R, T}}","page":"Reference","title":"LinearAlgebra.cholesky!","text":"cholesky!(M::HMatrix;atol=0,rank=typemax(Int),rtol=atol>0 ||\nrank<typemax(Int) ? 0 : sqrt(eps(Float64)))\n\nHierarhical cholesky facotrization of M, using the PartialACA(;atol,rtol;rank) compressor.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.cholesky-Tuple{Hermitian{T, HMatrix{R, T}} where {R, T}, Vararg{Any}}","page":"Reference","title":"LinearAlgebra.cholesky","text":"cholesky(M::HMatrix,args...;kwargs...)\n\nHierarchical cholesky factorization. See cholesky! for the available options.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.lu!-Tuple{HMatrix, Any}","page":"Reference","title":"LinearAlgebra.lu!","text":"lu!(M::HMatrix,comp)\n\nHierarhical LU facotrization of M, using comp to generate the compressed blocks during the multiplication routines.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.lu!-Tuple{HMatrix}","page":"Reference","title":"LinearAlgebra.lu!","text":"lu!(M::HMatrix;atol=0,rank=typemax(Int),rtol=atol>0 ||\nrank<typemax(Int) ? 0 : sqrt(eps(Float64)))\n\nHierarhical LU facotrization of M, using the PartialACA(;atol,rtol;rank) compressor.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.lu-Tuple{HMatrix, Vararg{Any}}","page":"Reference","title":"LinearAlgebra.lu","text":"LinearAlgebra.lu(M::HMatrix,args...;kwargs...)\n\nHierarchical LU factorization. See lu! for the available options.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.mul!","page":"Reference","title":"LinearAlgebra.mul!","text":"mul!(y::AbstractVector,H::HMatrix,x::AbstractVector,a,b[;global_index,threads])\n\nPerform y <-- H*x*a + y*b in place.\n\n\n\n\n\n","category":"function"},{"location":"01-teoria/#Apresentação","page":"Apresentação","title":"Apresentação","text":"","category":"section"},{"location":"01-teoria/#Método-dos-elementos-de-contorno","page":"Apresentação","title":"Método dos elementos de contorno","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"O método dos elementos de contorno é bem conhecido entre engenheiros e cientistas. Ele tem demonstrado sua superioridade em relação a outros métodos numéricos, especialmente quando usado para modelar uma aplicação apropriada. Apesar da popularidade do método dos elementos de contorno, ele não é tão comum entre os engenheiros quanto o método dos elementos finitos. As razões para isso podem ser resumidas da seguinte forma:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"1- A complexidade da formulação matemática.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"2- A falta de códigos simples.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"3- A falta de  cursos de elementos de contorno entre estudantes de graduação.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"4- A dificuldade no tratamento de alguns modelos numéricos, como singularidade.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"5- A dificuldade em modificar programas de elementos de contorno em relação aos desenvolvidos usando elementos finitos.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"6- A falta de versatilidade dos códigos de elementos de contorno.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"7- A mudança de estratégia de modelagem de elementos finitos para elementos de contorno.","category":"page"},{"location":"01-teoria/#Vantagens-e-desvantagens","page":"Apresentação","title":"Vantagens e desvantagens","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"O Método dos Elementos de Contorno (BEM), como qualquer outro método numérico, tem suas vantagens e desvantagens. As vantagens do método dos elementos de contorno são as seguintes:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Apenas o contorno do problema precisa ser discretizado, o que leva a uma fácil preparação de dados e menores requisitos de computação.\nO tratamento exato de domínios infinitos e semi-infinitos.\nAs incógnitas em locais internos são calculadas na fase de pós-processamento, o que simplifica qualquer procedimento de otimização.\nResultados precisos no caso de concentrações de tensões devido a fissuras ou cargas concentradas.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Por outro lado, as desvantagens do método dos elementos de contorno são as seguintes:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"As matrizes do sistema são não simétricas e totalmente preenchidas.\nAs soluções fundamentais nem sempre são fáceis de obter.\nA dificuldade em tratar estruturas delgadas.\nA discretização do domínio necessária no caso de aplicações não lineares.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Desafios que precisam ser enfrentados para que o método tenha uma maior adesão:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Uma visão mais profunda dos aspectos matemáticos e numéricos do método.\nUm método sistemático para a derivação das soluções fundamentais e particulares.\nFórmula de integração estável.\nProgramas de uso geral e pequenos programas disponíveis para engenheiros.\nAcoplamento entre elementos de contorno e elementos finitos.","category":"page"},{"location":"01-teoria/#Por-que-JULIA?","page":"Apresentação","title":"Por que JULIA?","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"A escolha da linguagem JULIA é justificada por várias razões. JULIA é uma linguagem de programação de alto desempenho, projetada especificamente para computação científica e análise numérica. Suas bibliotecas e funcionalidades são otimizadas para realizar cálculos complexos de forma eficiente, o que é crucial para a implementação de métodos como o Método dos Elementos de Contorno (BEM). Além disso, JULIA possui uma sintaxe simples e intuitiva, o que facilita a escrita e a leitura de códigos, tornando o processo de desenvolvimento mais ágil.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Desempenho: JULIA é projetada para ter um desempenho superior em cálculos numéricos e científicos, superando Python em termos de velocidade. Isso se deve à sua capacidade de compilar código em tempo de execução, o que resulta em execução mais rápida. Python, por outro lado, pode ser mais lento devido à sua natureza interpretada, embora existam bibliotecas como Cython que ajudam a melhorar o desempenho.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Normalmente, uma linguagem é utilizada para o desenvolvimento rápido e prototipagem, enquanto a outra é usada para obter desempenho otimizado. Por exemplo, um cientista pode usar Python para escrever a lógica do código devido à sua simplicidade e riqueza de bibliotecas, mas precisará reescrever partes críticas em C ou Fortran para alcançar a velocidade necessária.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Essa abordagem tem várias desvantagens:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Complexidade de Manutenção: Manter código em duas linguagens diferentes pode ser complexo e propenso a erros, especialmente quando as mudanças precisam ser sincronizadas entre as duas versões.\nCurva de Aprendizado: Exige que os desenvolvedores sejam proficientes em ambas as linguagens, o que pode não ser sempre o caso.\nIntegração Difícil: A integração entre diferentes linguagens pode ser complicada, exigindo ferramentas e técnicas adicionais para gerenciar a comunicação entre elas.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Uma solução para esse problema é a utilização de linguagens como JULIA, que são projetadas para oferecer tanto facilidade de uso quanto alto desempenho. Isso elimina a necessidade de usar duas linguagens diferentes, simplificando o desenvolvimento, a manutenção e a execução de programas complexos.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Para instalar abra o terminal do windows e rode:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"winget install julia -s msstore\njulia","category":"page"},{"location":"01-teoria/#Formulação-do-BEM-1d","page":"Apresentação","title":"Formulação do BEM-1d","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Considere u e v como duas funções da variável independente x em um espaço unidimensional. A seguinte fórmula de integração por partes é bem conhecida:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"intlimits_x=x_1^x=x_2u(x) dv(x)=beginbmatrixu(x) v(x)endbmatrix_x=x_1^x=x_2-intlimits_x=x_1^x=x_2v(x) du(x)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"ela pode ser rescrita de maneira simplificada como:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"intlimits_x=x_1^x=x_2u(x) v(x)dx=leftu(x) v(x)right_x=x_1^x=x_2-intlimits_x=x_1^x=x_2v(x) u(x)dx","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"onde  representa a derivada. O primeiro termo do lado direito pode ser rescrito levando em conta o contorno. No caso unidimensional isso consiste exatamente nos pontos x_1 e x_2.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"beginalignedleftu(x) v(x)right_x=x_1^x=x_2 =leftu(x) v(x) n(x)right_ x=x_2+leftu(x) v(x) n(x)right_ x=x_1 Rightarrowsum_x=x_1x_2u(x)v(x)n(x)Rightarrowint_Gammau(x)v(x)n(x)dGamma endaligned","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Os demais termos tratam de uma integral no domínio e pode ser escritas como:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"intlimits_Omegau(x) v(x)dOmega=intlimits_Gammau(x) v(x)n(x)dGamma-intlimits_Omegav(x) u(x)dOmega ","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"É importante notar: 1- A ideia principal da integração por partes, é trocar o operador diferencial da função v para a função u. 2- Ao fazer essa troca, alguns termos de contorno aparecem. 3- A integração por partes foi feita apenas uma vez. No entanto, no BEM a integração por partes pode ser realizada uma, duas ou até quatro vezes dependendo da ordem da derivada. 4- Esse processo pode ser facilmente estendido para 2 ou 3 dimensões.","category":"page"},{"location":"01-teoria/#Equação-de-Laplace","page":"Apresentação","title":"Equação de Laplace","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"A formulação diferencial da equação de Laplace é dada por:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"fracd^2T(x)dx^2=0","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Usando integração por partes duas vezes na expressão dos resíduos ponderados:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"int_x_0^x_fT^*fracd^2Tdx^2dx=left( T^*fracdTdxright) ^x_f_x_0-int^x_f_x_0fracdT^*dxfracdTdxdx=left( T^*fracdTdx-TfracdT^*dxright) ^x_f_x_0-int^x_f_x_0fracd^2T^*dx^2Tdx\n","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Reescrevendo em termos do fluxo Q=fracdTdx:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"int_x_0^x_fT^*fracd^2Tdx^2dx=-left( TQ^*-T^*Qright) ^x_f_x_0-int_x_0^x_ffracd^2T^*dx^2Tdx","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Considerando que T^* é a solução fundamental do problema, ou seja:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"-fracd^2T^*(xx_d)dx^2=delta(x-x_d)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"onde delta é a função delta de Dirac.  Pode-se observar que T^*=-frac12x-x_d e Q^*=fracdT^*dx=-frac12textsign(x-x_d). Substituindo essas funções na equação integral obtém-se:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"-T(x_d)= T(x_f)Q^*(x_fx_d)-T^*(x_fx_d)Q(x_f)-T(x_0)Q^*(x_0x_d)+T^*(x_0x_d)Q(x_0)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Quando x_d é x_0 tem-se:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"T^*(x_0x_0)=0T^*(x_fx_0)=-fracx_f-x_02Q^*(x_0x_0)=frac12Q^*(x_fx_0)=-frac12","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Quando x_d é x_f tem-se:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"T^*(x_0x_f)=-fracx_f-x_02T^*(x_fx_f)=0Q^*(x_0x_f)=frac12Q^*(x_fx_f)=-frac12","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Logo, para o ponto x_d=x_0 a equação se torna:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"-T(x_0)= -T(x_f)frac12+fracx_f-x_02Q(x_f)-T(x_0)frac12+0Q(x_0)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"e para o ponto x_d=x_f","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"-T(x_f)= -T(x_f)frac12-0Q(x_f)-T(x_0)frac12-fracx_f-x_02Q(0)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Escrevendo as duas equações em forma matricial, tem-se:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"left beginmatrix05  -05 -05  05 endmatrixright left beginmatrixT(0)T(1) endmatrixright =(x_f-x_0)left beginmatrix0  -05 05  0 endmatrixright left beginmatrixQ(0)Q(1) endmatrixright ","category":"page"},{"location":"01-teoria/#Exemplos","page":"Apresentação","title":"Exemplos","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Caso 1: Condição de Dirichlet T(0)=100T(1)=0 quad T(x)=100-100x","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Caso 2: Condição mista T(0)=100Q(0)=0 quad T(x)=100","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"x0=0\nxf=1\nl=xf-x0\nA1=[0.5 -.5 0 l/2\n-.5 .5 -l/2 0\n1 0 0 0\n0 1 0 0]\nb=[0,0,100,0]\nx1=A1\\b\n\nA2=[0.5 -.5 0 l/2\n-.5 .5 -l/2 0\n1 0 0 0\n0 0 1 0]\nb=[0,0,100,0]\nx2=A2\\b","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Usando essa equação podemos calcular o valor da temperatura nos pontos internos:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"x0=0\nxf=1\nxs=range(x0,xf,length=100)\nT=0.5*(x1[1]+x1[2]).+(xs.-x0)/2*x1[3].+(xs.-xf)/2*x1[4]\nusing Plots\nplot(xs,T,legend=false,xlabel=\"x\",ylabel=\"T\",marker=:c)","category":"page"},{"location":"01-teoria/#Exercícios","page":"Apresentação","title":"Exercícios","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Uma outra possível condição de contorno é a convecção:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"q=h (T-T_infty)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"considere o problema onde o lado direito está exposto a T_infty=20textC, no lado esquerdo T(0)=100textC, e h= 3textWC. Resolva esse problema analicamente e numericamente usando BEM.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Quando existe uma fonte de calor distribuída b mais um termo aparece na equação integral:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"-T(x_d)= T(x_f)Q^*(x_fx_d)-T^*(x_fx_d)Q(x_f)-T(x_0)Q^*(x_0x_d)+T^*(x_0x_d)Q(x_0)+int_x_0^x_fT^*(xx_d)bdx","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Considere uma carga constante(isso torna a integral restante muito fácil de ser integrada analiticamente) e resolva um problema de uma grande placa de espessura L = 2 cm com condutividade térmica constante k = 1 W/m.K e geração uniforme de calor b = 1000 kW/m3. As faces A e B estão a temperaturas de 100C e 200C, respectivamente. Compare com a solução analítica:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"T=leftfracT_B-T_AL+fracb2k(L-x)rightx+T_A","category":"page"},{"location":"01-teoria/#Extra","page":"Apresentação","title":"Extra","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Quando dois corpos trocam calor por radiação, o fluxo é proporcional à diferença da quarta potência de suas temperaturas absolutas: q_n=kappa f_sf_epsilon(u^4-u_R^4) onde u, uR são as temperaturas absolutas dos corpos radiantes, 𝜅 = 5.699 × 10−8 W∕(m2 K4) é a constante de Stefan-Boltzmann, 0 ≤ fs ≤ 1 é o fator de forma da radiação e 0 < f𝜖 ≤ 1 é a emissividade superficial, definida como o poder emissivo relativo de um corpo em comparação ao de um corpo negro ideal. A emissividade superficial também é igual ao coeficiente de absorção, definido como a fração da energia térmica incidente em um corpo que é absorvida. A radiação pode ser vista como uma condição de contorno convectiva onde o coeficiente de transferência de calor convectivo depende da temperatura dos corpos radiantes. Escrevendo:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"q_n=kappa f_s f_epsilon(u^4-u_R^4)=underbracekappa f_s f_epsilon(u^2+u_R^2)(u+u_R)_h_r(u)(u-u_R)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Os problemas de radiação devem ser resolvidos por iteração: primeiro, o problema linear é resolvido, então o coeficiente de transferência de calor convectivo é atualizado e a solução é repetida. O critério de parada é baseado no tamanho da variação de temperatura. Normalmente, são necessárias poucas iterações.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Implemente essa condição de contorno no BEM.","category":"page"},{"location":"Viga de Euler/#Viga-de-euler","page":"Viga de euler","title":"Viga de euler","text":"","category":"section"},{"location":"Viga de Euler/#Teoria-de-vigas","page":"Viga de euler","title":"Teoria de vigas","text":"","category":"section"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"Considerando a viga representada a equação governante do problema pode ser escrita como : ","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"EI fracmathrmd^4umathrmdx^4=q(x)","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"A partir de u  as podemos definir:","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"varphi=fracmathrmdumathrmdxquad M=-EIfracmathrmd^2umathrmdx^2quadmathrmequad Q=-EIfracmathrmd^3umathrmdx^3","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"que são a rotação, momento fletor e cortante.","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"(Image: viga carregada)","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"usando essas definições, aplicando o método dos resíduos ponderados e integração por partes 4 vezes obtemos:","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"\\begin{aligned}u(\\xi)& =+ u^{}(\\xi,x) Q(x) \\bigg|_{x=L}- u^{}(\\xi,x) Q(x) \\bigg|{x=0} \\&-\\left.\\varphi^*(\\xi,x)M(x)\\right|{x=L}+\\left.\\varphi^(\\xi,x)M(x)\\right|_{x=0} \\&+\\left.M^{}(\\xi,x)\\varphi(x)\\right|{x=L}-\\left.M^{*}(\\xi,x)\\varphi(x)\\right|{x=0} \\&- Q^{}(\\xi,x)u(x)\\bigg|_{x=L}+ Q^{}(\\xi,x)u(x)\\bigg|{x=0} \\&+\\int{0}^{L}u^{*}(\\xi,x)q(x) \\mathrm{d}x,\\end{aligned} $","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"onde:","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"u^{}(\\xi,x)=\\frac{r^{3}}{12EI},\\\n \\varphi^{}(\\xi,x) =\\frac{r^{2}}{4EI}\\left(\\frac{\\partial r}{\\partial x}\\right), \\\nM^{}(\\xi,x) = -\\frac r2 \\left(\\frac{\\partial r}{\\partial x}\\right)^2, \\\nQ^{}(\\xi,x) = -\\frac{1}{2} \\left(\\frac{\\partial r}{\\partial x}\\right)^{3}\\text{ e }\\\nr=|x-\\xi | $","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"onde fracpartial rpartial x=-1 mathrmquad  se quad xxi e fracpartial rpartial x=1 mathrmquad  se quad xxi.","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"Para esse problema precisamos de definir mais uma equação para conseguirmos montar um sistema de equação adequado. Isso é obtido derivando a equação anterior em relação à xi:","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"\\begin{gathered}\\varphi(\\xi) =+\\left.\\frac{\\partial u^{}(\\xi,x)}{\\partial\\xi}Q(x) \\right|_{x=L}-\\left.\\frac{\\partial u^{}(\\xi,x)}{\\partial\\xi}Q(x) \\right|{x=0} \\-\\left.\\frac{\\partial\\varphi^{*}(\\xi,x)}{\\partial\\xi}M(x)\\right|{x=L}+\\left.\\frac{\\partial\\varphi^{}(\\xi,x)}{\\partial\\xi}M(x)\\right|_{x=0} \\+\\left.\\frac{\\partial M^{}(\\xi,x)}{\\partial\\xi}\\varphi(x)\\right|{x=L}-\\left.\\frac{\\partial M^{*}(\\xi,x)}{\\partial\\xi}\\varphi(x)\\right|{x=0} \\+\\int_{0}^{L}\\frac{\\partial u^{*}(\\xi,x)}{\\partial\\xi}q(x) \\mathrm{d}x, \\end{gathered} $","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"onde:","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"\\begin{aligned}&\\frac{\\partial u^{}(\\xi,x)}{\\partial\\xi}=\\frac{r^{2}}{4EI}\\left(\\frac{\\partial r}{\\partial\\xi}\\right), \\&\\frac{\\partial\\varphi^{}(\\xi,x)}{\\partial\\xi}=\\frac{r}{2EI}\\left(\\frac{\\partial r}{\\partial\\xi}\\right)\\left(\\frac{\\partial r}{\\partial x}\\right), \\&\\frac{\\partial M^{*}(\\xi, x)}{\\partial\\xi}=\\frac{1}{2}\\left(\\frac{\\partial r}{\\partial\\xi}\\right)\\left(\\frac{\\partial r}{\\partial x}\\right)^{2},\\end{aligned} $","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"onde fracpartial rpartialxi=1 mathrmquad  se quad xxi e fracpartial rpartialxi=-1 mathrmquad  se quad xxi.","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"function solfundviga(ξ, x,E,I,L)\n\tr=abs(x-ξ)\n\tif x==ξ\n\t\tif ξ==0\n\t\t\tdrdx=1\n\t\telseif ξ==L\n\t\t\tdrdx=-1\n\t\telse\n\t\t\tdrdx=0\n\t\tend\n\telse\n\t\tdrdx=(x-ξ)/r\n\tend\n\tdrdξ=-drdx\n\t\n\tu_star = r^3 / (12 * E * I)\n\tphi_star = (r^2 / (4 * E * I)) * drdx\n\tM_star = -r/2 * drdx^2\n\tQ_star = -1/2 * drdx^3\n\t\n\tdu_star_dxi = (r^2 / (4 * E * I)) * drdξ\n\tdphi_star_dxi = (r / (2 * E * I)) * drdξ * drdx\n\tdM_star_dxi = 1/2 * drdξ * drdx^2\n\t\n\tu_star ,phi_star ,M_star ,Q_star ,du_star_dxi ,dphi_star_dxi ,dM_star_dxi\nend\n","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"Considere uma viga com L=4 textm, E=50textGPa, I=00036textm^2 e uma carga pontual no centro da viga de valor 10KN.","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"L=4\nE=50e9\nIv=0.0036\n\n#solfundviga(ξ, x,E,I,L)\nu_00 ,phi_00 ,M_00 ,Q_00 ,du_00 ,dphi_00,dM_00= solfundviga(0,0,E,Iv,L)\nu_0L ,phi_0L ,M_0L ,Q_0L ,du_0L ,dphi_0L,dM_0L= solfundviga(0,L,E,Iv,L)\nu_L0 ,phi_L0 ,M_L0 ,Q_L0 ,du_L0 ,dphi_L0,dM_L0= solfundviga(L,0,E,Iv,L)\nu_LL ,phi_LL ,M_LL ,Q_LL ,du_LL ,dphi_LL,dM_LL= solfundviga(L,L,E,Iv,L)\n#multiplica U e phi\nH=-[Q_00 -M_00 -Q_0L  M_0L\n\t\t0 dM_00 0  -dM_0L\n\t\tQ_L0 -M_L0 -Q_LL  M_LL\n\t\t0 dM_L0 0  -dM_LL]\n\t\t#multiplica V e M\nG=[-u_00 phi_00 u_0L  -phi_0L\n\t\t-du_00 dphi_00 du_0L  -dphi_0L\n\t\t-u_L0 phi_L0 u_LL  -phi_LL\n\t\t-du_L0 dphi_L0 du_LL  -dphi_LL]\n\nuc0 ,phic0 ,Mc0 ,Qc0 ,duc0 ,dphic0,dMc0=solfundviga(0,L/2,E,Iv,L)\nucL ,phicL ,McL ,QcL ,ducL ,dphicL,dMcL=solfundviga(L,L/2,E,Iv,L)\nb=1e4*[uc0;duc0 ;ucL;ducL]\n\nA=[-G[:,1] H[:,2] -G[:,3] H[:,4]]\nx=A\\b\n","category":"page"},{"location":"Viga de Euler/#Exercício","page":"Viga de euler","title":"Exercício","text":"","category":"section"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"1- Generalize esse código para qualquer condição de contorno. Ele é capaz de resolver problemas hiperestáticos? Como? ","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"2- Generalize esse código para qualquer carga distribuída e compare com a solução analítica. ","category":"page"},{"location":"Viga de Euler/#Efeitos-transientes","page":"Viga de euler","title":"Efeitos transientes","text":"","category":"section"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"(Image: viga transiente)","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"\\begin{aligned}EI\\frac{\\partial^4u}{\\partial x^4}+\\rho A\\frac{\\partial^2u}{\\partial t^2}=f(x,t)\\end{aligned} $","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"Dividindo a equação por rho A e definindo","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"c=\\sqrt{\\frac{EI}{\\rho A}} $","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"obtém-se a expressão:","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"\\begin{aligned}c^2\\frac{\\partial^4u}{\\partial x^4}+\\frac{\\partial^2u}{\\partial t^2}=\\frac{f(x,t)}{\\rho A}\\end{aligned} $","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"a solução fundamental para esse problema é dada por:","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"u^{*}(x,\\xi,t,\\tau)=\\frac{1}{c}\\left{\\frac{r}{2}\\left[\\mathrm{S}\\left(\\frac{r}{\\sqrt{2\\pi a}}\\right)-\\mathrm{C}\\left(\\frac{r}{\\sqrt{2\\pi a}}\\right)\\right]+\\frac{\\sqrt{a}}{\\sqrt{2\\pi}}\\left[\\sin\\left(\\frac{r^{2}}{4a}\\right)+\\cos\\left(\\frac{r^{2}}{4a}\\right)\\right]\\right}","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"onde as funções S e C são denominadas integrais de Fresnel, r=x-xie a=c(t-tau).","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"\\begin{gathered}\\theta^{} (x,\\xi,t,\\tau) =+\\frac{1}{c}\\left{\\frac{1}{2}\\left[ \\mathrm{S}\\left(\\frac{r}{\\sqrt{2\\pi a}}\\right)-\\mathrm{C}\\left(\\frac{r}{\\sqrt{2\\pi a}}\\right)\\right]\\right}\\left(\\frac{\\partial r}{\\partial x}\\right), \\M^{}(x,\\xi,t,\\tau) =-\\frac{EI}{c}\\Bigg{\\frac{1}{2\\sqrt{2\\pi a}}\\Bigg[\\sin\\Bigg(\\frac{r^2}{4a}\\Bigg)-\\cos\\Bigg(\\frac{r^2}{4a}\\Bigg)\\Bigg]\\Bigg}\\Bigg(\\frac{\\partial r}{\\partial x}\\Bigg)^2, \\Q^{*}\\left(x,\\xi,t,\\tau\\right) =-\\frac{EI}{c}\\Bigg{\\frac{r}{4\\sqrt{2\\pi a^{3}}}\\Bigg[\\sin\\left(\\frac{r^{2}}{4a}\\right)+\\cos\\left(\\frac{r^{2}}{4a}\\right)\\Bigg]\\Bigg}\\Bigg(\\frac{\\partial r}{\\partial x}\\Bigg)^{3}, \\end{gathered} $","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"A equação integral para esse problema é dada por:","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"\\begin{aligned}u(\\xi,t)=& - \\frac{1}{\\rho A}\\int{0}^{t}\\Big[ + u^{}Q-\\theta^{}M+M^{}\\theta-Q^{}u\\Big]{x=0} \\mathrm{d}\\tau  \\&+\\frac{1}{\\rho A}\\int{0}^{t}\\Big[+u^{}Q-\\theta^{}M+M^{}\\theta-Q^{}u\\Big]{x=L} \\mathrm{d}\\tau \\&+\\frac{1}{\\rho A}\\int{0}^{t}\\int{0}^{L}u^{*}f \\mathrm{d}x \\mathrm{d}\\tau.\\end{aligned} $","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"A solução do problema, que envolve quatro incógnitas de contorno, requer ao menos duas equações integrais distintas. Assim, escreve-se, para a rotação:","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"$","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"\\begin{aligned}\\theta(\\xi,t)=& - \\frac{1}{\\rho A}\\Bigg{ \\int{0}^{t}\\Big[ \\frac{\\partial u^{}}{\\partial\\xi}Q-\\frac{\\partial \\theta^{}}{\\partial\\xi}M+\\frac{\\partial M^{}}{\\partial\\xi}\\theta-\\frac{\\partial Q^{}}{\\partial\\xi}u\\Big]{x=0} \\mathrm{d}\\tau\\Bigg} \\&+\\frac{1}{\\rho A}\\Bigg{\\int{0}^{t}\\Big[\\frac{\\partial u^{}}{\\partial\\xi}Q-\\frac{\\partial \\theta^{}}{\\partial\\xi}M+\\frac{\\partial M^{}}{\\partial\\xi}\\theta-\\frac{\\partial Q^{}}{\\partial\\xi}u\\Big]{x=L}\\mathrm{d}\\tau\\Bigg} \\&+\\frac{1}{\\rho A}\\Bigg{ \\int{0}^{t}\\int{0}^{L}\\frac{\\partial u^{*}}{\\partial\\xi}f \\mathrm{d}x \\mathrm{d}\\tau\\Bigg},\\end{aligned} $","category":"page"},{"location":"Viga de Euler/#Exercício-2","page":"Viga de euler","title":"Exercício","text":"","category":"section"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"3 - Faça um gráfico 3d de u^* e du^*dxi. Considere xi e tau iguais a zero, que o tempo varia de 0 a 10s e que o  x varia de 0 a L. Exemplo de superfície. ","category":"page"},{"location":"Viga de Euler/#Desafio","page":"Viga de euler","title":"Desafio","text":"","category":"section"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"1- Implemente um código que usando a formulação transiente e resolva um problema de vibração livre.","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"2-Esse problema também pode ser resolvido usando a solução fundamental estática e uma integral de domínio como feito para o problema de Poisson. Faça isso usando Houbolt e compare.","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"Compare com uma solução analítica disponível no Rao","category":"page"},{"location":"Viga de Euler/","page":"Viga de euler","title":"Viga de euler","text":"3-Implemente a formulação da viga de Timoshenko e de BICKFORD-REDDY e compare as três para diferentes tamanhos de viga.","category":"page"},{"location":"90-contributing/#contributing","page":"Contributing guidelines","title":"Contributing guidelines","text":"","category":"section"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"First of all, thanks for the interest!","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"Be polite and respectful, and follow the code of conduct.","category":"page"},{"location":"90-contributing/#Bug-reports-and-discussions","page":"Contributing guidelines","title":"Bug reports and discussions","text":"","category":"section"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you think you found a bug, feel free to open an issue. Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please.","category":"page"},{"location":"90-contributing/#Working-on-an-issue","page":"Contributing guidelines","title":"Working on an issue","text":"","category":"section"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it.","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"tip: Tip\nFeel free to ping us after a few days if there are no responses.","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If your solution involves code (or something that requires running the package locally), check the developer documentation. Otherwise, you can use the GitHub interface directly to create your pull request.","category":"page"},{"location":"10-exemplos/#exemplos","page":"Exemplos","title":"Exemplos","text":"","category":"section"},{"location":"10-exemplos/","page":"Exemplos","title":"Exemplos","text":"testes","category":"page"},{"location":"10-exemplos/","page":"Exemplos","title":"Exemplos","text":"Here's some inline maths: sqrtn1 + x + x^2 + ldots.","category":"page"},{"location":"#BEM","page":"BEM","title":"BEM","text":"","category":"section"},{"location":"","page":"BEM","title":"BEM","text":"Documentação do BEM.","category":"page"}]
}
