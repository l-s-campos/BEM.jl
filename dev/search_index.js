var documenterSearchIndex = {"docs":
[{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"Pages = [\"95-reference.md\"]","category":"section"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"Pages = [\"95-reference.md\"]","category":"section"},{"location":"95-reference/#BEM.AbstractCompressor","page":"Reference","title":"BEM.AbstractCompressor","text":"abstract type AbstractCompressor\n\nTypes used to compress matrices.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.AbstractKernelMatrix","page":"Reference","title":"BEM.AbstractKernelMatrix","text":"abstract type AbstractKernelMatrix{T} <: AbstractMatrix{T}\n\nInterface for abstract matrices represented through a kernel function f, target elements X, and source elements Y. The matrix entry i,j is given by f(X[i],Y[j]). Concrete subtypes should implement at least\n\n`Base.getindex(K::AbstractKernelMatrix,i::Int,j::Int)`\n\nIf a more efficient implementation of getindex(K,I::UnitRange,I::UnitRange), getindex(K,I::UnitRange,j::Int) and getindex(adjoint(K),I::UnitRange,j::Int) is available (e.g. with SIMD vectorization), implementing such methods can improve the speed of assembling an HMatrix.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.AbstractSplitter","page":"Reference","title":"BEM.AbstractSplitter","text":"abstract type AbstractSplitter\n\nAn AbstractSplitter is used to split a ClusterTree. The interface requires the following methods:\n\nshould_split(clt,splitter) : return a Bool determining if the ClusterTree should be further divided\nsplit!(clt,splitter) : perform the splitting of the ClusterTree handling the necessary data sorting.\n\nSee GeometricSplitter for an example of an implementation.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.CardinalitySplitter","page":"Reference","title":"BEM.CardinalitySplitter","text":"struct CardinalitySplitter <: AbstractSplitter\n\nUsed to split a ClusterTree along the largest dimension if length(tree)>nmax. The split is performed so the data is evenly distributed amongst all children.\n\nSee also: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.ClusterTree","page":"Reference","title":"BEM.ClusterTree","text":"ClusterTree(elements,splitter;[copy_elements=true, threads=false])\n\nConstruct a ClusterTree from the  given elements using the splitting strategy encoded in splitter. If copy_elements is set to false, the elements argument are directly stored in the ClusterTree and are permuted during the tree construction.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.ClusterTree-2","page":"Reference","title":"BEM.ClusterTree","text":"mutable struct ClusterTree{N,T}\n\nTree structure used to cluster poitns of type SVector{N,T} into HyperRectangles.\n\nFields:\n\n_elements::Vector{SVector{N,T}} : vector containing the sorted elements.\ncontainer::HyperRectangle{N,T} : container for the elements in the current node.\nindex_range::UnitRange{Int} : indices of elements contained in the current node.\nloc2glob::Vector{Int} : permutation from the local indexing system to the original (global) indexing system used as input in the construction of the tree.\nglob2loc::Vector{Int} : inverse of loc2glob permutation.\nchildren::Vector{ClusterTree{N,T}}\nparent::ClusterTree{N,T}\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.DHMatrix","page":"Reference","title":"BEM.DHMatrix","text":"mutable struct DHMatrix{R,T} <: AbstractMatrix{T}\n\nConcrete type representing a hierarchical matrix with data distributed amongst various workers. Its structure is very similar to HMatrix, except that the leaves store a RemoteHMatrix object.\n\nThe data on the leaves of a DHMatrix may live on a different worker, so calling fetch on them should be avoided whenever possible.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.DHMatrix-Union{Tuple{T}, Tuple{R}, Tuple{R, R}} where {R, T}","page":"Reference","title":"BEM.DHMatrix","text":"DHMatrix{T}(rowtree,coltree;partition_strategy=:distribute_columns)\n\nConstruct the block structure of a distributed hierarchical matrix covering rowtree and coltree. Returns a DHMatrix with leaves that are empty.\n\nThe partition_strategy keyword argument determines how to partition the blocks for distributed computing. Currently, the only available options is distribute_columns, which will partition the columns of the underlying matrix into floor(log2(nw)) parts, where nw is the number of workers available.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.GeometricSplitter","page":"Reference","title":"BEM.GeometricSplitter","text":"struct GeometricSplitter <: AbstractSplitter\n\nUsed to split a ClusterTree in half along the largest axis. The children boxes are shrank to tighly fit the data.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.HMatrix","page":"Reference","title":"BEM.HMatrix","text":"mutable struct HMatrix{R,T} <: AbstractMatrix{T}\n\nA hierarchial matrix constructed from a rowtree and coltree of type R and holding elements of type T.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.HMatrix-Union{Tuple{T}, Tuple{R}, Tuple{R, R, Any}} where {R, T}","page":"Reference","title":"BEM.HMatrix","text":"HMatrix{T}(rowtree,coltree,adm)\n\nConstruct an empty HMatrix with rowtree and coltree using the admissibility condition adm. This function builds the skeleton for the hierarchical matrix, but does not compute data field in the blocks. See assemble_hmatrix for assembling a hierarhical matrix.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.HyperRectangle","page":"Reference","title":"BEM.HyperRectangle","text":"struct HyperRectangle{N,T}\n\nAxis-aligned hyperrectangle in N dimensions given by low_corner::SVector{N,T} and high_corner::SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.KernelMatrix","page":"Reference","title":"BEM.KernelMatrix","text":"KernelMatrix{Tf,Tx,Ty,T} <:: AbstractKernelMatrix{T}\n\nGeneric kernel matrix representing a kernel function acting on two sets of elements. If K is a KernelMatrix, then K[i,j] = f(X[i],Y[j]) where f::Tf=kernel(K), X::Tx=rowelements(K) and Y::Ty=colelements(K).\n\nExamples\n\nX = rand(SVector{2,Float64},2)\nY = rand(SVector{2,Float64},2)\nK = KernelMatrix(X,Y) do x,y\n    sum(x+y)\nend\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.MulLinearOp","page":"Reference","title":"BEM.MulLinearOp","text":"struct MulLinearOp{R,T} <: AbstractMatrix{T}\n\nAbstract matrix representing the following linear operator:\n\n    L = R + P + a * ∑ᵢ Aᵢ * Bᵢ\n\nwhere R and P are of type RkMatrix{T}, Aᵢ,Bᵢ are of type HMatrix{R,T} and a is scalar multiplier. Calling compressor(L) produces a low-rank approximation of L, where compressor is an AbstractCompressor.\n\nNote: this structure is used to group the operations required when multiplying hierarchical matrices so that they can later be executed in a way that minimizes recompression of intermediate computations.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.PartialACA","page":"Reference","title":"BEM.PartialACA","text":"struct PartialACA\n\nAdaptive cross approximation algorithm with partial pivoting. This structure can be used to generate an RkMatrix from a matrix-like object M as follows:\n\nusing LinearAlgebra\nrtol = 1e-6\ncomp = PartialACA(;rtol)\nA = rand(10,2)\nB = rand(10,2)\nM = A*adjoint(B) # a low-rank matrix\nR = comp(M, axes(M)...) # compress the entire matrix `M`\nnorm(Matrix(R) - M) < rtol*norm(M) # true\n\n# output\n\ntrue\n\n\nBecause it uses partial pivoting, the linear operator does not have to be evaluated at every i,j. This is usually much faster than TSVD, but due to the pivoting strategy the algorithm may fail in special cases, even when the underlying linear operator is of low rank.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.PermutedMatrix","page":"Reference","title":"BEM.PermutedMatrix","text":"PermutedMatrix{K,T} <: AbstractMatrix{T}\n\nStructured used to reprensent the permutation of a matrix-like object. The original matrix is stored in the data::K field, and the permutations are stored in rowperm and colperm.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.PrincipalComponentSplitter","page":"Reference","title":"BEM.PrincipalComponentSplitter","text":"struct PrincipalComponentSplitter <: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.RemoteHMatrix","page":"Reference","title":"BEM.RemoteHMatrix","text":"struct RemoteHMatrix{S,T}\n\nA light wrapper for a Future storing an HMatrix.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.RkMatrix","page":"Reference","title":"BEM.RkMatrix","text":"mutable struct RkMatrix{T}\n\nRepresentation of a rank r matrix M in outer product format M = A*adjoint(B) where A has size m × r and B has size n × r.\n\nThe internal representation stores A and B, but R.Bt or R.At can be used to get the respective adjoints.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.StrongAdmissibilityStd","page":"Reference","title":"BEM.StrongAdmissibilityStd","text":"struct StrongAdmissibilityStd\n\nTwo blocks are admissible under this condition if the minimum of their diameter is smaller than eta times the distance between them, where eta::Float64 is a parameter.\n\nUsage:\n\nadm = StrongAdmissibilityStd(;eta=2.0)\nadm(Xnode,Ynode)\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.TSVD","page":"Reference","title":"BEM.TSVD","text":"struct TSVD\n\nCompression algorithm based on a posteriori truncation of an SVD. This is the optimal approximation in Frobenius norm; however, it also tends to be very expensive and thus should be used mostly for \"small\" matrices.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.VectorOfVectors","page":"Reference","title":"BEM.VectorOfVectors","text":"struct VectorOfVectors{T}\n\nA simple structure which behaves as a Vector{Vector{T}} but stores the entries in a contiguous data::Vector{T} field. All vectors in the VectorOfVectors are assumed to be of size m, and there are k of them, meaning this structure can be used to represent a m × k matrix.\n\nSimilar to a vector-of-vectors, calling A[i] returns a view to the i-th column.\n\nSee also: newcol!\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.WeakAdmissibilityStd","page":"Reference","title":"BEM.WeakAdmissibilityStd","text":"struct WeakAdmissibilityStd\n\nTwo blocks are admissible under this condition if the distance between them is positive.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#Base.Matrix-Tuple{Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}}","page":"Reference","title":"Base.Matrix","text":"Matrix(H::HMatrix;global_index=true)\n\nConvert H to a Matrix. If global_index=true (the default), the entries are given in the global indexing system (see HMatrix for more information); otherwise the local indexing system induced by the row and columns trees are used.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.Bernsteins-Tuple{Any, Any}","page":"Reference","title":"BEM.Bernsteins","text":"Bernsteins(p, t)\n\nCalcula os polinômios de Bernstein para um dado grau p e parâmetro t.\n\nParâmetros\n\np::Int: Grau do polinômio de Bernstein.\nt::Float64: Parâmetro no qual o polinômio de Bernstein será avaliado.\n\nRetorno\n\nh::Float64: Resultado da avaliação do polinômio de Bernstein.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.Contato_NL_newton2-NTuple{5, Any}","page":"Reference","title":"BEM.Contato_NL_newton2","text":"Resolve numericamente um problema não-linear com condições de contato utilizando o método de Newton.\n\nArgumentos:\n\ndad: Estrutura de dados\nx0: Chute inicial para a solução.\nA2: Matriz do BEM\nb2: Vetor do BEM\nh: variável com as informações sobre o contato\nmaxiter (opcional): Número máximo de iterações do método de Newton.\ntol (opcional): Tolerância para o erro, utilizada como critério de parada.\n\nRetorno:\n\nx: Solução aproximada do problema, ou o último chute se o critério de parada não for satisfeito.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.FeD-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.FeD","text":"A função FeD calcula duas matrizes, F e D, com base nas coordenadas dos nós fornecidos.\n\nParâmetros\n\ndad: Estrutura de dados k.\nnodes: Matriz n x 2 onde cada linha representa as coordenadas (x, y) de um nó.\n\nRetorno\n\nF: Matriz n x n onde cada elemento F[i, j] é o resultado da função interpola aplicada à distância entre os nós i e j.\nD: Matriz n x n onde cada elemento D[i, j] é o valor -log(r) / (2 * π * dad.k), sendo r a distância entre os nós i e j.\n\nNotas\n\nA função ignora a diagonal principal das matrizes F e D (onde i == j).\nA função interpola deve ser definida em outro lugar no código.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.FeD2-Tuple{Any, Any}","page":"Reference","title":"BEM.FeD2","text":"A função FeD calcula duas matrizes, F e D, com base nas coordenadas dos nós fornecidos.\n\nParâmetros\n\ndad: Estrutura de dados k.\nnodes: Matriz n x 2 onde cada linha representa as coordenadas (x, y) de um nó.\n\nRetorno\n\nF: Matriz n x n onde cada elemento F[i, j] é o resultado da função interpola aplicada à distância entre os nós i e j.\nD: Matriz n x n onde cada elemento D[i, j] é o valor -log(r) / (2 * π * dad.k), sendo r a distância entre os nós i e j.\n\nNotas\n\nA função ignora a diagonal principal das matrizes F e D (onde i == j).\nA função interpola deve ser definida em outro lugar no código.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.Monta_M_RIMd-Tuple{potencial, Any}","page":"Reference","title":"BEM.Monta_M_RIMd","text":"Monta_M_RIMd(dad::potencial, npg)\n\nFunção que monta a matriz M utilizando o DIBEM (Direct interpolation method).\n\nParâmetros\n\ndad::potencial: Estrutura de dados contendo as informações do problema potencial.\nnpg: Número de pontos de Gauss para integração.\n\nRetorno\n\nMatriz A resultante da montagem utilizando o método RIMd.\n\nDescrição\n\nA função realiza os seguintes passos:\n\nCalcula o número de nós (n_nos), elementos (nelem) e nós internos (n_noi).\nCalcula as matrizes de funções radiais F  e das soluções fundamentais D utilizando a função FeD.\nCalcula as matrizes M e M1 utilizando a função calcMs.\nMonta a matriz A utilizando as matrizes M, F e D.\nAjusta os elementos da diagonal principal de A.\nRetorna a matriz A somada com a matriz diagonal M1.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.Monta_M_RIMd_hermite-Tuple{potencial, Any}","page":"Reference","title":"BEM.Monta_M_RIMd_hermite","text":"Monta_M_RIMd(dad::potencial, npg)\n\nFunção que monta a matriz M utilizando o DIBEM (Direct interpolation method).\n\nParâmetros\n\ndad::potencial: Estrutura de dados contendo as informações do problema potencial.\nnpg: Número de pontos de Gauss para integração.\n\nRetorno\n\nMatriz A resultante da montagem utilizando o método RIMd.\n\nDescrição\n\nA função realiza os seguintes passos:\n\nCalcula o número de nós (n_nos), elementos (nelem) e nós internos (n_noi).\nCalcula as matrizes de funções radiais F  e das soluções fundamentais D utilizando a função FeD.\nCalcula as matrizes M e M1 utilizando a função calcMs.\nMonta a matriz A utilizando as matrizes M, F e D.\nAjusta os elementos da diagonal principal de A.\nRetorna a matriz A somada com a matriz diagonal M1.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.Nlinear-Tuple{Any}","page":"Reference","title":"BEM.Nlinear","text":"Calcula as funções de forma lineares contínuas N1 e N2\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._aca_partial","page":"Reference","title":"BEM._aca_partial","text":"_aca_partial(K,irange,jrange,atol,rmax,rtol,istart=1)\n\nInternal function implementing the adaptive cross-approximation algorithm with partial pivoting. The returned R::RkMatrix provides an approximation to K[irange,jrange] which has either rank is expected to satisfy|M - R| < max(atol,rtol*|M|)`, but this inequality may fail to hold due to the various errors involved in estimating the error and |M|.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM._aca_partial_pivot-Tuple{Any, Any}","page":"Reference","title":"BEM._aca_partial_pivot","text":"_aca_partial_pivot(v,I)\n\nFind in the valid set I the index of the element x ∈ v maximizing its smallest singular value. This is equivalent to minimizing the spectral norm of the inverse of x.\n\nWhen x is a scalar, this is simply the element with largest absolute value.\n\nThis general implementation should work for both scalar as well as tensor-valued kernels; see (https://www.sciencedirect.com/science/article/pii/S0021999117306721)[https://www.sciencedirect.com/science/article/pii/S0021999117306721] for more details.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._assemble_cpu!-NTuple{4, Any}","page":"Reference","title":"BEM._assemble_cpu!","text":"_assemble_cpu!(hmat::HMatrix,K,comp)\n\nAssemble data on the leaves of hmat. The admissible leaves are compressed using the compressor comp. This function assumes the structure of hmat has already been intialized, and therefore should not be called directly. See HMatrix information on constructors.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._assemble_hmat_distributed-Tuple{Any, Any, Any}","page":"Reference","title":"BEM._assemble_hmat_distributed","text":"_assemble_hmat_distributed(K,rtree,ctree;adm=StrongAdmissibilityStd(),comp=PartialACA();global_index=true,threads=false)\n\nInternal methods called after the DHMatrix structure has been initialized in order to construct the HMatrix on each of the leaves of the DHMatrix.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._assemble_threads!-Tuple{Any, Any, Any}","page":"Reference","title":"BEM._assemble_threads!","text":"_assemble_threads!(hmat::HMatrix,K,comp)\n\nLike _assemble_cpu!, but uses threads to assemble the leaves. Note that the threads are spawned using Threads.@spawn, which means they are spawned on the same worker as the caller.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._build_block_structure!-Union{Tuple{T}, Tuple{R}, Tuple{Any, HMatrix{R, T}}} where {R, T}","page":"Reference","title":"BEM._build_block_structure!","text":"_build_block_structure!(adm_fun,current_node)\n\nRecursive constructor for HMatrix block structure. Should not be called directly.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._hgemv_recursive!-Tuple{AbstractVector, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, AbstractVector, Any}","page":"Reference","title":"BEM._hgemv_recursive!","text":"_hgemv_recursive!(C,A,B,offset)\n\nInternal function used to compute C[I] <-- C[I] + A*B[J] where I = rowrange(A) - offset[1] and J = rowrange(B) - offset[2].\n\nThe offset argument is used on the caller side to signal if the original hierarchical matrix had a pivot other than (1,1).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._update_frob_norm-Tuple{Any, Any, Any}","page":"Reference","title":"BEM._update_frob_norm","text":"_update_frob_norm(acc,A,B)\n\nGiven the Frobenius norm of Rₖ = A[1:end-1]*adjoint(B[1:end-1]) in acc, compute the Frobenius norm of Rₖ₊₁ = A*adjoint(B) efficiently.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato!-NTuple{5, Any}","page":"Reference","title":"BEM.aplica_contato!","text":"aplica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato2!-NTuple{5, Any}","page":"Reference","title":"BEM.aplica_contato2!","text":"aplica contato 2corpos\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato_incremental!-NTuple{8, Any}","page":"Reference","title":"BEM.aplica_contato_incremental!","text":"aplica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato_incremental2!-NTuple{7, Any}","page":"Reference","title":"BEM.aplica_contato_incremental2!","text":"aplica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.assemble_hmatrix-Tuple{AbstractKernelMatrix}","page":"Reference","title":"BEM.assemble_hmatrix","text":"assembel_hmatrix(K::AbstractKernelMatrix[; atol, rank, rtol, kwargs...])\n\nConstruct an approximation of K as an HMatrix using the partial ACA algorithm for the low rank blocks. The atol, rank, and rtol optional arguments are passed to the PartialACA constructor, and the remaining keyword arguments are forwarded to the main assemble_hmatrix function.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.assemble_hmatrix-Union{Tuple{T}, Tuple{Type{T}, Any, Any, Any}} where T","page":"Reference","title":"BEM.assemble_hmatrix","text":"assemble_hmatrix([T,], K, rowtree, coltree;\n    adm=StrongAdmissibilityStd(),\n    comp=PartialACA(),\n    threads=true,\n    distributed=false,\n    global_index=true)\n\nMain routine for assembling a hierarchical matrix. The argument K represents the matrix to be approximated, rowtree and coltree are tree structure partitioning the row and column indices, respectively, adm can be called on a node of rowtree and a node of coltree to determine if the block is compressible, and comp is a function/functor which can compress admissible blocks.\n\nIt is assumed that K supports getindex(K,i,j), and that comp can be called as comp(K,irange::UnitRange,jrange::UnitRange) to produce a compressed version of K[irange,jrange] in the form of an RkMatrix.\n\nThe type paramter T is used to specify the type of the entries of the matrix, by default is inferred from K using eltype(K).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.bclag_interp_matrix","page":"Reference","title":"BEM.bclag_interp_matrix","text":"M = bclag_interp_matrix(x, xx [, w])\n\nCompute the matrix M such that ff = M*f gives the barycentric Lagrange interpolation of f from points x to points xx.\n\nw is vector of weights, w = bclag_interp_weights(x) \n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.bclag_interp_matrix_deriv","page":"Reference","title":"BEM.bclag_interp_matrix_deriv","text":"M = bclag_interp_matrix(x, xx [, w])\n\nCompute the matrix M such that ff = M*f gives the barycentric Lagrange interpolation of f from points x to points xx.\n\nw is vector of weights, w = bclag_interp_weights(x) \n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.bclag_interp_weights-Tuple{Vector}","page":"Reference","title":"BEM.bclag_interp_weights","text":"w = bclag_interp_weights(x)\n\nCompute weights for Barycentric Lagrange interpolation.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.binary_split!-Union{Tuple{T}, Tuple{N}, Tuple{ClusterTree{N, T}, Function}} where {N, T}","page":"Reference","title":"BEM.binary_split!","text":"binary_split!(cluster::ClusterTree,predicate)\n\nSplit a ClusterTree into two, sorting all elements in the process according to predicate. cluster is assigned as parent to each children.\n\nEach point is sorted according to whether f(x) returns true (point sorted on the \"left\" node) or false (point sorted on the \"right\" node). At the end a minimal HyperRectangle containing all left/right points is created.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calcMs-Tuple{potencial, Any, Any}","page":"Reference","title":"BEM.calcMs","text":"calcMs(dad::potencial, npg)\n\nCalcula os valores das matrizes M e M1 para um dado potencial dad utilizando a quadratura de Gauss-Legendre com npg pontos.\n\nParâmetros\n\ndad::potencial: Estrutura contendo os dados do problema, incluindo nós (NOS), pontos internos (pontos_internos), elementos (ELEM) e constante k.\nnpg: Número de pontos de Gauss-Legendre a serem utilizados na quadratura.\n\nRetorno\n\nM: Vetor com as integrais das funções radiais calculados para cada ponto fonte.\nM1: Vetor com as integrais das soluções fundamentais calculados para cada ponto fonte.\n\nDescrição\n\nA função percorre todos os pontos radiais e elementos do problema, calculando os valores das matrizes M e M1 através da função calc_md, que utiliza a quadratura de Gauss-Legendre para integração numérica. Os resultados são acumulados nos vetores M e M1 e retornados ao final da execução.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calcPs-Tuple{potencial, Any}","page":"Reference","title":"BEM.calcPs","text":"calcPs(dad::potencial, npg)\n\nCalcula os valores das matrizes P e Pint para um dado potencial dad utilizando a quadratura de Gauss-Legendre com npg pontos.\n\nParâmetros\n\ndad::potencial: Estrutura contendo os dados do problema, incluindo nós (NOS), pontos internos (pontos_internos), elementos (ELEM) e constante k.\nnpg: Número de pontos de Gauss-Legendre a serem utilizados na quadratura.\n\nRetorno\n\nP: Vetor com as funções polinomiais para cada ponto fonte.\nPint: Vetor com as integrais de cada polinomio.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calc_Aeb","page":"Reference","title":"BEM.calc_Aeb","text":"calc_Aeb(dad::Union{potencial, helmholtz}, npg=8)\n\nCalcula a matriz A e o velor b para os dados fornecidos.\n\nParâmetros\n\ndad::Union{potencial, helmholtz}: Tipo de dado que pode ser potencial ou helmholtz.\nnpg: Número de pontos de Gauss (opcional, padrão é 8).\n\nRetorna\n\nA matriz A e o vetor b calculados com base nos parâmetros fornecidos.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_HeG","page":"Reference","title":"BEM.calc_HeG","text":"calc_HeG(dad::potencial, npg=8; Pint=false)\n\nCalcula as matrizes H e G para o problema de potencial usando o Método dos Elementos de Contorno (BEM).\n\nArgumentos\n\ndad::potencial: Os dados do problema de potencial, que incluem os elementos (ELEM) e nós (NOS).\nnpg::Int=8: O número de pontos de quadratura de Gauss-Legendre a serem usados para a integração numérica.\nPint::Bool=false: Uma flag para indicar se deve usar pontos internos (o padrão é falso).\n\nRetornos\n\nH::Matrix{Float64}: A matriz H.\nG::Matrix{Float64}: A matriz G.\n\nDescrição\n\nEsta função calcula as matrizes H e G para um dado problema de potencial usando o Método dos Elementos de Contorno (BEM).  Ela itera sobre os pontos fontes e elementos, realiza a integração numérica usando a quadratura de Gauss-Legendre,  e preenche as matrizes H e G com os valores computados.\n\nExemplo\n\n```julia H, G = calc_HeG(dad, 8)\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_HeG_hiper","page":"Reference","title":"BEM.calc_HeG_hiper","text":"calc_HeG_hiper(dad::potencial, npg=8)\n\nCalcula as matrizes H e G hiper-singulares para o problema de potencial usando o Método dos Elementos de Contorno (BEM).\n\nArgumentos\n\ndad::potencial: Os dados do problema de potencial, que incluem os elementos (ELEM) e nós (NOS).\nnpg::Int=8: O número de pontos de quadratura de Gauss-Legendre a serem usados para a integração numérica.\n\nRetornos\n\nH::Matrix{Float64}: A matriz H hiper-singular.\nG::Matrix{Float64}: A matriz G hiper-singular.\n\nDescrição\n\nEsta função calcula as matrizes H e G hiper-singulares para um dado problema de potencial usando o Método dos Elementos de Contorno (BEM).  Ela itera sobre os pontos fontes e elementos, realiza a integração numérica usando a quadratura de Gauss-Legendre,  e preenche as matrizes H e G com os valores computados.\n\nExemplo\n\n```julia H, G = calc_HeG(dad, 8)\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_Ti","page":"Reference","title":"BEM.calc_Ti","text":"calc_Ti(dad::Union{potencial, helmholtz}, T, q, npg=8)\n\nCalcula a matriz Ti com as temperaturas nos pontos internos para um dado problema de potencial ou Helmholtz.\n\nParâmetros\n\ndad::Union{potencial, helmholtz}: Estrutura contendo os dados do problema, incluindo elementos, nós e pontos internos.\nT: Vetor de temperaturas nos nós.\nq: Vetor de fluxos de calor nos nós.\nnpg: Número de pontos de Gauss para a quadratura (padrão é 8).\n\nRetorno\n\nTi: Vetor resultante após a integração dos elementos.\n\nDescrição\n\nA função percorre todos os pontos internos e elementos do contorno, calculando a contribuição de cada elemento para o vetor Ti utilizando a quadratura de Gauss. Para cada ponto interno, a função:\n\nObtém a coordenada do ponto fonte.\nPercorre todos os elementos do contorno.\nCalcula as coordenadas dos nós geométricos do elemento.\nCalcula a transformação de coordenadas e os fatores de forma.\nRealiza a integração dos elementos utilizando a quadratura de Gauss.\nAtualiza o vetor Ti com as contribuições de cada elemento.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_Ti-2","page":"Reference","title":"BEM.calc_Ti","text":"calc_Ti(dad::potencial_iga, T, q, npg = 8)\n\nCalcula a matriz Ti com as temperaturas nos pontos internos para um dado problema de potencial com elementos de contorno isogeométricos.\n\nParâmetros\n\ndad::Union{potencial, helmholtz}: Estrutura contendo os dados do problema, incluindo elementos, nós e pontos internos.\nT: Vetor de temperaturas nos nós.\nq: Vetor de fluxos de calor nos nós.\nnpg: Número de pontos de Gauss para a quadratura (padrão é 8).\n\nRetorno\n\nTi: Vetor resultante após a integração dos elementos.\n\nDescrição\n\nA função percorre todos os pontos internos e elementos do contorno, calculando a contribuição de cada elemento para o vetor Ti utilizando a quadratura de Gauss. Para cada ponto interno, a função:\n\nObtém a coordenada do ponto fonte.\nPercorre todos os elementos do contorno.\nCalcula as coordenadas dos nós geométricos do elemento.\nCalcula a transformação de coordenadas e os fatores de forma.\nRealiza a integração dos elementos utilizando a quadratura de Gauss.\nAtualiza o vetor Ti com as contribuições de cada elemento.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_fforma","page":"Reference","title":"BEM.calc_fforma","text":"calc_fforma(ξ, elem, deriv = true)\n\nCalcula as funções de forma polinomiais gerais.\n\nParâmetros\n\nξ: Ponto de avaliação.\nelem: Estrutura que contém os pontos nodais ξs.\nderiv: Booleano que indica se a derivada das funções de forma deve ser calculada. O padrão é true.\n\nRetorno\n\nSe deriv for true, retorna uma tupla (N, dN) onde N é o vetor das funções de forma e dN é o vetor das derivadas das funções de forma.\nSe deriv for false, retorna apenas N.\n\nNotas\n\nAs funções de forma são calculadas usando o interpolador de Lagrange.\nSe ξ for igual a algum dos pontos nodais ξs, um pequeno valor é adicionado a ξ para evitar divisão por zero.\n\nExemplo\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_fforma-Tuple{Any, BEM.bezier, Any}","page":"Reference","title":"BEM.calc_fforma","text":"calc_fforma(t, elem_j::bezier, w)\n\nCalcula a forma de função para um elemento de Bézier.\n\nParâmetros\n\nt: Ponto de avaliação.\nelem_j::bezier: Elemento de Bézier.\nw: Peso associado ao ponto de avaliação.\n\nRetorno\n\nRetorna a forma de função calculada no ponto t para o elemento elem_j com o peso w.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calc_fforma_gen","page":"Reference","title":"BEM.calc_fforma_gen","text":"calc_fforma_gen(ξ, ξs, deriv = true)\n\nCalcula as funções de forma gerais para elementos de um método numérico.\n\nParâmetros\n\nξ: Ponto de avaliação.\nξs: Vetor contendo as coordenadas dos nós.\nderiv: Booleano opcional que indica se a derivada das funções de forma deve ser calculada. O padrão é true.\n\nRetorno\n\nSe deriv for true, retorna uma tupla (N, dN), onde N é o vetor das funções de forma e dN é o vetor das derivadas das funções de forma.\nSe deriv for false, retorna apenas N.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.calc_md-NTuple{8, Any}","page":"Reference","title":"BEM.calc_md","text":"calc_md(x, pf, k, qsi, w, elem)\n\nCalcula o potencial e a sua derivada normal em um ponto fonte pf devido a um elemento elem.\n\nParâmetros\n\nx::Vector{Float64}: Coordenadas dos nós do elemento.\npf::Vector{Float64}: Coordenadas do ponto fonte.\nk::Float64: Coeficiente de condutividade térmica.\nqsi::Vector{Float64}: Pontos de Gauss para integração.\nw::Vector{Float64}: Pesos de Gauss para integração.\nelem: Dados do elemento \n\nRetorna\n\nm_el::Float64: Integral no elemento da função de base radial.\nm_el1::Float64: Integral no elemento da soluçao fundamental.\n\nDescrição\n\nA função calc_md realiza a integração numérica utilizando a técnica dos pontos de Gauss para calcular o potencial e sua derivada normal em um ponto fonte pf devido a um elemento elem. A função utiliza as funções de forma N e suas derivadas dN_geo para interpolar os pontos de Gauss e calcular as distâncias e vetores normais necessários para a integração. O resultado é o potencial m_el e sua derivada normal m_el1 no ponto fonte pf.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calsolfund-Tuple{Any, Any, Union{potencial, potencial_iga}, Any}","page":"Reference","title":"BEM.calsolfund","text":"calsolfund(r, n prob::Union{potencial,potencial_iga})\n\nCalcula a solução fundamental.\n\nParâmetros\n\nr: Distância radial.\nn: normal do ponto de integração.\nprob: Tipo de problema, pode ser potencial ou potencial_iga.\n\nRetorno\n\nRetorna a solução fundamental calculada com base nos parâmetros fornecidos.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.calsolfund_hiper-Tuple{Any, Any, Any, Union{potencial, potencial_iga}}","page":"Reference","title":"BEM.calsolfund_hiper","text":"calsolfund_hiper(r, n, nf, prob::Union{potencial,potencial_iga})\n\nCalcula a solução fundamental hipersingular.\n\nParâmetros\n\nr: Distância radial.\nn: normal do ponto de integração.\nnf: normal do ponto fonte.\nprob: Tipo de problema, pode ser potencial ou potencial_iga.\n\nRetorno\n\nRetorna a solução fundamental hipersingular calculada com base nos parâmetros fornecidos.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.center-Tuple{HyperRectangle}","page":"Reference","title":"BEM.center","text":"center(Ω)\n\nCenter of the smallest ball containing Ω.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.compress!-Tuple{BEM.RkMatrix, TSVD}","page":"Reference","title":"BEM.compress!","text":"compress!(M::RkMatrix,tsvd::TSVD)\n\nRecompress the matrix R using a truncated svd of R. The implementation uses the qr-svd strategy to efficiently compute svd(R) when rank(R) ≪ min(size(R)).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.compress!-Tuple{Matrix, TSVD}","page":"Reference","title":"BEM.compress!","text":"compress!(M::Matrix,tsvd::TSVD)\n\nRecompress the matrix M using a truncated svd and output an RkMatrix. The data in M is invalidated in the process.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.compression_ratio-Tuple{Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}}","page":"Reference","title":"BEM.compression_ratio","text":"compression_ratio(H::HTypes)\n\nThe ratio of the uncompressed size of H to its compressed size. A compression_ratio of 10 means it would have taken 10 times more memory to store H as a dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.contact_pressure_disp-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.contact_pressure_disp","text":"contact_pressure_disp(dad, K, g_aim; ε = 1e-8, maxiter = 100)\n\nCalculates the contact pressure occurring when a rigid smooth surface is loaded against an elastic half-space, following Normal adhesive contact on rough surfaces: efficient algorithm for FFT-based BEM resolution     https://hal.science/hal-01755724v1/document\n\n# Arguments\n\ndad: estrutura de dados do problema (dadHS2D ou dadHS3D).\nK: [m/Pa] influence matrix (can be a dense or H-matrix).\ng_aim: [m] desired gap height distribution.\np_min: [Pa] minimum pressure \nH: [Pa] maximum pressure (hard-wall constraint).\nerr_tol: [-] relative error tolerance.\nit_max: [-] maximum number of iterations.\nh_ref: [m] reference length of relative error.\n\nReturns\n\np_con: [Pa] contact pressure field (Nx1 x Nx2 matrix).\ng: [m] residual of the gap height distribution (Nx1 x Nx2 matrix).\nerr: [-] relative error history (vector).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.contact_pressure_force-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.contact_pressure_force","text":"contact_pressure(p_min, H, z, W_aim, Nx1, Nx2, dx1, dx2, fft2_Kernel_circ, err_tol, it_max, h_ref)\n\nCalculates the contact pressure occurring when a rigid smooth surface is loaded against an elastic half-space, following a method similar to Polonsky and Keer (1999).\n\nArguments\n\ndad: estrutura de dados do problema (dadHS2D ou dadHS3D).\nK: [m/Pa] influence matrix (can be a dense or H-matrix).\nW_aim: [N] desired normal load.\np_min: [Pa] minimum pressure \nH: [Pa] maximum pressure (hard-wall constraint).\nerr_tol: [-] relative error tolerance.\nit_max: [-] maximum number of iterations.\nh_ref: [m] reference length of relative error.\n\nReturns\n\np_con: [Pa] contact pressure field (Nx1 x Nx2 matrix).\ng: [m] residual of the gap height distribution (Nx1 x Nx2 matrix).\nerr: [-] relative error history (vector).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.container-Tuple{ClusterTree}","page":"Reference","title":"BEM.container","text":"container(clt::ClusterTree)\n\nReturn the object enclosing all the elements of the clt.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.criatensoes-Tuple{Any, Any}","page":"Reference","title":"BEM.criatensoes","text":"tens_nt, tens= criatensoes(dad, [-1,0,0])\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.dBernsteins-Tuple{Any, Any}","page":"Reference","title":"BEM.dBernsteins","text":"dBernsteins(p, t)\n\nCalcula a derivada das funções de Bernstein de grau p no ponto t.\n\nParâmetros\n\np::Int: O grau das funções de Bernstein.\nt::Float64: O ponto no qual a derivada será calculada.\n\nRetorno\n\ndB::Vector{Float64}: Um vetor contendo os valores das derivadas das funções de Bernstein de grau p no ponto t.\n\nExemplo\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.depth","page":"Reference","title":"BEM.depth","text":"depth(tree,acc=0)\n\nRecursive function to compute the depth of node in a a tree-like structure.\n\nOverload this function if your structure has a more efficient way to compute depth (e.g. if it stores it in a field).\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.diameter-Tuple{HyperRectangle}","page":"Reference","title":"BEM.diameter","text":"diameter(Ω)\n\nLargest distance between x and y for x,y ∈ Ω.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.distance-Tuple{ClusterTree, ClusterTree}","page":"Reference","title":"BEM.distance","text":"distance(X::ClusterTree, Y::ClusterTree)\n\nDistance between the containers of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.distance-Union{Tuple{N}, Tuple{HyperRectangle{N}, HyperRectangle{N}}} where N","page":"Reference","title":"BEM.distance","text":"distance(Ω1,Ω2)\n\nMinimal Euclidean distance between a point x ∈ Ω1 and y ∈ Ω2.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.elements-Tuple{ClusterTree}","page":"Reference","title":"BEM.elements","text":"elements(clt::ClusterTree)\n\nIterable list of the elements inside clt.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.filter_tree","page":"Reference","title":"BEM.filter_tree","text":"filter_tree(f,tree,isterminal=true)\n\nReturn a vector containing all the nodes of tree such that f(node)==true.  The argument isterminal can be used to control whether to continue the search on children of nodes for which f(node)==true.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.filter_tree!","page":"Reference","title":"BEM.filter_tree!","text":"filter_tree!(filter,nodes,tree,[isterminal=true])\n\nLike filter_tree, but appends results to nodes.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.getblock!-NTuple{4, Any}","page":"Reference","title":"BEM.getblock!","text":"getblock!(block,K,irange,jrange)\n\nFill block with K[i,j] for i ∈ irange, j ∈ jrange, where block is of size length(irange) × length(jrange).\n\nA default implementation exists which relies on getindex(K,i,j), but this method can be overloaded for better performance if e.g. a vectorized way of computing a block is available.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.getcol!-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.getcol!","text":"getcol!(col, M, j)\n\nReturn the j-th column of M in col.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.getcol!-Union{Tuple{T}, Tuple{Any, BEM.RkMatrix, Int64}, Tuple{Any, BEM.RkMatrix, Int64, Val{T}}} where T","page":"Reference","title":"BEM.getcol!","text":"getcol!(col,M::AbstractMatrix,j)\n\nFill the entries of col with column j of M.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.getcol-Tuple{Any, Any}","page":"Reference","title":"BEM.getcol","text":"getcol(M, j)\n\nReturn the j-th column of M.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.glob2loc-Tuple{ClusterTree}","page":"Reference","title":"BEM.glob2loc","text":"glob2loc(clt::ClusterTree)\n\nThe inverse of loc2glob.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.greville","page":"Reference","title":"BEM.greville","text":"greville(knots, p, β = 0.0)\n\nCalcula os nós de Greville para uma dada sequência de nós e grau da B-spline.\n\nParâmetros\n\nknots::Vector{Float64}: Vetor contendo a sequência de nós.\np::Int: Grau da B-spline.\nβ::Float64: Parâmetro opcional para ajuste dos nós de Greville. O valor padrão é 0.0.\n\nRetorno\n\nVector{Float64}: Vetor contendo os nós de Greville calculados.\n\nExemplo\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.hmul!-Union{Tuple{T}, Tuple{T, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Any, Any, Any}, Tuple{T, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Vararg{Any, 4}}, Tuple{T, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Union{HMatrix, Adjoint{T, HMatrix{R, T}} where {R, T}, Hermitian{T, HMatrix{R, T}} where {R, T}}, Vararg{Any, 5}}} where T<:HMatrix","page":"Reference","title":"BEM.hmul!","text":"hmul!(C::HMatrix,A::HMatrix,B::HMatrix,a,b,compressor)\n\nSimilar to mul! : compute C <-- A*B*a + C*b, where A,B,C are hierarchical matrices and compressor is a function/functor used in the intermediate stages of the multiplication to avoid growring the rank of admissible blocks after addition is performed.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.index_range-Tuple{ClusterTree}","page":"Reference","title":"BEM.index_range","text":"index_range(clt::ClusterTree)\n\nIndices of elements in root_elements(clt) which lie inside clt.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.integraelem-Tuple{Any, Any, Any, Any, Any, Union{elastico, elastico_aniso}}","page":"Reference","title":"BEM.integraelem","text":"Funcao para calcular fazer integracao no contorno \n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.integraelem-Tuple{Any, Any, Any, Any, Any, Union{helmholtz, potencial}, Any}","page":"Reference","title":"BEM.integraelem","text":"Função para integrar elementos.\n\nParâmetros\n\npf: Coordenadas do ponto de fonte.\nx: Coordenadas dos pontos pertencentes ao elemento.\neta: Coordenadas eta dos pontos de integração.\nw: Pesos dos pontos de integração.\nelem: Elemento a ser integrado. \n`dad:: estrutura: Estrutura contendo os dados do problema.\n\nRetorno\n\nh: Valor da integral de h no elemento.\ng: Valor da integral de g no elemento.\n\nDescrição\n\nEsta função realiza a integração dos elementos fornecidos utilizando os pontos de integração e pesos especificados.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.integraelem_hiper-Tuple{Any, Any, Any, Any, Any, Any, Union{helmholtz, potencial}}","page":"Reference","title":"BEM.integraelem_hiper","text":"Função para integrar elementos considerando a solução fundamental hipersingular.\n\nParâmetros\n\npf: Coordenadas do ponto de fonte.\nx: Coordenadas dos pontos pertencentes ao elemento.\neta: Coordenadas eta dos pontos de integração.\nw: Pesos dos pontos de integração.\nelem: Elemento a ser integrado. \n`dad:: estrutura: Estrutura contendo os dados do problema.\n\nRetorno\n\nh: Valor da integral de h no elemento.\ng: Valor da integral de g no elemento.\n\nDescrição\n\nEsta função realiza a integração dos elementos fornecidos utilizando os pontos de integração e pesos especificados.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.integraelem_hiper_sing","page":"Reference","title":"BEM.integraelem_hiper_sing","text":"Função para integrar elementos singulares considerando a solução fundamental hipersingular.\n\nParâmetros\n\npf: Coordenadas do ponto de fonte.\nnf: Normal do ponto de fonte.\nx: Coordenadas dos pontos pertencentes ao elemento.\nxi0: Coordenada eta dos ponto singular.\nelem: Elemento a ser integrado. \n`dad:: estrutura: Estrutura contendo os dados do problema.\nnpg::Int=20: Número de pontos de quadratura PTVSI a serem usados para a integração numérica.\n\nRetorno\n\nh: Valor da integral de h no elemento.\ng: Valor da integral de g no elemento.\n\nDescrição\n\nEsta função realiza a integração dos elementos singulares.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.integraelemd-NTuple{4, Any}","page":"Reference","title":"BEM.integraelemd","text":"Funcao para calcular a das funções de forma\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.isclean-Tuple{HMatrix}","page":"Reference","title":"BEM.isclean","text":"isclean(H::HMatrix)\n\nReturn true if all leaves of H have data, and if the leaves are the only nodes containing data. This is the normal state of an ℋ-matrix, but during intermediate stages of a computation data may be associated with non-leaf nodes for convenience.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.lagrange-NTuple{5, Any}","page":"Reference","title":"BEM.lagrange","text":"lagrange(pg, x1, n1, x2, n2)\n\nCalcula a matriz de interpolação de Lagrange para os pontos fornecidos.\n\nParâmetros\n\npg: Matriz de pontos de grade, onde cada linha representa um ponto e cada coluna representa uma dimensão.\nx1: Vetor de coordenadas na primeira dimensão.\nn1: Número de pontos na primeira dimensão.\nx2: Vetor de coordenadas na segunda dimensão.\nn2: Número de pontos na segunda dimensão.\n\nRetorno\n\nL: Matriz de interpolação de Lagrange de tamanho (ni, n1 * n2), onde ni é o número de pontos na grade pg.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.lagrange-NTuple{7, Any}","page":"Reference","title":"BEM.lagrange","text":"lagrange(pg, x1, n1, x2, n2, x3, n3)\n\nCalcula a matriz de interpolação de Lagrange para os pontos fornecidos.\n\nParâmetros\n\npg: Matriz de pontos de grade, onde cada linha representa um ponto e cada coluna representa uma dimensão.\nx1: Vetor de coordenadas na primeira dimensão.\nn1: Número de pontos na primeira dimensão.\nx2: Vetor de coordenadas na segunda dimensão.\nn2: Número de pontos na segunda dimensão.\nx3: Vetor de coordenadas na terceira dimensão.\nn3: Número de pontos na terceira dimensão.\n\nRetorno\n\nL: Matriz de interpolação de Lagrange de tamanho (ni, n1 * n2 * n3), onde ni é o número de pontos na grade pg.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.lagrange-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.lagrange","text":"lagrange(pg, x, n)\n\nCalcula o polinômio interpolador de Lagrange.\n\nParâmetros\n\npg: Vetor de pontos de interpolação.\nx: Ponto onde o polinômio será avaliado.\nn: Número de pontos de interpolação.\n\nRetorno\n\nValor do polinômio interpolador de Lagrange avaliado em x.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.leaves-Tuple{Any}","page":"Reference","title":"BEM.leaves","text":"leaves(tree)\n\nReturn a vector containing all the leaf nodes of tree.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.loc2glob-Tuple{ClusterTree}","page":"Reference","title":"BEM.loc2glob","text":"loc2glob(clt::ClusterTree)\n\nThe permutation from the (local) indexing system of the elements of the clt to the (global) indexes used upon the construction of the tree.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.newcol!-Tuple{BEM.VectorOfVectors}","page":"Reference","title":"BEM.newcol!","text":"newcol!(A::VectorOfVectors)\n\nAppend a new (unitialized) column to A, and return a view of it.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.nodes-Tuple{Any}","page":"Reference","title":"BEM.nodes","text":"leaves(tree)\n\nReturn a vector containing all the nodes of tree.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.nosproximoskmeans","page":"Reference","title":"BEM.nosproximoskmeans","text":"indc=nosproximoskmeans(X,k=9) qr1=pqrfact(M[:,indc],rtol=1e-8) qr2=pqrfact(:c,qr1.Q,rtol=1e-8) indl=qr2.p[1:size(qr2.Q,1)] A1=M[:,indc] A2=M[indl,indc]divide M[indl,:] M=A1*A2\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.novelquad","page":"Reference","title":"BEM.novelquad","text":"f->  funçao a ser integrada m->ordem da singularidade t->posição da singularidade n->Quantidade de pontos de integração https://link.springer.com/article/10.1007/s10092-021-00446-1 t = 0.3 f1(x) = (1 + x - x^2) / (x - t)^1 f2(x) = (1 + x - x^2) / (x - t)^2 f3(x) = (1 + x - x^2) / (x - t)^3 eta, w = BEM.novelquad(2, (t - 0.5) * 2, 32) F1(x)=-(t^2 - t - 1) log(x - t) - 1/2 x (2 t + x - 2) dot(f1.(eta / 2 .+ 0.5), w) / 2-1.22523041106851637258923008288999 dot(f2.(eta / 2 .+ 0.5), w) / 2+6.42298561774988045927786175929650 dot(f3.(eta / 2 .+ 0.5), w) / 2-2.73546857952209343844408750481721\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.parentnode-Tuple{ClusterTree}","page":"Reference","title":"BEM.parentnode","text":"parentnode(clt::ClusterTree)\n\nThe node's parent. If t is a root, then parent(t)==t.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.radius-Tuple{HyperRectangle}","page":"Reference","title":"BEM.radius","text":"radius(Ω)\n\nHalf the diameter.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.reset!-Tuple{BEM.VectorOfVectors}","page":"Reference","title":"BEM.reset!","text":"reset!(A::VectorOfVectors)\n\nSet the number of columns of A to zero, and the number of rows to zero, but does not resize! the underlying data vector.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.root_elements-Tuple{ClusterTree}","page":"Reference","title":"BEM.root_elements","text":"root_elements(clt::ClusterTree)\n\nThe elements contained in the root of the tree to which clt belongs.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.should_split","page":"Reference","title":"BEM.should_split","text":"should_split(clt::ClusterTree, depth, splitter::AbstractSplitter)\n\nDetermine whether or not a ClusterTree should be further divided.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.split!","page":"Reference","title":"BEM.split!","text":"split!(clt::ClusterTree,splitter::AbstractSplitter)\n\nDivide clt using the strategy implemented by splitter. This function is reponsible of assigning the children and parent fields, as well as of permuting the data of clt.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.use_global_index-Tuple{}","page":"Reference","title":"BEM.use_global_index","text":"use_global_index()::Bool\n\nDefault choice of whether operations will use the global indexing system throughout the package.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.use_threads-Tuple{}","page":"Reference","title":"BEM.use_threads","text":"use_threads()::Bool\n\nDefault choice of whether threads will be used throughout the package.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.verifica_contato","text":"verifica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato2-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.verifica_contato2","text":"verifica contato 2corpos\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato_incremental-NTuple{6, Any}","page":"Reference","title":"BEM.verifica_contato_incremental","text":"verifica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato_incremental2-NTuple{5, Any}","page":"Reference","title":"BEM.verifica_contato_incremental2","text":"verifica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Base.split-Union{Tuple{N}, Tuple{HyperRectangle{N}, Any, Any}} where N","page":"Reference","title":"Base.split","text":"split(rec::HyperRectangle,[axis]::Int,[place])\n\nSplit a hyperrectangle in two along the axis direction at the  position place. Returns a tuple with the two resulting hyperrectangles.\n\nWhen no place is given, defaults to splitting in the middle of the axis.\n\nWhen no axis and no place is given, defaults to splitting along the largest axis.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.cholesky!-Tuple{Hermitian{T, HMatrix{R, T}} where {R, T}, Any}","page":"Reference","title":"LinearAlgebra.cholesky!","text":"cholesky!(M::HMatrix,comp)\n\nHierarhical cholesky facotrization of M, using comp to generate the compressed blocks during the multiplication routines.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.cholesky!-Tuple{Hermitian{T, HMatrix{R, T}} where {R, T}}","page":"Reference","title":"LinearAlgebra.cholesky!","text":"cholesky!(M::HMatrix;atol=0,rank=typemax(Int),rtol=atol>0 ||\nrank<typemax(Int) ? 0 : sqrt(eps(Float64)))\n\nHierarhical cholesky facotrization of M, using the PartialACA(;atol,rtol;rank) compressor.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.cholesky-Tuple{Hermitian{T, HMatrix{R, T}} where {R, T}, Vararg{Any}}","page":"Reference","title":"LinearAlgebra.cholesky","text":"cholesky(M::HMatrix,args...;kwargs...)\n\nHierarchical cholesky factorization. See cholesky! for the available options.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.lu!-Tuple{HMatrix, Any}","page":"Reference","title":"LinearAlgebra.lu!","text":"lu!(M::HMatrix,comp)\n\nHierarhical LU facotrization of M, using comp to generate the compressed blocks during the multiplication routines.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.lu!-Tuple{HMatrix}","page":"Reference","title":"LinearAlgebra.lu!","text":"lu!(M::HMatrix;atol=0,rank=typemax(Int),rtol=atol>0 ||\nrank<typemax(Int) ? 0 : sqrt(eps(Float64)))\n\nHierarhical LU facotrization of M, using the PartialACA(;atol,rtol;rank) compressor.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.lu-Tuple{HMatrix, Vararg{Any}}","page":"Reference","title":"LinearAlgebra.lu","text":"LinearAlgebra.lu(M::HMatrix,args...;kwargs...)\n\nHierarchical LU factorization. See lu! for the available options.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.mul!","page":"Reference","title":"LinearAlgebra.mul!","text":"mul!(y::AbstractVector,H::HMatrix,x::AbstractVector,a,b[;global_index,threads])\n\nPerform y <-- H*x*a + y*b in place.\n\n\n\n\n\n","category":"function"},{"location":"01-data/#data","page":"Data","title":"Data","text":"This section explains how to enter data for BEM simulations in the BEM.jl package. Data entry involves defining the geometry, boundary conditions, material properties, and discretization parameters. The following example function potencial1d demonstrates the data structure for a 1D thermal potential problem.","category":"section"},{"location":"01-data/#Geometry-Definition","page":"Data","title":"Geometry Definition","text":"The geometry is defined using points and segments. Points are specified in a matrix where each row contains the point number and its coordinates.\n\nfunction potencial1d(ne = 15, tipo = 2)\n    # Define the points of the geometry\n    # PONTOS = [point_number x y]\n    PONTOS = [\n        1 0 0  # Point 1 at (0, 0)\n        2 1 0  # Point 2 at (1, 0)\n        3 1 1  # Point 3 at (1, 1)\n        4 0 1  # Point 4 at (0, 1)\n    ]","category":"section"},{"location":"01-data/#Segments","page":"Data","title":"Segments","text":"Segments connect the points and define the boundaries. Each segment is defined by its number, start and end points, and curvature (radius). A radius of 0 indicates a straight line.\n\n    # Define segments: [segment_number start_point end_point radius]\n    # Radius: 0 = straight line, >0 = left curve, <0 = right curve\n    SEGMENTOS = [\n        1 1 2 0  # Straight segment from point 1 to 2\n        2 2 3 0  # Straight segment from point 2 to 3\n        3 3 4 0  # Straight segment from point 3 to 4\n        4 4 1 0  # Straight segment from point 4 to 1\n    ]","category":"section"},{"location":"01-data/#Mesh-Discretization","page":"Data","title":"Mesh Discretization","text":"The mesh specifies how many elements to place on each segment and their type.\n\n    # Define mesh: [segment_number number_of_elements element_type]\n    MALHA = [\n        1 ne tipo  # Segment 1: ne elements of type tipo\n        2 ne tipo  # Segment 2: ne elements of type tipo\n        3 ne tipo  # Segment 3: ne elements of type tipo\n        4 ne tipo  # Segment 4: ne elements of type tipo\n    ]","category":"section"},{"location":"01-data/#Boundary-Conditions","page":"Data","title":"Boundary Conditions","text":"Boundary conditions are applied to each segment, specifying whether temperature or heat flux is prescribed.\n\n    # Define boundary conditions: [segment_number condition_type condition_value]\n    # condition_type: 0 = prescribed temperature, 1 = prescribed flux\n    CCSeg = [\n        1 1 0    # Segment 1: flux = 0\n        2 1 -1   # Segment 2: flux = -1\n        3 1 0    # Segment 3: flux = 0\n        4 0 0    # Segment 4: temperature = 0\n    ]","category":"section"},{"location":"01-data/#Material-Properties","page":"Data","title":"Material Properties","text":"Material properties such as thermal conductivity are defined as scalars or functions.\n\n    # Thermal conductivity of the material\n    k = 1\n\nThe function returns the data structures needed for the BEM solver.\n\n    # Return the data for the potential problem\n    return potencial, PONTOS, SEGMENTOS, MALHA, CCSeg, k\nend","category":"section"},{"location":"02-exemplos/#examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"02-exemplos/#Thermal","page":"Examples","title":"Thermal","text":"This example demonstrates the application of the Boundary Element Method (BEM) to solve thermal conduction problems. It shows how to model steady-state heat transfer in a domain by discretizing only the boundary, reducing computational complexity compared to domain discretization methods.","category":"section"},{"location":"02-exemplos/#Initialization","page":"Examples","title":"Initialization","text":"Set up the environment and define problem parameters.\n\nusing DrWatson\n@quickactivate \"BEM\"\ninclude(scriptsdir(\"includes.jl\"))\nnelem = 20  # Number of elements\norder = 2   # Element order\nNPX = 10    # Internal points in x direction\nNPY = NPX   # Internal points in y direction\nnpg = 20    # Number of Gauss points (even numbers only)","category":"section"},{"location":"02-exemplos/#Data-Formatting","page":"Examples","title":"Data Formatting","text":"Format the input data using the predefined geometry and boundary conditions.\n\nprintln(\"1. Formatting the data\")\ndad = format_dad(potencial1d(nelem, order), NPX, NPY)  # Data structure","category":"section"},{"location":"02-exemplos/#Matrix-Assembly","page":"Examples","title":"Matrix Assembly","text":"Compute the influence matrices H and G, then apply boundary conditions to form the system matrix A and vector b.\n\nprintln(\"2. Assembling matrix A and vector b\")\nH, G = calc_HeG(dad, npg)  # Compute H and G matrices\nA, b = aplicaCDC(H, G, dad)  # Apply boundary conditions","category":"section"},{"location":"02-exemplos/#Solving-the-System","page":"Examples","title":"Solving the System","text":"Solve the linear system and separate the results into temperature and flux.\n\nprintln(\"3. Solving the linear system\")\nx = A \\ b\nprintln(\"4. Separating temperature and flux\")\nT, q = separa(dad, x)","category":"section"},{"location":"02-exemplos/#Linear-Elasticity","page":"Examples","title":"Linear Elasticity","text":"This example illustrates the use of BEM for solving linear elasticity problems. It demonstrates how to compute displacements and stresses in elastic solids under various loading conditions, leveraging the boundary-only discretization to efficiently handle 2D or 3D elastic problems.","category":"section"},{"location":"02-exemplos/#Initialization-2","page":"Examples","title":"Initialization","text":"Set up the environment for the elasticity analysis.\n\nusing DrWatson\n@quickactivate \"BEM\"\ninclude(scriptsdir(\"includes.jl\"))\nnelem = 10  # Number of elements\nNPX = 2     # Internal points in x direction\nNPY = 2     # Internal points in y direction\nnpg = 20    # Number of Gauss points\ntipo = 3    # Element type","category":"section"},{"location":"02-exemplos/#Data-Formatting-2","page":"Examples","title":"Data Formatting","text":"Prepare the data for a beam problem.\n\nprintln(\"1. Formatting the data\")\ndad = format_dad(viga(nelem, tipo), NPX, NPY)  # Beam data","category":"section"},{"location":"02-exemplos/#Matrix-Assembly-2","page":"Examples","title":"Matrix Assembly","text":"Assemble the matrices for the elasticity problem.\n\nprintln(\"2. Assembling matrix A and vector b\")\nH, G = calc_HeG(dad, npg, interno = false)  # Compute matrices (boundary only)\nA, b = BEM.aplicaCDC(H, G, dad)  # Apply boundary conditions","category":"section"},{"location":"02-exemplos/#Solving-the-System-2","page":"Examples","title":"Solving the System","text":"Solve for displacements and tractions.\n\nprintln(\"3. Solving the linear system\")\nx = A \\ b\nprintln(\"4. Separating displacements and tractions\")\nu, t = separa(dad, x)","category":"section"},{"location":"02-exemplos/#Thermal-Elasticity","page":"Examples","title":"Thermal Elasticity","text":"This example demonstrates coupled thermal-elasticity analysis, where temperature fields induce thermal stresses in elastic materials. It combines heat conduction and structural mechanics to solve problems involving thermal expansion and stress generation.","category":"section"},{"location":"02-exemplos/#Benchmark-Test-Function","page":"Examples","title":"Benchmark Test Function","text":"The benchmark function testagao evaluates the accuracy and performance of the thermal-elasticity solver by comparing numerical results with analytical solutions for varying mesh densities.\n\nfunction testagao(i, metodo)\n    nelem = i     # Number of elements\n    NPY = 2i      # Internal points in y-direction\n    NPX = 2NPY    # Internal points in x-direction\n    npg = 10      # Number of Gauss points\n\n    ## Data Formatting\n    dad = format_dad(telasticogao(nelem, 3), NPX, NPY)\n\n    # Define temperature distribution\n    c0 = 0\n    c1 = -60\n    c2 = 40\n    f(x, y) = c2 * y^2 + c1 * y + c0\n\n    # Extract material properties\n    EE = dad.k.E\n    v = dad.k.nu\n    k = dad.k.k\n\n    # Analytical displacement solution\n    uana(y) = (c1 / 2 * (y^2 - 0.5^2) + c2 / 3 * (y^3 + 0.5^3) + c0 * (y + 0.5)) * 1.3 / 0.7 * k\n\n    # Solve thermal-elasticity problem\n    tdad = @timed u, ss = termoelasticidade(dad, npg, θ = f, metodo = metodo)\n\n    # Post-process results\n    y = [dad.NOS[:, 2]; dad.pontos_internos[:, 2]]\n    ssa = -k / 0.7 * f.(0, y) * dad.k.E\n    ua = uana.(y)\n    eu = nrmse(ua, u[:, 2])\n    es = nrmse(ssa, ss[:, 1])\n\n    return [nc(dad) ni(dad) eu es tdad.time]\nend","category":"section"},{"location":"02-exemplos/#Thermal-Elasticity-Solver-Function","page":"Examples","title":"Thermal-Elasticity Solver Function","text":"The core function termoelasticidade implements the coupled thermal-elastic BEM formulation. It handles temperature-induced deformations and computes displacements and stresses.\n\nfunction termoelasticidade(dad, npg; θ = 1, carga = 0, metodo = \"dibem\")\n    # Compute influence matrices\n    H, G = calc_HeG(dad, npg, interno = true)\n    A, b = BEM.aplicaCDC(H, G, dad)\n\n    # Material properties\n    EE = dad.k.E\n    v = dad.k.nu\n    k = dad.k.k\n    kchap = EE * k / (1 - 2 * v)\n\n    # Process temperature input\n    np = nc(dad) + ni(dad)\n    if θ isa Number\n        theta = fill(θ, np)\n    elseif θ isa Vector\n        theta = θ\n    elseif θ isa Function\n        theta = [\n            θ.(dad.NOS[:, 1], dad.NOS[:, 2])\n            θ.(dad.pontos_internos[:, 1], dad.pontos_internos[:, 2])\n        ]\n    end\n\n    # Compute thermal loads\n    F, Fx, Fy = BEM.montaFs([dad.NOS; dad.pontos_internos], [dad.NOS; dad.pontos_internos])\n    dF = [zeros(size(Fx)); zeros(size(Fy))]\n    for i = 1:np\n        dF[2i-1, :] = Fx[i, :]\n        dF[2i, :] = Fy[i, :]\n    end\n\n    # Thermal expansion terms\n    if metodo == \"DIBEM\"\n        Mpe = BEM.Monta_M_RIMd(dad, npg)\n        dMpe = BEM.Monta_dM_RIMd(dad, npg)\n    else\n        Mpe = BEM.Monta_M_RIM(dad, npg)\n        dMpe = BEM.Monta_dM_RIM(dad, npg)\n    end\n    q2 = Mpe * kchap * dF * theta\n    dq2 = dMpe * kchap * dF * theta\n\n    # Body forces (if any)\n    if carga != 0\n        carga_nodal = zeros(2np)\n        for i = 1:nc(dad)\n            carga_nodal[2i-1:2i] = carga(dad.NOS[i, 1], dad.NOS[i, 2])\n        end\n        for i = nc(dad)+1:np\n            carga_nodal[2i-1:2i] = carga(dad.pontos_internos[i-nc(dad), 1], dad.pontos_internos[i-nc(dad), 2])\n        end\n        qc = Mpe * carga_nodal\n        dqc = dMpe * carga_nodal\n    else\n        qc = 0\n        dqc = 0\n    end\n\n    # Assemble thermal load vector\n    normal_fonte = dad.normal\n    q1 = G * (normal_fonte .* theta[1:nc(dad)])'[:] * kchap\n\n    # Solve system\n    x = A \\ (b + q1 .- q2 .+ qc)\n\n    # Separate results\n    u, t, uint = separa(dad, x)\n\n    # Compute stresses\n    S, D = calc_SeD(dad)\n    dq1 = D * (normal_fonte .* theta[1:nc(dad)])'[:] * kchap\n    dq3 = [kchap * theta kchap * theta 0 * theta]\n    fatorcontorno = [fill(2, nc(dad)); ones(ni(dad))]\n    sigma = reshape(D * t'[:] - S * u'[:] + dq1 .- dq2 .+ dqc, 3, :)' .* fatorcontorno - dq3\n\n    return [u; uint], sigma\nend\n\nThis implementation supports different solution methods (RIM or DIBEM) and can handle various temperature distributions and mechanical loads.","category":"section"},{"location":"#BEM","page":"BEM","title":"BEM","text":"Documentation BEM a 2D boundary element method solver. ","category":"section"}]
}
