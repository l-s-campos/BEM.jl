var documenterSearchIndex = {"docs":
[{"location":"91-developer/#dev_docs","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"note: Contributing guidelines\nIf you haven't, please read the Contributing guidelines first.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"If you want to make contributions to this package that involves code, then this guide is for you.","category":"page"},{"location":"91-developer/#First-time-clone","page":"Developer documentation","title":"First time clone","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"tip: If you have writing rights\nIf you have writing rights, you don't have to fork. Instead, simply clone and skip ahead. Whenever upstream is mentioned, use origin instead.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"If this is the first time you work with this repository, follow the instructions below to clone the repository.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Fork this repo\nClone your repo (this will create a git remote called origin)\nAdd this repo as a remote:\ngit remote add upstream https://github.com/l-s-campos/BEM.jl","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"This will ensure that you have two remotes in your git: origin and upstream. You will create branches and push to origin, and you will fetch and update your local main branch from upstream.","category":"page"},{"location":"91-developer/#Linting-and-formatting","page":"Developer documentation","title":"Linting and formatting","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Install a plugin on your editor to use EditorConfig. This will ensure that your editor is configured with important formatting settings.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"We use https://pre-commit.com to run the linters and formatters. In particular, the Julia code is formatted using JuliaFormatter.jl, so please install it globally first:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"julia> # Press ]\npkg> activate\npkg> add JuliaFormatter","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"To install pre-commit, we recommend using pipx as follows:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"# Install pipx following the link\npipx install pre-commit","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"With pre-commit installed, activate it as a pre-commit hook:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"pre-commit install","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"To run the linting and formatting manually, enter the command below:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"pre-commit run -a","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Now, you can only commit if all the pre-commit tests pass.","category":"page"},{"location":"91-developer/#Testing","page":"Developer documentation","title":"Testing","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"As with most Julia packages, you can just open Julia in the repository folder, activate the environment, and run test:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"julia> # press ]\npkg> activate .\npkg> test","category":"page"},{"location":"91-developer/#Working-on-a-new-issue","page":"Developer documentation","title":"Working on a new issue","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"We try to keep a linear history in this repo, so it is important to keep your branches up-to-date.","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Fetch from the remote and fast-forward your local main\ngit fetch upstream\ngit switch main\ngit merge --ff-only upstream/main\nBranch from main to address the issue (see below for naming)\ngit switch -c 42-add-answer-universe\nPush the new local branch to your personal remote repository\ngit push -u origin 42-add-answer-universe\nCreate a pull request to merge your remote branch into the org main.","category":"page"},{"location":"91-developer/#Branch-naming","page":"Developer documentation","title":"Branch naming","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"If there is an associated issue, add the issue number.\nIf there is no associated issue, and the changes are small, add a prefix such as \"typo\", \"hotfix\", \"small-refactor\", according to the type of update.\nIf the changes are not small and there is no associated issue, then create the issue first, so we can properly discuss the changes.\nUse dash separated imperative wording related to the issue (e.g., 14-add-tests, 15-fix-model, 16-remove-obsolete-files).","category":"page"},{"location":"91-developer/#Commit-message","page":"Developer documentation","title":"Commit message","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Use imperative or present tense, for instance: Add feature or Fix bug.\nHave informative titles.\nWhen necessary, add a body with details.\nIf there are breaking changes, add the information to the commit message.","category":"page"},{"location":"91-developer/#Before-creating-a-pull-request","page":"Developer documentation","title":"Before creating a pull request","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"tip: Atomic git commits\nTry to create \"atomic git commits\" (recommended reading: The Utopic Git History).","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Make sure the tests pass.\nMake sure the pre-commit tests pass.\nFetch any main updates from upstream and rebase your branch, if necessary:\ngit fetch upstream\ngit rebase upstream/main BRANCH_NAME\nThen you can open a pull request and work with the reviewer to address any issues.","category":"page"},{"location":"91-developer/#Building-and-viewing-the-documentation-locally","page":"Developer documentation","title":"Building and viewing the documentation locally","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Following the latest suggestions, we recommend using LiveServer to build the documentation. Here is how you do it:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Run julia --project=docs to open Julia in the environment of the docs.\nIf this is the first time building the docs\nPress ] to enter pkg mode\nRun pkg> dev . to use the development version of your package\nPress backspace to leave pkg mode\nRun julia> using LiveServer\nRun julia> servedocs()","category":"page"},{"location":"91-developer/#Making-a-new-release","page":"Developer documentation","title":"Making a new release","text":"","category":"section"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"To create a new release, you can follow these simple steps:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Create a branch release-x.y.z\nUpdate version in Project.toml\nUpdate the CHANGELOG.md:\nRename the section \"Unreleased\" to \"[x.y.z] - yyyy-mm-dd\" (i.e., version under brackets, dash, and date in ISO format)\nAdd a new section on top of it named \"Unreleased\"\nAdd a new link in the bottom for version \"x.y.z\"\nChange the \"[unreleased]\" link to use the latest version - end of line, vx.y.z ... HEAD.\nCreate a commit \"Release vx.y.z\", push, create a PR, wait for it to pass, merge the PR.\nGo back to main screen and click on the latest commit (link: https://github.com/l-s-campos/BEM.jl/commit)\nAt the bottom, write @JuliaRegistrator register","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"After that, you only need to wait and verify:","category":"page"},{"location":"91-developer/","page":"Developer documentation","title":"Developer documentation","text":"Wait for the bot to comment (should take < 1m) with a link to a PR to the registry\nFollow the link and wait for a comment on the auto-merge\nThe comment should said all is well and auto-merge should occur shortly\nAfter the merge happens, TagBot will trigger and create a new GitHub tag. Check on https://github.com/l-s-campos/BEM.jl/releases\nAfter the release is create, a \"docs\" GitHub action will start for the tag.\nAfter it passes, a deploy action will run.\nAfter that runs, the stable docs should be updated. Check them and look for the version number.","category":"page"},{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Modules = [BEM]","category":"page"},{"location":"95-reference/#BEM.AbstractCompressor","page":"Reference","title":"BEM.AbstractCompressor","text":"abstract type AbstractCompressor\n\nTypes used to compress matrices.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.AbstractHMatrix","page":"Reference","title":"BEM.AbstractHMatrix","text":"abstract type AbstractHMatrix{T} <: AbstractMatrix{T}\n\nAbstract type for hierarchical matrices.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.AbstractKernelMatrix","page":"Reference","title":"BEM.AbstractKernelMatrix","text":"abstract type AbstractKernelMatrix{T} <: AbstractMatrix{T}\n\nInterface for abstract matrices represented through a kernel function f, target elements X, and source elements Y. The matrix entry i,j is given by f(X[i],Y[j]). Concrete subtypes should implement at least\n\n`Base.getindex(K::AbstractKernelMatrix,i::Int,j::Int)`\n\nIf a more efficient implementation of getindex(K,I::UnitRange,I::UnitRange), getindex(K,I::UnitRange,j::Int) and getindex(adjoint(K),I::UnitRange,j::Int) is available (e.g. with SIMD vectorization), implementing such methods can improve the speed of assembling an HMatrix.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.AbstractSplitter","page":"Reference","title":"BEM.AbstractSplitter","text":"abstract type AbstractSplitter\n\nAn AbstractSplitter is used to split a ClusterTree. The interface requires the following methods:\n\nshould_split(clt,splitter) : return a Bool determining if the ClusterTree should be further divided\nsplit!(clt,splitter) : perform the splitting of the ClusterTree handling the necessary data sorting.\n\nSee GeometricSplitter for an example of an implementation.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.CardinalitySplitter","page":"Reference","title":"BEM.CardinalitySplitter","text":"struct CardinalitySplitter <: AbstractSplitter\n\nUsed to split a ClusterTree along the largest dimension if length(tree)>nmax. The split is performed so the data is evenly distributed amongst all children.\n\nSee also: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.ClusterTree","page":"Reference","title":"BEM.ClusterTree","text":"ClusterTree(elements,splitter;[copy_elements=true, threads=false])\n\nConstruct a ClusterTree from the  given elements using the splitting strategy encoded in splitter. If copy_elements is set to false, the elements argument are directly stored in the ClusterTree and are permuted during the tree construction.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.ClusterTree-2","page":"Reference","title":"BEM.ClusterTree","text":"mutable struct ClusterTree{N,T}\n\nTree structure used to cluster poitns of type SVector{N,T} into HyperRectangles.\n\nFields:\n\n_elements::Vector{SVector{N,T}} : vector containing the sorted elements.\ncontainer::HyperRectangle{N,T} : container for the elements in the current node.\nindex_range::UnitRange{Int} : indices of elements contained in the current node.\nloc2glob::Vector{Int} : permutation from the local indexing system to the original (global) indexing system used as input in the construction of the tree.\nglob2loc::Vector{Int} : inverse of loc2glob permutation.\nchildren::Vector{ClusterTree{N,T}}\nparent::ClusterTree{N,T}\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.DHMatrix","page":"Reference","title":"BEM.DHMatrix","text":"mutable struct DHMatrix{R,T} <: AbstractHMatrix{T}\n\nConcrete type representing a hierarchical matrix with data distributed amongst various workers. Its structure is very similar to HMatrix, except that the leaves store a RemoteHMatrix object.\n\nThe data on the leaves of a DHMatrix may live on a different worker, so calling fetch on them should be avoided whenever possible.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.DHMatrix-Union{Tuple{T}, Tuple{R}, Tuple{R, R}} where {R, T}","page":"Reference","title":"BEM.DHMatrix","text":"DHMatrix{T}(rowtree,coltree;partition_strategy=:distribute_columns)\n\nConstruct the block structure of a distributed hierarchical matrix covering rowtree and coltree. Returns a DHMatrix with leaves that are empty.\n\nThe partition_strategy keyword argument determines how to partition the blocks for distributed computing. Currently, the only available options is distribute_columns, which will partition the columns of the underlying matrix into floor(log2(nw)) parts, where nw is the number of workers available.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.GeometricSplitter","page":"Reference","title":"BEM.GeometricSplitter","text":"struct GeometricSplitter <: AbstractSplitter\n\nUsed to split a ClusterTree in half along the largest axis. The children boxes are shrank to tighly fit the data.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.HMatrix","page":"Reference","title":"BEM.HMatrix","text":"mutable struct HMatrix{R,T} <: AbstractHMatrix{T}\n\nA hierarchial matrix constructed from a rowtree and coltree of type R and holding elements of type T.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.HMatrix-Union{Tuple{T}, Tuple{R}, Tuple{R, R, Any}} where {R, T}","page":"Reference","title":"BEM.HMatrix","text":"HMatrix{T}(rowtree,coltree,adm)\n\nConstruct an empty HMatrix with rowtree and coltree using the admissibility condition adm. This function builds the skeleton for the hierarchical matrix, but does not compute data field in the blocks. See assemble_hmatrix for assembling a hierarhical matrix.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.HyperRectangle","page":"Reference","title":"BEM.HyperRectangle","text":"struct HyperRectangle{N,T}\n\nAxis-aligned hyperrectangle in N dimensions given by low_corner::SVector{N,T} and high_corner::SVector{N,T}.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.KernelMatrix","page":"Reference","title":"BEM.KernelMatrix","text":"KernelMatrix{Tf,Tx,Ty,T} <:: AbstractKernelMatrix{T}\n\nGeneric kernel matrix representing a kernel function acting on two sets of elements. If K is a KernelMatrix, then K[i,j] = f(X[i],Y[j]) where f::Tf=kernel(K), X::Tx=rowelements(K) and Y::Ty=colelements(K).\n\nExamples\n\nX = rand(SVector{2,Float64},2)\nY = rand(SVector{2,Float64},2)\nK = KernelMatrix(X,Y) do x,y\n    sum(x+y)\nend\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.MulLinearOp","page":"Reference","title":"BEM.MulLinearOp","text":"struct MulLinearOp{R,T} <: AbstractMatrix{T}\n\nAbstract matrix representing the following linear operator:\n\n    L = R + P + a * ∑ᵢ Aᵢ * Bᵢ\n\nwhere R and P are of type RkMatrix{T}, Aᵢ,Bᵢ are of type HMatrix{R,T} and a is scalar multiplier. Calling compressor(L) produces a low-rank approximation of L, where compressor is an AbstractCompressor.\n\nNote: this structure is used to group the operations required when multiplying hierarchical matrices so that they can later be executed in a way that minimizes recompression of intermediate computations.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.PartialACA","page":"Reference","title":"BEM.PartialACA","text":"struct PartialACA\n\nAdaptive cross approximation algorithm with partial pivoting. This structure can be used to generate an RkMatrix from a matrix-like object M as follows:\n\nusing LinearAlgebra\nrtol = 1e-6\ncomp = PartialACA(;rtol)\nA = rand(10,2)\nB = rand(10,2)\nM = A*adjoint(B) # a low-rank matrix\nR = comp(M, axes(M)...) # compress the entire matrix `M`\nnorm(Matrix(R) - M) < rtol*norm(M) # true\n\n# output\n\ntrue\n\n\nBecause it uses partial pivoting, the linear operator does not have to be evaluated at every i,j. This is usually much faster than TSVD, but due to the pivoting strategy the algorithm may fail in special cases, even when the underlying linear operator is of low rank.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.Partition","page":"Reference","title":"BEM.Partition","text":"struct Partition{T}\n\nA partition of the leaves of an HMatrix. Used to perform threaded hierarchical multiplication.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.PermutedMatrix","page":"Reference","title":"BEM.PermutedMatrix","text":"PermutedMatrix{K,T} <: AbstractMatrix{T}\n\nStructured used to reprensent the permutation of a matrix-like object. The original matrix is stored in the data::K field, and the permutations are stored in rowperm and colperm.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.PrincipalComponentSplitter","page":"Reference","title":"BEM.PrincipalComponentSplitter","text":"struct PrincipalComponentSplitter <: AbstractSplitter\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.RemoteHMatrix","page":"Reference","title":"BEM.RemoteHMatrix","text":"struct RemoteHMatrix{S,T}\n\nA light wrapper for a Future storing an HMatrix.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.RkMatrix","page":"Reference","title":"BEM.RkMatrix","text":"mutable struct RkMatrix{T}\n\nRepresentation of a rank r matrix M in outer product format M = A*adjoint(B) where A has size m × r and B has size n × r.\n\nThe internal representation stores A and B, but R.Bt or R.At can be used to get the respective adjoints.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.StrongAdmissibilityStd","page":"Reference","title":"BEM.StrongAdmissibilityStd","text":"struct StrongAdmissibilityStd\n\nTwo blocks are admissible under this condition if the minimum of their diameter is smaller than eta times the distance between them, where eta::Float64 is a parameter.\n\nUsage:\n\nadm = StrongAdmissibilityStd(;eta=2.0)\nadm(Xnode,Ynode)\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.TSVD","page":"Reference","title":"BEM.TSVD","text":"struct TSVD\n\nCompression algorithm based on a posteriori truncation of an SVD. This is the optimal approximation in Frobenius norm; however, it also tends to be very expensive and thus should be used mostly for \"small\" matrices.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.VectorOfVectors","page":"Reference","title":"BEM.VectorOfVectors","text":"struct VectorOfVectors{T}\n\nA simple structure which behaves as a Vector{Vector{T}} but stores the entries in a contiguous data::Vector{T} field. All vectors in the VectorOfVectors are assumed to be of size m, and there are k of them, meaning this structure can be used to represent a m × k matrix.\n\nSimilar to a vector-of-vectors, calling A[i] returns a view to the i-th column.\n\nSee also: newcol!\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.WeakAdmissibilityStd","page":"Reference","title":"BEM.WeakAdmissibilityStd","text":"struct WeakAdmissibilityStd\n\nTwo blocks are admissible under this condition if the distance between them is positive.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#BEM.kernelH","page":"Reference","title":"BEM.kernelH","text":"KH=kernelH(dad,BEM.calc_normais(dad))\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#Base.Matrix-Tuple{HMatrix}","page":"Reference","title":"Base.Matrix","text":"Matrix(H::HMatrix;global_index=true)\n\nConvert H to a Matrix. If global_index=true (the default), the entries are given in the global indexing system (see HMatrix for more information); otherwise the local indexing system induced by the row and columns trees are used.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.Contato_NL_newton2-NTuple{5, Any}","page":"Reference","title":"BEM.Contato_NL_newton2","text":"Resolve numericamente um problema não-linear com condições de contato utilizando o método de Newton.\n\nArgumentos:\n\ndad: Estrutura de dados\nx0: Chute inicial para a solução.\nA2: Matriz do BEM\nb2: Vetor do BEM\nh: variável com as informações sobre o contato\nmaxiter (opcional): Número máximo de iterações do método de Newton.\ntol (opcional): Tolerância para o erro, utilizada como critério de parada.\n\nRetorno:\n\nx: Solução aproximada do problema, ou o último chute se o critério de parada não for satisfeito.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._aca_partial","page":"Reference","title":"BEM._aca_partial","text":"_aca_partial(K,irange,jrange,atol,rmax,rtol,istart=1)\n\nInternal function implementing the adaptive cross-approximation algorithm with partial pivoting. The returned R::RkMatrix provides an approximation to K[irange,jrange] which has either rank is expected to satisfy|M - R| < max(atol,rtol*|M|)`, but this inequality may fail to hold due to the various errors involved in estimating the error and |M|.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM._aca_partial_pivot-Tuple{Any, Any}","page":"Reference","title":"BEM._aca_partial_pivot","text":"_aca_partial_pivot(v,I)\n\nFind in the valid set I the index of the element x ∈ v maximizing its smallest singular value. This is equivalent to minimizing the spectral norm of the inverse of x.\n\nWhen x is a scalar, this is simply the element with largest absolute value.\n\nThis general implementation should work for both scalar as well as tensor-valued kernels; see (https://www.sciencedirect.com/science/article/pii/S0021999117306721)[https://www.sciencedirect.com/science/article/pii/S0021999117306721] for more details.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._assemble_cpu!-NTuple{4, Any}","page":"Reference","title":"BEM._assemble_cpu!","text":"_assemble_cpu!(hmat::HMatrix,K,comp)\n\nAssemble data on the leaves of hmat. The admissible leaves are compressed using the compressor comp. This function assumes the structure of hmat has already been intialized, and therefore should not be called directly. See HMatrix information on constructors.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._assemble_hmat_distributed-Tuple{Any, Any, Any}","page":"Reference","title":"BEM._assemble_hmat_distributed","text":"_assemble_hmat_distributed(K,rtree,ctree;adm=StrongAdmissibilityStd(),comp=PartialACA();global_index=true,threads=false)\n\nInternal methods called after the DHMatrix structure has been initialized in order to construct the HMatrix on each of the leaves of the DHMatrix.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._assemble_threads!-NTuple{4, Any}","page":"Reference","title":"BEM._assemble_threads!","text":"_assemble_threads!(hmat::HMatrix,K,comp)\n\nLike _assemble_cpu!, but uses threads to assemble the leaves. Note that the threads are spanwned using Threads.@spawn, which means they are spawned on the same worker as the caller.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._build_block_structure!-Union{Tuple{T}, Tuple{R}, Tuple{Any, HMatrix{R, T}}} where {R, T}","page":"Reference","title":"BEM._build_block_structure!","text":"_build_block_structure!(adm_fun,current_node)\n\nRecursive constructor for HMatrix block structure. Should not be called directly.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._cost_gemv-Tuple{BEM.RkMatrix}","page":"Reference","title":"BEM._cost_gemv","text":"_cost_gemv(A::Union{Matrix,SubArray,Adjoint})\n\nA proxy for the computational cost of a matrix/vector product.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._hgemv_recursive!-Tuple{AbstractVector, Union{HMatrix, LinearAlgebra.Adjoint{<:Any, <:HMatrix}}, AbstractVector, Any}","page":"Reference","title":"BEM._hgemv_recursive!","text":"_hgemv_recursive!(C,A,B,offset)\n\nInternal function used to compute C[I] <-- C[I] + A*B[J] where I = rowrange(A) - offset[1] and J = rowrange(B) - offset[2].\n\nThe offset argument is used on the caller side to signal if the original hierarchical matrix had a pivot other than (1,1).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM._update_frob_norm-Tuple{Any, Any, Any}","page":"Reference","title":"BEM._update_frob_norm","text":"_update_frob_norm(acc,A,B)\n\nGiven the Frobenius norm of Rₖ = A[1:end-1]*adjoint(B[1:end-1]) in acc, compute the Frobenius norm of Rₖ₊₁ = A*adjoint(B) efficiently.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato!-NTuple{5, Any}","page":"Reference","title":"BEM.aplica_contato!","text":"aplica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato2!-NTuple{5, Any}","page":"Reference","title":"BEM.aplica_contato2!","text":"aplica contato 2corpos\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato_incremental!-NTuple{8, Any}","page":"Reference","title":"BEM.aplica_contato_incremental!","text":"aplica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.aplica_contato_incremental2!-NTuple{7, Any}","page":"Reference","title":"BEM.aplica_contato_incremental2!","text":"aplica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.assemble_hmatrix-Tuple{AbstractKernelMatrix}","page":"Reference","title":"BEM.assemble_hmatrix","text":"assembel_hmatrix(K::AbstractKernelMatrix[; atol, rank, rtol, kwargs...])\n\nConstruct an approximation of K as an HMatrix using the partial ACA algorithm for the low rank blocks. The atol, rank, and rtol optional arguments are passed to the PartialACA constructor, and the remaining keyword arguments are forwarded to the main assemble_hmatrix function.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.assemble_hmatrix-Union{Tuple{T}, Tuple{Type{T}, Any, Any, Any}} where T","page":"Reference","title":"BEM.assemble_hmatrix","text":"assemble_hmatrix([T,], K, rowtree, coltree;\n    adm=StrongAdmissibilityStd(),\n    comp=PartialACA(),\n    threads=true,\n    distributed=false,\n    global_index=true)\n\nMain routine for assembling a hierarchical matrix. The argument K represents the matrix to be approximated, rowtree and coltree are tree structure partitioning the row and column indices, respectively, adm can be called on a node of rowtree and a node of coltree to determine if the block is compressible, and comp is a function/functor which can compress admissible blocks.\n\nIt is assumed that K supports getindex(K,i,j), and that comp can be called as comp(K,irange::UnitRange,jrange::UnitRange) to produce a compressed version of K[irange,jrange] in the form of an RkMatrix.\n\nThe type paramter T is used to specify the type of the entries of the matrix, by default is inferred from K using eltype(K).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.binary_split!-Union{Tuple{T}, Tuple{N}, Tuple{ClusterTree{N, T}, Function}} where {N, T}","page":"Reference","title":"BEM.binary_split!","text":"binary_split!(cluster::ClusterTree,predicate)\n\nSplit a ClusterTree into two, sorting all elements in the process according to predicate. cluster is assigned as parent to each children.\n\nEach point is sorted according to whether f(x) returns true (point sorted on the \"left\" node) or false (point sorted on the \"right\" node). At the end a minimal HyperRectangle containing all left/right points is created.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.build_sequence_partition-NTuple{4, Any}","page":"Reference","title":"BEM.build_sequence_partition","text":"build_sequence_partition(seq,nq,cost,nmax)\n\nPartition the sequence seq into nq contiguous subsequences with a maximum of cost of nmax per set. Note that if nmax is too small, this may not be possible (see has_partition).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.center-Tuple{HyperRectangle}","page":"Reference","title":"BEM.center","text":"center(Ω)\n\nCenter of the smallest ball containing Ω.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.col_partition","page":"Reference","title":"BEM.col_partition","text":"col_partition(H::HMatrix,np,cost)\n\nSimilar to hilbert_partition, but attempts to partition the leaves of H by column.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.compress!-Tuple{BEM.RkMatrix, TSVD}","page":"Reference","title":"BEM.compress!","text":"compress!(M::RkMatrix,tsvd::TSVD)\n\nRecompress the matrix R using a truncated svd of R. The implementation uses the qr-svd strategy to efficiently compute svd(R) when rank(R) ≪ min(size(R)).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.compress!-Tuple{Matrix, TSVD}","page":"Reference","title":"BEM.compress!","text":"compress!(M::Matrix,tsvd::TSVD)\n\nRecompress the matrix M using a truncated svd and output an RkMatrix. The data in M is invalidated in the process.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.compression_ratio-Tuple{BEM.RkMatrix}","page":"Reference","title":"BEM.compression_ratio","text":"compression_ratio(R::RkMatrix)\n\nThe ratio of the uncompressed size of R to its compressed size in outer product format.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.compression_ratio-Tuple{HMatrix}","page":"Reference","title":"BEM.compression_ratio","text":"compression_ratio(H::HMatrix)\n\nThe ratio of the uncompressed size of H to its compressed size. A compression_ratio of 10 means it would have taken 10 times more memory to store H as a dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.container-Tuple{ClusterTree}","page":"Reference","title":"BEM.container","text":"container(clt::ClusterTree)\n\nReturn the object enclosing all the elements of the clt.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.criatensoes-Tuple{Any, Any}","page":"Reference","title":"BEM.criatensoes","text":"tens_nt, tens= criatensoes(dad, [-1,0,0])\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.depth","page":"Reference","title":"BEM.depth","text":"depth(tree,acc=0)\n\nRecursive function to compute the depth of node in a a tree-like structure.\n\nOverload this function if your structure has a more efficient way to compute depth (e.g. if it stores it in a field).\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.diameter-Tuple{HyperRectangle}","page":"Reference","title":"BEM.diameter","text":"diameter(Ω)\n\nLargest distance between x and y for x,y ∈ Ω.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.distance-Tuple{ClusterTree, ClusterTree}","page":"Reference","title":"BEM.distance","text":"distance(X::ClusterTree, Y::ClusterTree)\n\nDistance between the containers of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.distance-Union{Tuple{N}, Tuple{HyperRectangle{N}, HyperRectangle{N}}} where N","page":"Reference","title":"BEM.distance","text":"distance(Ω1,Ω2)\n\nMinimal Euclidean distance between a point x ∈ Ω1 and y ∈ Ω2.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.elements-Tuple{ClusterTree}","page":"Reference","title":"BEM.elements","text":"elements(clt::ClusterTree)\n\nIterable list of the elements inside clt.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.filter_tree","page":"Reference","title":"BEM.filter_tree","text":"filter_tree(f,tree,isterminal=true)\n\nReturn a vector containing all the nodes of tree such that f(node)==true.  The argument isterminal can be used to control whether to continue the search on children of nodes for which f(node)==true.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.filter_tree!","page":"Reference","title":"BEM.filter_tree!","text":"filter_tree!(filter,nodes,tree,[isterminal=true])\n\nLike filter_tree, but appends results to nodes.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.find_optimal_cost","page":"Reference","title":"BEM.find_optimal_cost","text":"find_optimal_cost(seq,nq,cost,tol)\n\nFind an approximation to the cost of an optimal partitioning of seq into nq contiguous segments. The optimal cost is the smallest number cmax such that has_partition(seq,nq,cost,cmax) returns true.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.find_optimal_partition","page":"Reference","title":"BEM.find_optimal_partition","text":"find_optimal_partition(seq,nq,cost,tol=1)\n\nFind an approximation to the optimal partition seq into nq contiguous segments according to the cost function. The optimal partition is the one which minimizes the maximum cost over all possible partitions of seq into nq segments.\n\nThe generated partition is optimal up to a tolerance tol; for integer valued cost, setting tol=1 means the partition is optimal.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.getblock!-NTuple{4, Any}","page":"Reference","title":"BEM.getblock!","text":"getblock!(block,K,irange,jrange)\n\nFill block with K[i,j] for i ∈ irange, j ∈ jrange, where block is of size length(irange) × length(jrange).\n\nA default implementation exists which relies on getindex(K,i,j), but this method can be overloaded for better performance if e.g. a vectorized way of computing a block is available.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.getcol!-Union{Tuple{T}, Tuple{Any, BEM.RkMatrix, Int64}, Tuple{Any, BEM.RkMatrix, Int64, Val{T}}} where T","page":"Reference","title":"BEM.getcol!","text":"getcol!(col,M::AbstractMatrix,j)\n\nFill the entries of col with column j of M.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.glob2loc-Tuple{ClusterTree}","page":"Reference","title":"BEM.glob2loc","text":"glob2loc(clt::ClusterTree)\n\nThe inverse of loc2glob.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.has_partition","page":"Reference","title":"BEM.has_partition","text":"has_partition(v,np,cost,cmax)\n\nGiven a vector v, determine whether or not a partition into np segments is possible where the cost of each partition does not exceed cmax.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.hilbert_cartesian_to_linear-Tuple{Integer, Any, Any}","page":"Reference","title":"BEM.hilbert_cartesian_to_linear","text":"hilbert_cartesian_to_linear(n,x,y)\n\nConvert the cartesian indices x,y into a linear index d using a hilbert curve of order n. The coordinates x,y range from 0 to n-1, and the output d ranges from 0 to n^2-1.\n\nSee https://en.wikipedia.org/wiki/Hilbert_curve.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.hilbert_linear_to_cartesian-Tuple{Integer, Any}","page":"Reference","title":"BEM.hilbert_linear_to_cartesian","text":"hilbert_linear_to_cartesian(n,d)\n\nConvert the linear index 0 ≤ d ≤ n^2-1 into the cartesian coordinates 0 ≤ x < n-1 and 0 ≤ y ≤ n-1 on the Hilbert curve of order n.\n\nSee https://en.wikipedia.org/wiki/Hilbert_curve.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.hilbert_partition","page":"Reference","title":"BEM.hilbert_partition","text":"hilbert_partition(H::HMatrix,np,cost)\n\nPartiotion the leaves of H into np sequences of approximate equal cost (as determined by the cost function) while also trying to maximize the locality of each partition.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.hmul!-Union{Tuple{T}, Tuple{T, T, T, Any, Any, Any}, Tuple{T, T, T, Vararg{Any, 4}}} where T<:HMatrix","page":"Reference","title":"BEM.hmul!","text":"hmul!(C::HMatrix,A::HMatrix,B::HMatrix,a,b,compressor)\n\nSimilar to mul! : compute C <-- A*B*a + B*b, where A,B,C are hierarchical matrices and compressor is a function/functor used in the intermediate stages of the multiplication to avoid growring the rank of admissible blocks after addition is performed.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.index_range-Tuple{ClusterTree}","page":"Reference","title":"BEM.index_range","text":"index_range(clt::ClusterTree)\n\nIndices of elements in root_elements(clt) which lie inside clt.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.integraelem-Tuple{Any, Any, Any, Any, Any, Union{elastico, elastico_aniso}}","page":"Reference","title":"BEM.integraelem","text":"Funcao para calcular fazer integracao no contorno \n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.integraelemd-NTuple{4, Any}","page":"Reference","title":"BEM.integraelemd","text":"Funcao para calcular a das funções de forma\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.isclean-Tuple{HMatrix}","page":"Reference","title":"BEM.isclean","text":"isclean(H::HMatrix)\n\nReturn true if all leaves of H have data, and if the leaves are the only nodes containing data. This is the normal state of an ℋ-matrix, but during intermediate stages of a computation data may be associated with non-leaf nodes for convenience.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.lagrange-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.lagrange","text":"pg ponto interpolado x ponto interpolador\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.loc2glob-Tuple{ClusterTree}","page":"Reference","title":"BEM.loc2glob","text":"loc2glob(clt::ClusterTree)\n\nThe permutation from the (local) indexing system of the elements of the clt to the (global) indexes used upon the construction of the tree.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.newcol!-Tuple{BEM.VectorOfVectors}","page":"Reference","title":"BEM.newcol!","text":"newcol!(A::VectorOfVectors)\n\nAppend a new (unitialized) column to A, and return a view of it.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.nosproximoskmeans","page":"Reference","title":"BEM.nosproximoskmeans","text":"indc=nosproximoskmeans(X,k=9) qr1=pqrfact(M[:,indc],rtol=1e-8) qr2=pqrfact(:c,qr1.Q,rtol=1e-8) indl=qr2.p[1:size(qr2.Q,1)] A1=M[:,indc] A2=M[indl,indc]divide M[indl,:] M=A1*A2\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.novelquad","page":"Reference","title":"BEM.novelquad","text":"f->  funçao a ser integrada m->ordem da singularidade t->posição da singularidade n->Quantidade de pontos de integração https://link.springer.com/article/10.1007/s10092-021-00446-1 t = 0.3 f1(x) = (1 + x - x^2) / (x - t)^1 f2(x) = (1 + x - x^2) / (x - t)^2 f3(x) = (1 + x - x^2) / (x - t)^3 eta, w = BEM.novelquad(2, (t - 0.5) * 2, 32) F1(x)=-(t^2 - t - 1) log(x - t) - 1/2 x (2 t + x - 2) dot(f1.(eta / 2 .+ 0.5), w) / 2-1.22523041106851637258923008288999 dot(f2.(eta / 2 .+ 0.5), w) / 2+6.42298561774988045927786175929650 dot(f3.(eta / 2 .+ 0.5), w) / 2-2.73546857952209343844408750481721\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.num_stored_elements-Tuple{BEM.RkMatrix}","page":"Reference","title":"BEM.num_stored_elements","text":"num_stored_elements(R::RkMatrix)\n\nThe number of entries stored in the representation. Note that this is not length(R).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.num_stored_elements-Tuple{HMatrix}","page":"Reference","title":"BEM.num_stored_elements","text":"num_stored_elements(H::HMatrix)\n\nThe number of entries stored in the representation. Note that this is not length(H).\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.radius-Tuple{HyperRectangle}","page":"Reference","title":"BEM.radius","text":"radius(Ω)\n\nHalf the diameter.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.reset!-Tuple{BEM.VectorOfVectors}","page":"Reference","title":"BEM.reset!","text":"reset!(A::VectorOfVectors)\n\nSet the number of columns of A to zero, and the number of rows to zero, but does not resize! the underlying data vector.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.root_elements-Tuple{ClusterTree}","page":"Reference","title":"BEM.root_elements","text":"root_elements(clt::ClusterTree)\n\nThe elements contained in the root of the tree to which clt belongs.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.row_partition","page":"Reference","title":"BEM.row_partition","text":"row_partition(H::HMatrix,np,cost)\n\nSimilar to hilbert_partition, but attempts to partition the leaves of H by row.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.should_split","page":"Reference","title":"BEM.should_split","text":"should_split(clt::ClusterTree, depth, splitter::AbstractSplitter)\n\nDetermine whether or not a ClusterTree should be further divided.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.split!","page":"Reference","title":"BEM.split!","text":"split!(clt::ClusterTree,splitter::AbstractSplitter)\n\nDivide clt using the strategy implemented by splitter. This function is reponsible of assigning the children and parent fields, as well as of permuting the data of clt.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#BEM.use_global_index-Tuple{}","page":"Reference","title":"BEM.use_global_index","text":"use_global_index()::Bool\n\nDefault choice of whether operations will use the global indexing system throughout the package.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.use_threads-Tuple{}","page":"Reference","title":"BEM.use_threads","text":"use_threads()::Bool\n\nDefault choice of whether threads will be used throughout the package.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.verifica_contato","text":"verifica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato2-Tuple{Any, Any, Any}","page":"Reference","title":"BEM.verifica_contato2","text":"verifica contato 2corpos\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato_incremental-NTuple{6, Any}","page":"Reference","title":"BEM.verifica_contato_incremental","text":"verifica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#BEM.verifica_contato_incremental2-NTuple{5, Any}","page":"Reference","title":"BEM.verifica_contato_incremental2","text":"verifica contato com superfície rígida\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Base.parent-Tuple{ClusterTree}","page":"Reference","title":"Base.parent","text":"parent(t::ClusterTree)\n\nThe node's parent. If t is a root, then parent(t)==t.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Base.split-Union{Tuple{N}, Tuple{HyperRectangle{N}, Any, Any}} where N","page":"Reference","title":"Base.split","text":"split(rec::HyperRectangle,[axis]::Int,[place])\n\nSplit a hyperrectangle in two along the axis direction at the  position place. Returns a tuple with the two resulting hyperrectangles.\n\nWhen no place is given, defaults to splitting in the middle of the axis.\n\nWhen no axis and no place is given, defaults to splitting along the largest axis.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.lu!-Tuple{HMatrix, Any}","page":"Reference","title":"LinearAlgebra.lu!","text":"lu!(M::HMatrix,comp)\n\nHierarhical LU facotrization of M, using comp to generate the compressed blocks during the multiplication routines.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.lu!-Tuple{HMatrix}","page":"Reference","title":"LinearAlgebra.lu!","text":"lu!(M::HMatrix;atol=0,rank=typemax(Int),rtol=atol>0 ||\nrank<typemax(Int) ? 0 : sqrt(eps(Float64)))\n\nHierarhical LU facotrization of M, using the PartialACA(;atol,rtol;rank) compressor.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.lu-Tuple{HMatrix, Vararg{Any}}","page":"Reference","title":"LinearAlgebra.lu","text":"LinearAlgebra.lu(M::HMatrix,args...;kwargs...)\n\nHierarchical LU factorization. See lu! for the available options.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#LinearAlgebra.mul!","page":"Reference","title":"LinearAlgebra.mul!","text":"mul!(y::AbstractVector,H::HMatrix,x::AbstractVector,a,b[;global_index,threads])\n\nPerform y <-- H*x*a + y*b in place.\n\n\n\n\n\n","category":"function"},{"location":"01-teoria/#Apresentação","page":"Apresentação","title":"Apresentação","text":"","category":"section"},{"location":"01-teoria/#Método-dos-elementos-de-contorno","page":"Apresentação","title":"Método dos elementos de contorno","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"O método dos elementos de contorno é bem conhecido entre engenheiros e cientistas. Ele tem demonstrado sua superioridade em relação a outros métodos numéricos, especialmente quando usado para modelar uma aplicação apropriada. Apesar da popularidade do método dos elementos de contorno, ele não é tão comum entre os engenheiros quanto o método dos elementos finitos. As razões para isso podem ser resumidas da seguinte forma:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"1- A complexidade da formulação matemática.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"2- A falta de códigos simples.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"3- A falta de  cursos de elementos de contorno entre estudantes de graduação.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"4- A dificuldade no tratamento de alguns modelos numéricos, como singularidade.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"5- A dificuldade em modificar programas de elementos de contorno em relação aos desenvolvidos usando elementos finitos.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"6- A falta de versatilidade dos códigos de elementos de contorno.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"7- A mudança de estratégia de modelagem de elementos finitos para elementos de contorno.","category":"page"},{"location":"01-teoria/#Vantagens-e-desvantagens","page":"Apresentação","title":"Vantagens e desvantagens","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"O Método dos Elementos de Contorno (BEM), como qualquer outro método numérico, tem suas vantagens e desvantagens. As vantagens do método dos elementos de contorno são as seguintes:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Apenas o contorno do problema precisa ser discretizado, o que leva a uma fácil preparação de dados e menores requisitos de computação.\nO tratamento exato de domínios infinitos e semi-infinitos.\nAs incógnitas em locais internos são calculadas na fase de pós-processamento, o que simplifica qualquer procedimento de otimização.\nResultados precisos no caso de concentrações de tensões devido a fissuras ou cargas concentradas.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Por outro lado, as desvantagens do método dos elementos de contorno são as seguintes:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"As matrizes do sistema são não simétricas e totalmente preenchidas.\nAs soluções fundamentais nem sempre são fáceis de obter.\nA dificuldade em tratar estruturas delgadas.\nA discretização do domínio necessária no caso de aplicações não lineares.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Desafios que precisam ser enfrentados para que o método tenha uma maior adesão:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Uma visão mais profunda dos aspectos matemáticos e numéricos do método.\nUm método sistemático para a derivação das soluções fundamentais e particulares.\nFórmula de integração estável.\nProgramas de uso geral e pequenos programas disponíveis para engenheiros.\nAcoplamento entre elementos de contorno e elementos finitos.","category":"page"},{"location":"01-teoria/#Por-que-JULIA?","page":"Apresentação","title":"Por que JULIA?","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"A escolha da linguagem JULIA é justificada por várias razões. JULIA é uma linguagem de programação de alto desempenho, projetada especificamente para computação científica e análise numérica. Suas bibliotecas e funcionalidades são otimizadas para realizar cálculos complexos de forma eficiente, o que é crucial para a implementação de métodos como o Método dos Elementos de Contorno (BEM). Além disso, JULIA possui uma sintaxe simples e intuitiva, o que facilita a escrita e a leitura de códigos, tornando o processo de desenvolvimento mais ágil. ","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Desempenho: JULIA é projetada para ter um desempenho superior em cálculos numéricos e científicos, superando Python em termos de velocidade. Isso se deve à sua capacidade de compilar código em tempo de execução, o que resulta em execução mais rápida. Python, por outro lado, pode ser mais lento devido à sua natureza interpretada, embora existam bibliotecas como Cython que ajudam a melhorar o desempenho.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Normalmente, uma linguagem é utilizada para o desenvolvimento rápido e prototipagem, enquanto a outra é usada para obter desempenho otimizado. Por exemplo, um cientista pode usar Python para escrever a lógica do código devido à sua simplicidade e riqueza de bibliotecas, mas precisará reescrever partes críticas em C ou Fortran para alcançar a velocidade necessária.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Essa abordagem tem várias desvantagens:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Complexidade de Manutenção: Manter código em duas linguagens diferentes pode ser complexo e propenso a erros, especialmente quando as mudanças precisam ser sincronizadas entre as duas versões.\nCurva de Aprendizado: Exige que os desenvolvedores sejam proficientes em ambas as linguagens, o que pode não ser sempre o caso.\nIntegração Difícil: A integração entre diferentes linguagens pode ser complicada, exigindo ferramentas e técnicas adicionais para gerenciar a comunicação entre elas.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Uma solução para esse problema é a utilização de linguagens como JULIA, que são projetadas para oferecer tanto facilidade de uso quanto alto desempenho. Isso elimina a necessidade de usar duas linguagens diferentes, simplificando o desenvolvimento, a manutenção e a execução de programas complexos.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Para instalar abra o terminal do windows e rode:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"winget install julia -s msstore\njulia","category":"page"},{"location":"01-teoria/#Formulação-do-BEM-1d","page":"Apresentação","title":"Formulação do BEM-1d","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Considere u e v como duas funções da variável independente x em um espaço unidimensional. A seguinte fórmula de integração por partes é bem conhecida:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"intlimits_x=x_1^x=x_2u(x) dv(x)=beginbmatrixu(x) v(x)endbmatrix_x=x_1^x=x_2-intlimits_x=x_1^x=x_2v(x) du(x)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"ela pode ser rescrita de maneira simplificada como:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"intlimits_x=x_1^x=x_2u(x) v(x)dx=leftu(x) v(x)right_x=x_1^x=x_2-intlimits_x=x_1^x=x_2v(x) u(x)dx","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"onde  representa a derivada. O primeiro termo do lado direito pode ser rescrito levando em conta o contorno. No caso unidimensional isso consiste exatamente nos pontos x_1 e x_2.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"beginalignedleftu(x) v(x)right_x=x_1^x=x_2 =leftu(x) v(x) n(x)right_ x=x_2+leftu(x) v(x) n(x)right_ x=x_1 Rightarrowsum_x=x_1x_2u(x)v(x)n(x)Rightarrowint_Gammau(x)v(x)n(x)dGamma endaligned","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Os demais termos tratam de uma integral no domínio e pode ser escritas como:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"intlimits_Omegau(x) v(x)dOmega=intlimits_Gammau(x) v(x)n(x)dGamma-intlimits_Omegav(x) u(x)dOmega ","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"É importante notar: 1- A ideia principal da integração por partes, é trocar o operador diferencial da função v para a função u. 2- Ao fazer essa troca, alguns termos de contorno aparecem. 3- A integração por partes foi feita apenas uma vez. No entanto, no BEM a integração por partes pode ser realizada uma, duas ou até quatro vezes dependendo da ordem da derivada. 4- Esse processo pode ser facilmente estendido para 2 ou 3 dimensões.","category":"page"},{"location":"01-teoria/#Equação-de-Laplace","page":"Apresentação","title":"Equação de Laplace","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"A formulação diferencial da equação de Laplace é dada por:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"fracd^2T(x)dx^2=0","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Usando integração por partes duas vezes na expressão dos resíduos ponderados:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"int_x_0^x_fT^*fracd^2Tdx^2dx=left( T^*fracdTdxright) ^x_f_x_0-int^x_f_x_0fracdT^*dxfracdTdxdx=left( T^*fracdTdx-TfracdT^*dxright) ^x_f_x_0-int^x_f_x_0fracd^2T^*dx^2Tdx\n","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Reescrevendo em termos do fluxo Q=fracdTdx:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"int_x_0^x_fT^*fracd^2Tdx^2dx=-left( TQ^*-T^*Qright) ^x_f_x_0-int_x_0^x_ffracd^2T^*dx^2Tdx","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Considerando que T^* é a solução fundamental do problema, ou seja:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"-fracd^2T^*(xx_d)dx^2=delta(x-x_d)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"onde delta é a função delta de Dirac.  Pode-se observar que T^*=-frac12x-x_d e Q^*=fracdT^*dx=-frac12textsign(x-x_d). Substituindo essas funções na equação integral obtém-se:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"-T(x_d)= T(x_f)Q^*(x_fx_d)-T^*(x_fx_d)Q(x_f)-T(x_0)Q^*(x_0x_d)+T^*(x_0x_d)Q(x_0)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Quando x_d é x_0 tem-se:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"T^*(x_0x_0)=0T^*(x_fx_0)=-fracx_f-x_02Q^*(x_0x_0)=frac12Q^*(x_fx_0)=-frac12","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Quando x_d é x_f tem-se:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"T^*(x_0x_f)=-fracx_f-x_02T^*(x_fx_f)=0Q^*(x_0x_f)=frac12Q^*(x_fx_f)=-frac12","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Logo, para o ponto x_d=x_0 a equação se torna:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"-T(x_0)= -T(x_f)frac12+fracx_f-x_02Q(x_f)-T(x_0)frac12+0Q(x_0)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"e para o ponto x_d=x_f","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"-T(x_f)= -T(x_f)frac12-0Q(x_f)-T(x_0)frac12-fracx_f-x_02Q(0)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Escrevendo as duas equações em forma matricial, tem-se:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"left beginmatrix05  -05 -05  05 endmatrixright left beginmatrixT(0)T(1) endmatrixright =(x_f-x_0)left beginmatrix0  -05 05  0 endmatrixright left beginmatrixQ(0)Q(1) endmatrixright ","category":"page"},{"location":"01-teoria/#Exemplos","page":"Apresentação","title":"Exemplos","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Caso 1: Condição de Dirichlet T(0)=100T(1)=0 quad T(x)=100-100x","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Caso 2: Condição mista T(0)=100Q(0)=0 quad T(x)=100","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"x0=0\nxf=1\nl=xf-x0\nA1=[0.5 -.5 0 l/2\n-.5 .5 -l/2 0\n1 0 0 0 \n0 1 0 0]\nb=[0,0,100,0]\nx1=A1\\b\n\nA2=[0.5 -.5 0 l/2\n-.5 .5 -l/2 0\n1 0 0 0 \n0 0 1 0]\nb=[0,0,100,0]\nx2=A2\\b","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Usando essa equação podemos calcular o valor da temperatura nos pontos internos:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"x0=0\nxf=1\nxs=range(x0,xf,length=100)\nT=0.5*(x1[1]+x1[2]).+(xs.-x0)/2*x1[3].+(xs.-xf)/2*x1[4]\nusing Plots\nplot(xs,T,legend=false,xlabel=\"x\",ylabel=\"T\",marker=:c)","category":"page"},{"location":"01-teoria/#Exercícios","page":"Apresentação","title":"Exercícios","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Uma outra possível condição de contorno é a convecção:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"q=h (T-T_infty)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"considere o problema onde o lado direito está exposto a T_infty=20textC, no lado esquerdo T(0)=100textC, e h= 3textWC. Resolva esse problema analicamente e numericamente usando BEM.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Quando existe uma fonte de calor distribuída b mais um termo aparece na equação integral:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"-T(x_d)= T(x_f)Q^*(x_fx_d)-T^*(x_fx_d)Q(x_f)-T(x_0)Q^*(x_0x_d)+T^*(x_0x_d)Q(x_0)+int_x_0^x_fT^*(xx_d)bdx","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Considere uma carga constante(isso torna a integral restante muito fácil de ser integrada analiticamente) e resolva um problema de uma grande placa de espessura L = 2 cm com condutividade térmica constante k = 1 W/m.K e geração uniforme de calor b = 1000 kW/m3. As faces A e B estão a temperaturas de 100C e 200C, respectivamente. Compare com a solução analítica:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"T=leftfracT_B-T_AL+fracb2k(L-x)rightx+T_A","category":"page"},{"location":"01-teoria/#Extra","page":"Apresentação","title":"Extra","text":"","category":"section"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Quando dois corpos trocam calor por radiação, o fluxo é proporcional à diferença da quarta potência de suas temperaturas absolutas: q_n=kappa f_sf_epsilon(u^4-u_R^4) onde u, uR são as temperaturas absolutas dos corpos radiantes, 𝜅 = 5.699 × 10−8 W∕(m2 K4) é a constante de Stefan-Boltzmann, 0 ≤ fs ≤ 1 é o fator de forma da radiação e 0 < f𝜖 ≤ 1 é a emissividade superficial, definida como o poder emissivo relativo de um corpo em comparação ao de um corpo negro ideal. A emissividade superficial também é igual ao coeficiente de absorção, definido como a fração da energia térmica incidente em um corpo que é absorvida. A radiação pode ser vista como uma condição de contorno convectiva onde o coeficiente de transferência de calor convectivo depende da temperatura dos corpos radiantes. Escrevendo:","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"q_n=kappa f_s f_epsilon(u^4-u_R^4)=underbracekappa f_s f_epsilon(u^2+u_R^2)(u+u_R)_h_r(u)(u-u_R)","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Os problemas de radiação devem ser resolvidos por iteração: primeiro, o problema linear é resolvido, então o coeficiente de transferência de calor convectivo é atualizado e a solução é repetida. O critério de parada é baseado no tamanho da variação de temperatura. Normalmente, são necessárias poucas iterações.","category":"page"},{"location":"01-teoria/","page":"Apresentação","title":"Apresentação","text":"Implemente essa condição de contorno no BEM.","category":"page"},{"location":"90-contributing/#contributing","page":"Contributing guidelines","title":"Contributing guidelines","text":"","category":"section"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"First of all, thanks for the interest!","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"Be polite and respectful, and follow the code of conduct.","category":"page"},{"location":"90-contributing/#Bug-reports-and-discussions","page":"Contributing guidelines","title":"Bug reports and discussions","text":"","category":"section"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you think you found a bug, feel free to open an issue. Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please.","category":"page"},{"location":"90-contributing/#Working-on-an-issue","page":"Contributing guidelines","title":"Working on an issue","text":"","category":"section"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it.","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"tip: Tip\nFeel free to ping us after a few days if there are no responses.","category":"page"},{"location":"90-contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If your solution involves code (or something that requires running the package locally), check the developer documentation. Otherwise, you can use the GitHub interface directly to create your pull request.","category":"page"},{"location":"10-exemplos/#exemplos","page":"Exemplos","title":"Exemplos","text":"","category":"section"},{"location":"10-exemplos/","page":"Exemplos","title":"Exemplos","text":"testes","category":"page"},{"location":"10-exemplos/","page":"Exemplos","title":"Exemplos","text":"Here's some inline maths: sqrtn1 + x + x^2 + ldots.","category":"page"},{"location":"","page":"BEM","title":"BEM","text":"CurrentModule = BEM","category":"page"},{"location":"#BEM","page":"BEM","title":"BEM","text":"","category":"section"},{"location":"","page":"BEM","title":"BEM","text":"Documentação do BEM.","category":"page"}]
}
