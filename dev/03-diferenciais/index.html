<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Equações diferenciais · BEM.jl</title><meta name="title" content="Equações diferenciais · BEM.jl"/><meta property="og:title" content="Equações diferenciais · BEM.jl"/><meta property="twitter:title" content="Equações diferenciais · BEM.jl"/><meta name="description" content="Documentation for BEM.jl."/><meta property="og:description" content="Documentation for BEM.jl."/><meta property="twitter:description" content="Documentation for BEM.jl."/><meta property="og:url" content="https://l-s-campos.github.io/BEM.jl/03-diferenciais/"/><meta property="twitter:url" content="https://l-s-campos.github.io/BEM.jl/03-diferenciais/"/><link rel="canonical" href="https://l-s-campos.github.io/BEM.jl/03-diferenciais/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BEM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">BEM</a></li><li><a class="tocitem" href="../01-teoria/">Apresentação</a></li><li><a class="tocitem" href="../02-interpola/">Interpolação</a></li><li class="is-active"><a class="tocitem" href>Equações diferenciais</a><ul class="internal"><li><a class="tocitem" href="#Sistemas-de-equações"><span>Sistemas de equações</span></a></li><li><a class="tocitem" href="#Runge-Kutta"><span>Runge-Kutta</span></a></li><li><a class="tocitem" href="#Métodos-de-múltiplos-passos"><span>Métodos de múltiplos passos</span></a></li><li><a class="tocitem" href="#Matrizes-de-diferenças-finitas"><span>Matrizes de diferenças finitas</span></a></li><li><a class="tocitem" href="#A-equação-de-**difusão**"><span>A equação de <strong>difusão</strong></span></a></li><li><a class="tocitem" href="#Exercício"><span>Exercício</span></a></li><li><a class="tocitem" href="#Equação-da-onda"><span>Equação da onda</span></a></li><li><a class="tocitem" href="#Desafio"><span>Desafio</span></a></li></ul></li><li><a class="tocitem" href="../10-exemplos/">Exemplos</a></li><li><a class="tocitem" href="../90-contributing/">Contributing guidelines</a></li><li><a class="tocitem" href="../91-developer/">Developer documentation</a></li><li><a class="tocitem" href="../95-reference/">Reference</a></li><li><a class="tocitem" href="../Viga de Euler/">Viga de euler</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Equações diferenciais</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Equações diferenciais</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/l-s-campos/BEM.jl/blob/master/docs/src/03-diferenciais.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Equações-diferenciais"><a class="docs-heading-anchor" href="#Equações-diferenciais">Equações diferenciais</a><a id="Equações-diferenciais-1"></a><a class="docs-heading-anchor-permalink" href="#Equações-diferenciais" title="Permalink"></a></h1><p>Quantidades que mudam continuamente no tempo ou no espaço são frequentemente modeladas por equações diferenciais.  As equações diferenciais precisam de condições suplementares para definir de maneira única tanto a situação de modelagem quanto as soluções teóricas. O problema de valor inicial (PVI), no qual todas as condições são dadas em um único valor da variável independente, é a situação mais simples. Muitas vezes, a variável independente neste caso representa o tempo.</p><p>Os métodos para PVIs geralmente começam a partir do valor inicial conhecido e iteram ou &quot;avançam&quot; a partir daí. Há um grande número desses métodos, em parte devido às diferenças em precisão, estabilidade e conveniência. </p><p>Um problema de valor inicial escalar de <strong>primeira ordem</strong> (PVI) é</p><p class="math-container">\[u&#39;(t) = f(t,u(t)), \qquad a \le t \le b,  \\\\
  u(a) =u_0.\]</p><p>Chamamos t de <strong>variável independente</strong> e <span>$u$</span> de <strong>variável dependente</strong>. Se <span>$u&#39; = f(t,u) = g(t) + u h(t)$</span>, a equação diferencial é <strong>linear</strong>; caso contrário, é <strong>não linear</strong>.</p><p>Uma <strong>solução</strong> de um problema de valor inicial é uma função <span>$u(t)$</span> que torna ambas as equações <span>$u&#39;(t)=f\bigl(t,u(t)\bigr)$</span> e <span>$u(a)=u_0$</span> verdadeiras.</p><p>Quando <span>$t$</span> representa o tempo, às vezes escrevemos <span>$\dot{u}$</span> (lê-se &quot;u-ponto&quot;) em vez de <span>$u&#39;$</span>.</p><h3 id="Soluções-numéricas"><a class="docs-heading-anchor" href="#Soluções-numéricas">Soluções numéricas</a><a id="Soluções-numéricas-1"></a><a class="docs-heading-anchor-permalink" href="#Soluções-numéricas" title="Permalink"></a></h3><p>O pacote <code>DifferentialEquations</code> oferece solucionadores para problemas de valor inicial (PVIs). Vamos usá-lo para definir e resolver um problema de valor inicial para <span>$u&#39;=\sin[(u+t)^2]$</span> sobre <span>$t \in [0,4]$</span>, tal que <span>$u(0)=1$</span>.</p><p>Como muitos problemas práticos vêm com parâmetros que são fixos dentro de uma instância, mas variam de uma instância para outra, a sintaxe para PVIs inclui um argumento de entrada <code>p</code> que permanece fixo durante toda a solução. Aqui não queremos usar esse argumento, mas ele deve estar na definição para que o solucionador funcione.</p><p>Para criar um problema de valor inicial para <span>$u(t)$</span>, você deve fornecer uma função que calcula <span>$u&#39;$</span>, um valor inicial para <span>$u$</span> e os pontos finais do intervalo para <span>$t$</span>. O intervalo <span>$t$</span> deve ser definido como <code>(a,b)</code>, onde pelo menos um dos valores é um float.</p><pre><code class="language-julia hljs">using DifferentialEquations,LaTeXStrings
f = (u,p,t) -&gt; sin((t+u)^2)     # define du/dt, deve incluir o argumento p
u₀ = 1.0                       # valor inicial
tspan = (0.0,4.0)               # intervalo t </code></pre><p>Com os dados acima, definimos um objeto de problema de PVI e depois o resolvemos. Aqui, informamos ao solucionador para usar o método <code>Tsit5</code>, que é uma boa escolha inicial para a maioria dos problemas.</p><pre><code class="language-julia hljs">ivp = ODEProblem(f,u₀,tspan)
sol = solve(ivp,Tsit5());</code></pre><p>O objeto solução resultante pode ser mostrado usando <code>plot</code>.</p><pre><code class="language-julia hljs">plot(sol,label=&quot;solução&quot;,legend=:bottom,
    xlabel=&quot;t&quot;,ylabel=L&quot;u(t)&quot;,title=L&quot;u&#39;=\\sin((t+u)^2)&quot;) </code></pre><p>A solução também funciona como qualquer função que pode ser avaliada em diferentes valores de <span>$t$</span>.</p><pre><code class="language-julia hljs">@show sol(1.0); </code></pre><p>Nos bastidores, o objeto solução contém algumas informações sobre como os valores e o gráfico são produzidos:</p><pre><code class="language-julia hljs">[sol.t sol.u]</code></pre><p>O solucionador inicialmente encontra valores aproximados da solução (segunda coluna acima) em alguns tempos escolhidos automaticamente (primeira coluna acima). Para calcular a solução em outros momentos, o objeto realiza uma interpolação nesses valores. Este capítulo trata de como os valores discretos de <span>$t$</span> e <span>$u$</span> são calculados. Por enquanto, apenas observe como podemos extraí-los do objeto solução.</p><pre><code class="language-julia hljs">scatter!(sol.t,sol.u,label=&quot;valores discretos&quot;) </code></pre><h3 id="Método-de-Euler"><a class="docs-heading-anchor" href="#Método-de-Euler">Método de Euler</a><a id="Método-de-Euler-1"></a><a class="docs-heading-anchor-permalink" href="#Método-de-Euler" title="Permalink"></a></h3><p>Considere um problema de valor inicial de primeira ordem. Representamos uma solução numérica de um PVI por seus valores em uma coleção finita de nós, que por enquanto exigimos que sejam igualmente espaçados:</p><p class="math-container">\[t_i = a + ih, \quad h=\frac{b-a}{n}, \quad i=0,\ldots,n. \]</p><p class="math-container">\[h\]</p><p>é chamado de <strong>tamanho do passo</strong>.</p><p>Como não obtemos valores exatamente corretos da solução nos nós, precisamos ter algum cuidado com a notação. A partir de agora, deixamos <span>$\hat{u}(t)$</span>  denotar a solução exata do PVI. O valor aproximado em <span>$t_i$</span>  calculado por nossos métodos numéricos será denotado por <span>$u_i\approx \hat{u}(t_i)$</span>. </p><p>Considere um interpolador linear por partes para os valores (ainda desconhecidos) <span>$u_0,u_1,\ldots, u_n$</span>. Para <span>$t_i &lt; t &lt; t_{i+1}$</span>, sua inclinação é</p><p class="math-container">\[\frac{u_{i+1} - u_{i}}{t_{i+1}-t_i} = \frac{u_{i+1}-u_i}{h}. \]</p><p>Podemos conectar essa derivada à equação diferencial seguindo o modelo de <span>$u&#39;=f(t,u)$</span>:</p><p class="math-container">\[\frac{u_{i+1}-u_i}{h} = f(t_i,u_i), \quad i=0,\ldots,n-1. \]</p><p>Podemos ver o lado esquerdo como uma aproximação para <span>$u&#39;(t)$</span> em <span>$t=t_i$</span>. Podemos reorganizar a equação para obter o <strong>método de Euler</strong>, nosso primeiro método para PVIs.</p><p>O método de Euler avança em <span>$t$</span>, obtendo a solução em um novo nível de tempo explicitamente em termos do valor mais recente   <span>$u_{i+1}=u_i + h f(t_i,u_i)$</span>.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    euler(ivp,n)

Aplique o método de Euler para resolver o PVI dado usando `n` passos de tempo.
Retorna um vetor de tempos e um vetor de valores da solução.
&quot;&quot;&quot;
function euler(ivp,n)
    # Discretização do tempo.
    a,b = ivp.tspan
    h = (b-a)/n
    t = [ a + i*h for i in 0:n ]

    # Condição inicial e configuração de saída.
    u = fill(float(ivp.u0),n+1)

    # A iteração de passos de tempo.
    for i in 1:n
        u[i+1] = u[i] + h*ivp.f(u[i],ivp.p,t[i])
    end
    return t,u
end
</code></pre><h3 id="Exemplo"><a class="docs-heading-anchor" href="#Exemplo">Exemplo</a><a id="Exemplo-1"></a><a class="docs-heading-anchor-permalink" href="#Exemplo" title="Permalink"></a></h3><p>Consideramos o PVI <span>$u&#39;=\sin[(u+t)^2]$</span> sobre <span>$0\le t \le 4$</span>, com <span>$u(0)=-1$</span>.</p><pre><code class="language-julia hljs">f = (u,p,t) -&gt; sin((t+u)^2);
tspan = (0.0,4.0);
u0 = -1.0;

ivp = ODEProblem(f,u0,tspan)
t,u = euler(ivp,20)

plot(t,u,m=2,label=&quot;n=20&quot;,
    xlabel=L&quot;t&quot;,ylabel=L&quot;u(t)&quot;,title=&quot;Solução por Euler&quot; )
</code></pre><p>Poderíamos definir um interpolador diferente para obter uma imagem mais suave acima, mas a derivação do método de Euler assumiu um interpolador linear por partes. Podemos, em vez disso, solicitar mais passos para fazer o interpolador parecer mais suave.</p><pre><code class="language-julia hljs">t,u = euler(ivp,50)
plot!(t,u,m=2,label=&quot;n=50&quot;)</code></pre><p>Aumentar <span>$n$</span> mudou a solução de maneira notável. Como sabemos que interpoladores e diferenças finitas se tornam mais precisos à medida que <span>$h\to 0$</span>, devemos antecipar o mesmo comportamento do método de Euler. Não temos uma solução exata para comparar, então usaremos um solucionador <code>DifferentialEquations</code> para construir uma solução de referência precisa.</p><pre><code class="language-julia hljs">u_exact = solve(ivp,Tsit5(),reltol=1e-14,abstol=1e-14)

plot!(u_exact,l=(2,:black),label=&quot;referência&quot;)</code></pre><p>Agora podemos realizar um estudo de convergência.</p><pre><code class="language-julia hljs">n = [ round(Int,5*10^k) for k in 0:0.5:3 ]
err = []
for n in n
    t,u = euler(ivp,n)
    push!( err, norm(u_exact.(t)-u,Inf) )
end

pretty_table((n=n,err=err),header=[&quot;n&quot;,&quot;Inf-norm error&quot;])
</code></pre><p>O erro é aproximadamente reduzido por um fator de 10 para cada aumento em <span>$n$</span> pelo mesmo fator. </p><h2 id="Sistemas-de-equações"><a class="docs-heading-anchor" href="#Sistemas-de-equações">Sistemas de equações</a><a id="Sistemas-de-equações-1"></a><a class="docs-heading-anchor-permalink" href="#Sistemas-de-equações" title="Permalink"></a></h2><p>Poucas aplicações envolvem um problema de valor inicial com apenas uma única variável dependente. Geralmente, existem múltiplas incógnitas e um sistema de equações para defini-las.</p><p>A generalização de qualquer solucionador escalar de PVI para lidar com sistemas é direta. Considere o método de Euler, que na forma de sistema se torna</p><p class="math-container">\[    \mathbf{u}_{i+1} = \mathbf{u}_i + h\,\mathbf{f}(t_i,\mathbf{u}_i), \qquad i=0,\ldots,n-1.\]</p><p>A equação de diferenças vetoriais é apenas a fórmula de Euler aplicada simultaneamente a cada componente do sistema de EDO. Como operações como adição e multiplicação se traduzem facilmente de escalares para vetores, a função que escrevemos para PVIs escalares funciona para sistemas também. Praticamente falando, as únicas mudanças que devem ser feitas são que a condição inicial e a função de EDO têm que ser codificadas para usar vetores.</p><p>Felizmente, a capacidade de resolver sistemas de de primeira ordem implica também a capacidade de resolver sistemas de ordem diferencial mais alta. A razão é que existe uma maneira sistemática de transformar um problema de ordem superior em um de primeira ordem de dimensão superior.</p><p>Dois pêndulos idênticos suspensos na mesma barra e oscilando em planos paralelos podem ser modelados como o sistema de segunda ordem</p><p><img src="../massa-mola.png" alt="massa-mola"/></p><p class="math-container">\[  \theta_1&#39;&#39;(t) +\gamma \theta_1&#39; + \frac{g}{L} \sin \theta_1 +  k(\theta_1-\theta_2) = 0,\\  \theta_2&#39;&#39;(t) +\gamma \theta_2&#39; + \frac{g}{L} \sin \theta_2 +  k(\theta_2-\theta_1) = 0,\]</p><p>onde <span>$\theta_1$</span> e <span>$\theta_2$</span>  são os ângulos feitos pelos dois pêndulos, <span>$L$</span>  é o comprimento de cada pêndulo, <span>$\gamma$</span> é um parâmetro de fricção, e <span>$k$</span> é um parâmetro que descreve um torque produzido pela barra quando ela é torcida. Podemos converter este problema em um sistema de primeira ordem usando as substituições </p><p class="math-container">\[  u_1 = \theta_1, \quad u_2 = \theta_2, \quad u_3 = \theta_1&#39;, \quad  u_4 = \theta_2&#39;\]</p><p>Com essas definições, o sistema se torna</p><p class="math-container">\[  u_1&#39; = u_3, \\  u_2&#39; = u_4, \\  u_3&#39; = -\gamma u_3 - \frac{g}{L}\sin u_1 + k(u_2-u_1), \\  u_4&#39; = -\gamma u_4 - \frac{g}{L}\sin u_2 + k(u_1-u_2),\]</p><p>que é um sistema de primeira ordem em quatro dimensões. Para completar a descrição do problema, é necessário especificar valores para <span>$\theta_1(0)$</span>, <span>$\theta_1&#39;(0)$</span>, <span>$\theta_2(0)$</span> e <span>$\theta_2&#39;(0)$</span>. </p><p>O truque ilustrado nos exemplos anteriores está sempre disponível. Para cada variável dependente escalar no sistema, introduza novos componentes até a derivada mais alta que aparece para <span>$y$</span>. As equações do sistema de primeira ordem vêm das relações triviais entre todas as derivadas inferiores e das equações originais de alta ordem. No final, deve haver tantas equações de componentes escalares quanto variáveis desconhecidas de primeira ordem.</p><h3 id="Exemplo-2"><a class="docs-heading-anchor" href="#Exemplo-2">Exemplo</a><a class="docs-heading-anchor-permalink" href="#Exemplo-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">function couple(u,p,t)
    γ,L,k = p
    g = 9.8
    udot = similar(u)
    udot[1:2] .= u[3:4]
    udot[3] = - γ*u[3] - (g/L)*sin(u[1]) + k*(u[2]-u[1])
    udot[4] = - γ*u[4] - (g/L)*sin(u[2]) + k*(u[1]-u[2])
    return udot 
end
u₀ = [1.25,-0.5,0,0]
tspan = (0.,50.);
γ,L,k = 0,0.5,0
ivp = ODEProblem(couple,u₀,tspan,[γ,L,k])
sol = solve(ivp,Tsit5())
plot(sol,vars=[1,2],label=[L&quot;\theta_1&quot; L&quot;\theta_2&quot;],
    xlims=[20,50],title=&quot;k=0&quot;)
    
k = 1
ivp = ODEProblem(couple,u₀,tspan,[γ,L,k])
sol = solve(ivp,Tsit5())
plot(sol,vars=[1,2],label=[L&quot;\theta_1&quot; L&quot;\theta_2&quot;],
    xlims=[20,50],title=&quot;k=1&quot;)   
    </code></pre><h2 id="Runge-Kutta"><a class="docs-heading-anchor" href="#Runge-Kutta">Runge-Kutta</a><a id="Runge-Kutta-1"></a><a class="docs-heading-anchor-permalink" href="#Runge-Kutta" title="Permalink"></a></h2><p>Chegamos agora a um dos principais e mais utilizados tipos de métodos para problemas de valor inicial: métodos Runge-Kutta. São métodos de uma etapa, embora eles não sejam frequentemente escritos nessa forma. Os métodos RK aumentam a precisão da primeira ordem, avaliando a função da EDO <span>$f (t, u)$</span> mais de uma vez por etapa do tempo.</p><ul><li>Método de segunda ordemConsidere uma expansão em série da solução exata para <span>$u&#39;=f(t,u),$</span><code>math   \hat{u}(t_{i+1}) = \hat{u}(t_i) + h \hat{u}&#39;(t_i) + \frac{1}{2}h^2 \hat{u}&#39;&#39;(t_i) + O(h^3) .</code>Se substituirmos <span>$\hat{u}&#39;$</span> por <span>$f$</span> e mantivermos apenas os dois primeiros termos no lado direito, obteremos o método de Euler. Para obter mais precisão, precisaremos calcular ou estimar o terceiro termo também. Observe que<code>math   \hat{u}&#39;&#39; = f&#39; = \frac{d f}{d t} = \frac{\partial f}{\partial t} + \frac{\partial f}{\partial u} \frac{d u}{d t} = f_t + f_u f,</code>onde aplicamos a regra da cadeia multidimensional à derivada, porque ambos os argumentos de <span>$f$</span> dependem de <span>$t$</span>. Usando essa expressão, obtemos<code>math   \hat{u}(t_{i+1}) = \hat{u}(t_i) + h\left[f\bigl(t_i,\hat{u}(t_i)\bigr) +    \frac{h}{2}f_t\bigl(t_i,\hat{u}(t_i)\bigr) +    \frac{h}{2}f\bigl(t_i,\hat{u}(t_i)\bigr)\,f_u\bigl(t_i,\hat{u}(t_i)\bigr)\right] \\  + O(h^3).</code>Uma aproximação dessas derivadas parciais de <span>$f$</span> é necessária. Observe que<code>math     f\bigl(t_i+\alpha,\hat{u}(t_i)+\beta\bigr) = f\bigl(t_i,\hat{u}(t_i)\bigr) +  \alpha f_t\bigl(t_i,\hat{u}(t_i)\bigr) + \beta f_u\bigl(t_i,\hat{u}(t_i)\bigr) +  O\bigl(\alpha^2 + |\alpha\beta| + \beta^2\bigr).</code>Correspondendo esta expressão ao termo entre colchetes e selecionando <span>$\alpha = h/2$</span>  e <span>$\beta = \frac{1}{2}h f\bigl(t_i,\hat{u}(t_i)\bigr).$</span> Fazendo isso, encontramos<code>math   \hat{u}(t_{i+1}) = \hat{u}(t_i) + h\left[f\bigl(t_i+\alpha,\hat{u}(t_i)+\beta\bigr)\right] +  O(h\alpha^2 + h|\alpha \beta| + h\beta^2 + h^3).</code>Truncar a série aqui resulta em um novo método de uma etapa.</li></ul><h3 id="Método-de-Euler-Melhorado"><a class="docs-heading-anchor" href="#Método-de-Euler-Melhorado">Método de Euler Melhorado</a><a id="Método-de-Euler-Melhorado-1"></a><a class="docs-heading-anchor-permalink" href="#Método-de-Euler-Melhorado" title="Permalink"></a></h3><p>O método de Euler melhorado é a fórmula de uma etapa</p><p class="math-container">\[{u}_{i+1} = u_i +  hf\left(t_i+\tfrac{1}{2}h,u_i+\tfrac{1}{2}h f(t_i,u_i)\right).\]</p><p>Graças às definições acima a ordem de precisão do Euler melhorado é dois. Em um primeiro estágio, o método faz meio passo de Euler <span>$h/2$</span></p><p class="math-container">\[  k_1 = h f(t_i,u_i), \\  v = u_i + \tfrac{1}{2}k_1.\]</p><p>e no segundo estágio ele usa o passo inteiro de Euler mas usa o valor obtido no primeiro estágio para a inclinação.</p><p class="math-container">\[  k_2 = h f\left(t_i+\tfrac{1}{2}h,v\right),\\  {u}_{i+1} = u_i + k_2.\]</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    euler2(ivp,n)

Aplique o método de Euler Melhorado para resolver o PVI dado usando `n`
passos de tempo. Retorna um vetor de tempos e um vetor de valores da solução.
&quot;&quot;&quot;
function me2(ivp,n)
    # Discretização do tempo.
    a,b = ivp.tspan
    h = (b-a)/n
    t = [ a + i*h for i in 0:n ]

    # Inicializar saída.
    u = fill(float(ivp.u0),n+1)

    # Iteração de passos de tempo.
    for i in 1:n
        uhalf = u[i] + h/2*ivp.f(u[i],ivp.p,t[i]);
        u[i+1] = u[i] + h*ivp.f(uhalf,ivp.p,t[i]+h/2);
    end
    return t,u
end
</code></pre><p>Esse procedimento pode ser feito para ordens mais altas mas a complexidade aumenta rapidamente. </p><p>O método de Runge-Kutta mais comumente usado, e talvez o método mais popular de todos, é o de quarta ordem, dado por:</p><p class="math-container">\[    k_1 = hf(t_i,u_i), \\    k_2 = hf(t_i+h/2,u_i+k_1/2),\\    k_3 = hf(t_i+h/2,u_i+k_2/2),\\    k_4 = hf(t_i+h,u_i+k_3),\\    u_{i+1} = u_i + \frac{1}{6} k_1 + \frac{1}{3} k_2 + \frac{1}{3} k_3 + \frac{1}{6} k_4.\]</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    rk4(ivp,n)

Aplique o método comum de Runge-Kutta de 4ª ordem para resolver o PVI dado
usando `n` passos de tempo. Retorna um vetor de tempos e um vetor de
valores da solução.
&quot;&quot;&quot;
function rk4(ivp,n)
    # Discretização do tempo.
    a,b = ivp.tspan
    h = (b-a)/n
    t = [ a + i*h for i in 0:n ]

    # Inicializar saída.
    u = fill(float(ivp.u0),n+1)

    # Iteração de passos de tempo.
    for i in 1:n
        k₁ = h*ivp.f( u[i],      ivp.p, t[i]     )
        k₂ = h*ivp.f( u[i]+k₁/2, ivp.p, t[i]+h/2 )
        k₃ = h*ivp.f( u[i]+k₂/2, ivp.p, t[i]+h/2 )
        k₄ = h*ivp.f( u[i]+k₃,   ivp.p, t[i]+h   )
        u[i+1] = u[i] + (k₁ + 2(k₂+k₃) + k₄)/6
    end
    return t,u
end</code></pre><pre><code class="language-julia hljs">f = (u,p,t) -&gt; sin((t+u)^2)
ivp = ODEProblem(f,u0,tspan)
tspan = (0.0,4.0)
u₀ = -1.0
u_ref = solve(ivp,Tsit5(),reltol=1e-14,abstol=1e-14);

n = [ round(Int,2*10^k) for k in 0:0.5:3 ]
err_IE2,err_RK4 = [],[]
for n in n
    t,u = euler2(ivp,n)
    push!( err_IE2, maximum( @.abs(u_ref(t)-u) ) )
    t,u = rk4(ivp,n)
    push!( err_RK4, maximum( @.abs(u_ref(t)-u) ) )
end

pretty_table([n err_IE2 err_RK4],header=[&quot;n&quot;,&quot;IE2 erro&quot;,&quot;RK4 erro&quot;])</code></pre><h2 id="Métodos-de-múltiplos-passos"><a class="docs-heading-anchor" href="#Métodos-de-múltiplos-passos">Métodos de múltiplos passos</a><a id="Métodos-de-múltiplos-passos-1"></a><a class="docs-heading-anchor-permalink" href="#Métodos-de-múltiplos-passos" title="Permalink"></a></h2><p>Nos métodos de Runge–Kutta, começamos em <span>$u_i$</span>  para encontrar <span>$u_{i+1}$</span>, realizando múltiplas avaliações de f (estágios) para alcançar alta precisão. Em contraste, os métodos de múltiplos passos aumentam a precisão utilizando mais do histórico da solução, aproveitando informações do passado recente. Para a discussão nesta e nas seções seguintes, introduzimos a notação abreviada <span>$f_i = f(t_i, u_i).$</span></p><p>Um método de <strong>múltiplos passos</strong> (ou <em>método linear de múltiplos passos</em>) de <span>$k$</span> passos é dado pela equação <span>$u_{i+1} = a_{k-1}u_i + \cdots + a_0 u_{i-k+1} \qquad \\
\qquad + h ( b_kf_{i+1} + \cdots + b_0 f_{i-k+1}),$</span></p><p>onde <span>$a_j$</span> e <span>$b_j$</span>  são constantes. Se <span>$b_k=0$</span>, o método é <strong>explícito</strong>; caso contrário, é <strong>implícito</strong>.</p><p>As quantidades <span>$u$</span> e <span>$f$</span> são mostradas como escalares, mas em geral podem ser vetores.</p><p>Para usar como um método numérico, iteramos através de <span>$i=k-1,\ldots,n-1$</span>. O valor <span>$u_0$</span>  é determinado pela condição inicial, mas também precisamos de alguma forma de gerar os <strong>valores iniciais</strong> <span>$u_1=\alpha_1, \quad \ldots \quad u_{k-1}=\alpha_{k-1}.$</span></p><p>A fórmula define <span>$u_{i+1}$</span> em termos de valores conhecidos da solução e sua derivada do passado. No caso explícito com <span>$b_k=0$</span>, a Equação imediatamente fornece uma fórmula para a quantidade desconhecida <span>$u_{i+1}$</span> em termos de valores no nível de tempo <span>$t_i$</span> e anteriores. Assim, apenas uma nova avaliação de f é necessária para fazer um passo de tempo, desde que armazenemos o histórico recente.</p><p>Por exemplo a formula do Adams-Bashforth de quarta ordem é dada por:</p><p class="math-container">\[\mathbf{u}_{i+1} = \mathbf{u}_i + h\, ( \tfrac{55}{24}\mathbf{f}_i - \tfrac{59}{24} \mathbf{f}_{i-1} + \tfrac{37}{24}\mathbf{f}_{i-2} - \tfrac{9}{24}\mathbf{f}_{i-3}), \quad i=3,\ldots,n-1.\]</p><pre><code class="language-julia hljs">function ab4(ivp,n)
    # Discretização do tempo.
    a,b = ivp.tspan
    h = (b-a)/n
    t = [ a + i*h for i in 0:n ]

    # Constantes no método AB4.
    k = 4;   σ = [-9,37,-59,55]/24;

    # Encontrar valores iniciais usando RK4.
    u = fill(float(ivp.u0),n+1)
    rkivp = ODEProblem(ivp.f,ivp.u0,(a,a+(k-1)*h),ivp.p)
    ts,us = rk4(rkivp,k-1)
    u[1:k] .= us

    # Calcular histórico dos valores de u&#39;, do mais recente ao mais antigo.
    f = [ ivp.f(u[i],ivp.p,t[i]) for i in 1:k ]
    # Iteração de passos de tempo.
    for i in k+1:n+1
        u[i] = u[i-1] + h*dot(f,σ)  # avançar um passo
        f = [ f[2:k];ivp.f(u[i],ivp.p,t[i]) ]   # novo valor de du/dt
    end
    return t,u
end</code></pre><p>Agora fazemos um estudo de convergência:</p><pre><code class="language-julia hljs">err_AB4 = []
for n in n
    t,u = ab4(ivp,n)
    push!( err_AB4, maximum( @.abs(u_ref(t)-u) ) )
end

pretty_table([n err_IE2 err_RK4 err_AB4],[&quot;n&quot;,&quot;IE2 erro&quot;,&quot;RK4 erro&quot;,&quot;AB4 erro&quot;])</code></pre><p>Os métodos de Adams-Moulton são métodos implícitos e, portanto, não podem ser resolvidos como fazemos no caso dos métodos de Adams-Bashforth.  Portanto, para obter o valor aproximado de <span>$u_{i+1}$</span>, podemos usar um método de dois passos chamado método preditor-corretor. </p><p>No passo 1, usamos um método explícito, como o método de Adams-Bashforth, chamado preditor, para obter um valor aproximado inicial e no passo 2, chamado corretor, melhoramos a estimativa inicial. </p><p>O método Adams-Moulton implícito de quarta ordem é dado por:</p><p><span>$\mathbf{u}_{i+1}^k = \mathbf{u}_i + h\, (\tfrac{9}{24}\red{\mathbf{f}_{i+1}^{k-1}}+ \tfrac{19}{24}\mathbf{f}_i - \tfrac{5}{24} \mathbf{f}_{i-1} + \tfrac{1}{24}\mathbf{f}_{i-2} )$</span></p><p>esse passo pode ser repetido até obter  <span>$|u_{i+1}^{(k)} - u_{i+1}^{(k-1)}| \leq \epsilon |u_{i+1}^{(k-1)}|$</span> </p><pre><code class="language-julia hljs">function am4(ivp, n; tol=1e-8, max_iter=10)
    # Discretização do tempo.
    a, b = ivp.tspan
    h = (b - a) / n
    t = [a + i * h for i in 0:n]

    # Constantes do método AM4.
    k = 4
    σ = [1, -5, 19,9] / 24
    σb = [-9,37,-59,55]/24

    # Encontrar valores iniciais usando RK4.
    u = fill(float(ivp.u0), n + 1)
    rkivp = ODEProblem(ivp.f, ivp.u0, (a, a + (k - 1) * h), ivp.p)
    ts, us = rk4(rkivp, k - 1)
    u[1:k] .= us

    # Calcular histórico dos valores de u&#39;, do mais recente ao mais antigo.
    f = [ ivp.f(u[i],ivp.p,t[i]) for i in 1:k ]
    # Iteração de passos de tempo.
    for i in k+1:n+1
        u[i] = u[i-1] + h*dot(f,σb)  # avançar um passo
        f = [ f[2:k];ivp.f(u[i],ivp.p,t[i]) ]   # novo valor de du/dt

        # Método de correção.
        u_corr=0
        for iter in 1:max_iter
            u_corr = u[i-1] + h*dot(f,σ)  # avançar um passo
            # @show iter,abs(u[i] - u_corr) , tol * abs(u_corr)
            if abs(u[i] - u_corr) &lt;= tol * abs(u_corr)
                break
            end
            f[4] = ivp.f(u_corr,ivp.p,t[i])   # novo valor de du/dt
            u[i ] = u_corr
        end
    end

    return t, u
end
</code></pre><h3 id="Exercícios"><a class="docs-heading-anchor" href="#Exercícios">Exercícios</a><a id="Exercícios-1"></a><a class="docs-heading-anchor-permalink" href="#Exercícios" title="Permalink"></a></h3><p>1- Escolha 5 PVI, use as funções   <code>rk4</code> ,<code>ab4</code>  e  <code>am4</code> e resolva para <span>$n=10\cdot2^d$</span> e <span>$d=1,\ldots,10$</span>. Faça um gráfico de convergência log-log para os erros no tempo final <span>$|u_n-\hat{u}(t_n)|$</span> por <span>$n$</span>, e adicione uma linha reta indicando a convergência de quarta ordem. Com <span>$n=100$</span>, trace a solução e o erro <span>$u-\hat{u}$</span> em gráficos separados.</p><p class="math-container">\[u&#39; = -2t u, \ 0 \le t \le 2, \ u(0) = 2;\  \hat{u}(t) = 2e^{-t^2}\\
u&#39; = u + t, \ 0 \le t \le 1, \ u(0) = 2;\  \hat{u}(t) = 1-t+e^t
\\u&#39; = x^2/[u(1+x^3)],\ 0 \le x \le 3, \ u(0) =1;\ \hat{u}(x) =[1+(2/3)\ln (1+x^3)]^{1/2}
\\u&#39;&#39;+ 9u = 9t, \: 0&lt; t&lt; 2\pi, \: u(0) =1,\: u&#39;(0) = 1; \: \hat{u}(t) = t+\cos (3t)
\\u&#39;&#39;+ 9u = \sin(2t), \: 0&lt; t&lt; 2\pi, \: u(0) =2,\: u&#39;(0) = 1;    \quad \hat{u}(t) = (1/5) \sin(3t) + 2 \cos (3t)+ (1/5) \sin (2t)
\\u&#39;&#39;- 9u = 9t \: 0&lt; t&lt; 1, \: u(0) =2,\: u&#39;(0) = -1; \: \hat{u}(t) = e^{3t} + e^{-3t}-t
\\u&#39;&#39;+ 4u&#39;+ 4u = t, \: 0&lt; t&lt; 4, \: u(0) =1,\: u&#39;(0) = 3/4; \: \hat{u}(t) = (3t+5/4)e^{-2t} + \\x^2 u&#39;&#39; +5xu&#39; + 4u = 0,\: 1&lt;x&lt;e^2, \: u(1) =1, \: u&#39;(1) = -1; \: \hat{u}(x) = x^{-2}( 1 + \ln x)
\\2 x^2 u&#39;&#39; +3xu&#39; - u = 0,\: 1&lt;x&lt;16, \: u(1) =4, \: u&#39;(1) = -1;    \quad \hat{u}(x) = 2(x^{1/2} + x^{-1})
\\x^2 u&#39;&#39; -xu&#39; + 2u = 0,\: 1&lt;x&lt;e^{\pi}, \: u(1) =3, \: u&#39;(1) = 4;    \quad \hat{u}(x) = x \left[ 3 \cos \left( \ln x \right)+\sin \left( \ln x \right) \right]\]</p><p>2- O método de Houbolt é comumente usado em problemas de dinâmica estrutural. O método é conhecido por sua estabilidade e é especialmente eficaz em problemas onde é necessário lidar com altas frequências ou amortecimento. Ele descreve as derivadas de ordem 1 e 2 como:</p><p class="math-container">\[\begin{aligned}&amp;u&#39;&#39;_{n+1}=\frac{2u_{n+1}-5u_{n}+4u_{n-1}-u_{n-2}}{h^{2}}\\&amp;u&#39;_{n+1}=\frac{11u_{n+1}-18u_{n}+9u_{n-1}-2u_{n-2}}{6h}\end{aligned}\]</p><p>implemente esse método e o compare com um dos problemas resolvidos  na questão anterior.</p><h2 id="Matrizes-de-diferenças-finitas"><a class="docs-heading-anchor" href="#Matrizes-de-diferenças-finitas">Matrizes de diferenças finitas</a><a id="Matrizes-de-diferenças-finitas-1"></a><a class="docs-heading-anchor-permalink" href="#Matrizes-de-diferenças-finitas" title="Permalink"></a></h2><p>Primeiro discretizamos o intervalo  <span>$x \in [a,b]$</span> em pedaços iguais de comprimento <span>$h = \frac{b-a}{n}$</span>, levando aos nós <span>$x_i = a + i h, \qquad  i = 0, \ldots, n$</span>.</p><p>Nosso objetivo é encontrar um vetor <span>$\mathbf{g}$</span>  tal que  <span>$g_i \approx f&#39;(x_i)$</span>  para  <span>$i = 0, \ldots, n$</span>. Usando a fórmula de diferenças finitas:</p><p><span>$g_n = \frac{f_n - f_{n-1}}{h}$</span>.</p><p>Podemos resumir todo o conjunto de fórmulas definindo</p><p class="math-container">\[\mathbf{f} =
\begin{bmatrix}
f(x_0) \\ f(x_1) \\ \vdots \\ f(x_{n-1}) \\ f(x_n)
\end{bmatrix}\]</p><p>,</p><p>e então a equação vetorial</p><p class="math-container">\[\begin{bmatrix}f&#39;(x_0) \\[1mm] f&#39;(x_1) \\[1mm] \vdots \\[1mm] f&#39;(x_{n-1}) \\[1mm] f&#39;(x_n)\end{bmatrix}\approx\mathbf{D}_x \mathbf{f}, \qquad\mathbf{D}_x= \frac{1}{h}\begin{bmatrix}-1 &amp; 1 &amp; &amp; &amp; \\[1mm]&amp; -1 &amp; 1 &amp; &amp; \\[1mm]&amp; &amp; \ddots &amp; \ddots &amp; \\[1mm]&amp; &amp; &amp; -1 &amp; 1 \\[1mm]&amp; &amp; &amp; -1 &amp; 1\end{bmatrix}.\]</p><p>Aqui, como em outros lugares, os elementos de <span>$\mathbf{D}_x$</span>  que não são mostrados são zero. Chamamos <span>$\mathbf{D}_x$</span> de <strong>matriz de diferenciação</strong>. Cada linha de <span>$\mathbf{D}_x$</span>  fornece os pesos da fórmula de diferença finita usada em um dos nós.</p><p>A matriz de diferenciação não é uma escolha única. Somos livres para usar quaisquer fórmulas de diferença finita que quisermos em cada linha. No entanto, faz sentido escolher linhas que sejam o mais semelhantes possível. Usando diferenças centradas de segunda ordem onde possível e fórmulas unilaterais de segunda ordem nos pontos de fronteira resulta em</p><p class="math-container">\[\mathbf{D}_x = \frac{1}{h}\begin{bmatrix}-\frac{3}{2} &amp; 2    &amp; -\frac{1}{2}   &amp;        &amp;        &amp;  \\[1mm]-\frac{1}{2} &amp; 0    &amp; \frac{1}{2}    &amp;        &amp;        &amp;  \\[1mm]&amp; -\frac{1}{2} &amp; 0      &amp; \frac{1}{2}    &amp;        &amp;  \\&amp;      &amp; \ddots &amp; \ddots &amp; \ddots &amp;  \\&amp;      &amp;        &amp; -\frac{1}{2}   &amp; 0      &amp; \frac{1}{2} \\[1mm]&amp;      &amp;        &amp; \frac{1}{2}    &amp; -2     &amp; \frac{3}{2}\end{bmatrix}.\]</p><p>As matrizes de diferenciação até agora são matrizes bandadas, ou seja, todos os valores não zero estão ao longo das diagonais próximas à diagonal principal.</p><h3 id="Segunda-derivada"><a class="docs-heading-anchor" href="#Segunda-derivada">Segunda derivada</a><a id="Segunda-derivada-1"></a><a class="docs-heading-anchor-permalink" href="#Segunda-derivada" title="Permalink"></a></h3><p>Da mesma forma, podemos definir matrizes de diferenciação para segundas derivadas. Por exemplo,</p><p class="math-container">\[\begin{bmatrix}f&#39;&#39;(x_0) \\[1mm] f&#39;&#39;(x_1) \\[1mm] f&#39;&#39;(x_2) \\[1mm] \vdots \\[1mm] f&#39;&#39;(x_{n-1}) \\[1mm] f&#39;&#39;(x_n)\end{bmatrix}\approx\frac{1}{h^2}\begin{bmatrix}2 &amp; -5 &amp; 4      &amp; -1     &amp;        &amp;     \\[1mm]1 &amp; -2 &amp; 1      &amp;        &amp;        &amp;    \\[1mm]&amp; 1  &amp; -2     &amp; 1      &amp;        &amp;    \\[1mm]&amp;    &amp; \ddots &amp; \ddots &amp; \ddots &amp;    \\[1mm]&amp;        &amp;        &amp; 1      &amp; -2 &amp; 1 \\[1mm]&amp;        &amp;     -1  &amp; 4      &amp; -5 &amp; 2\end{bmatrix}\begin{bmatrix}f(x_0) \\[1mm] f(x_1) \\[1mm] f(x_2) \\[1mm] \vdots \\[1mm] f(x_{n-1}) \\[1mm] f(x_n)\end{bmatrix} = \mathbf{D}_{xx} \mathbf{f}.\]</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    diff(n, xspan)

Construa matrizes de diferenciação de 2ª ordem, usando `n` nós únicos no intervalo
`xspan`. Retorna um vetor de nós e as matrizes para as primeiras
e segundas derivadas.
&quot;&quot;&quot;
function diffmat(n, xspan)
		a,b = xspan
    h = (b-a)/n
    x = [ a + i*h for i in 0:n ]   # nós

    
		# Define a maior parte de Dₓ por suas diagonais.
		dp = fill(0.5/h,n)        # superdiagonal
		dm = fill(-0.5/h,n)       # subdiagonal
		Dₓ = diagm(-1=&gt;dm,1=&gt;dp)
		
		# Corrigir as primeiras e últimas linhas.
		Dₓ[1,1:3] = [-1.5,2,-0.5]/h
		Dₓ[n+1,n-1:n+1] = [0.5,-2,1.5]/h
		
		# Define a maior parte de Dₓₓ por suas diagonais.
		d0 =  fill(-2/h^2,n+1)    # diagonal principal
		dp =  ones(n)/h^2         # super- e subdiagonal
		Dₓₓ = diagm(-1=&gt;dp,0=&gt;d0,1=&gt;dp)
		
		# Corrigir as primeiras e últimas linhas.
		Dₓₓ[1,1:4] = [2,-5,4,-1]/h^2
		Dₓₓ[n+1,n-2:n+1] = [-1,4,-5,2]/h^2
		
		return x,Dₓ,Dₓₓ
		
end
</code></pre><p>Usando essas matrizes para resolver o problema com condições de contorno </p><p class="math-container">\[T(-1)=100,T(1)=0\]</p><pre><code class="language-julia hljs">n=100
 x,dx,dxx=diffmat(n,[-1,1])
 dxx[1,:].=0 
 dxx[end,:].=0
  dxx[1,1]=1 
  dxx[end,end]=1
  b=zeros(n+1)
  b[1]=100
  xdf=dxx\b</code></pre><h2 id="A-equação-de-**difusão**"><a class="docs-heading-anchor" href="#A-equação-de-**difusão**">A equação de <strong>difusão</strong></a><a id="A-equação-de-**difusão**-1"></a><a class="docs-heading-anchor-permalink" href="#A-equação-de-**difusão**" title="Permalink"></a></h2><p>A <strong>equação de difusão</strong> em uma dimensão é</p><p class="math-container">\[u_t = k u_{xx},\]</p><p>onde  <span>$k$</span> é o <em>coeficiente de difusão</em>. A equação do calor é a equação diferencial típica para a classe conhecida como <strong>EDPs parabólicas</strong>. Um processo difusivo é aquele em que a velocidade é proporcional ao gradiente da solução. Assim, mudanças rápidas na solução se achatam rapidamente.</p><p>Agora vamos resolver a equação de difusão em<span>$[-1,1]$</span> usando diferenças finitas para aproximar a derivada em <span>$x$</span>. As condições de contorno são <span>$u(-1,t)=0,u(1,t)=2$</span> e a condição inicial é  <span>$1 + \sin(πx/2) + 3(1-x^2)e^{-4x^2}$</span>. </p><pre><code class="language-julia hljs">using DifferentialEquations,LaTeXStrings,Plots

n=100
 x,dx,dxx=diffmat(n,[-1,1])
 
f = (u,p,t) -&gt; p[1]*[p[2];u[2:end-1];p[3]]
init = x -&gt; 1 + sin(π*x/2) + 3*(1-x^2)*exp(-4x^2);
u0=init.(x)
tspan=(0,0.75)
ivp = ODEProblem(f,u0,tspan,[dxx,0,2])
sol = solve(ivp,Tsit5());

plt = plot(xlabel=L&quot;x&quot;,ylabel=L&quot;u(x,t)&quot;,legend=:topleft,
          title=&quot;Solução da equação de calor&quot;)
for t in 0:0.1:0.7
    plot!(x[1:end-1],sol(t)[1:end-1],label=&quot;t=$t&quot;)
end
plt

anim = @animate for t in range(0,0.75,length=201) 
    plot(x[1:end-1],sol(t)[1:end-1],label=&quot;t=$t&quot;,
        xaxis=(L&quot;x&quot;), yaxis=(L&quot;u(x,t)&quot;,(0,4.2)), 
        title=&quot;Difusão&quot;,leg=:topleft,dpi=100)
end
mp4(anim,&quot;calor.mp4&quot;,fps=30)</code></pre><p><a href="../boundaries-heat.mp4">boundaries-heat.mp4</a></p><p>Aqui as estratégias de passo no tempo apresentadas anteriormente também poderiam ser utilizadas.</p><h2 id="Exercício"><a class="docs-heading-anchor" href="#Exercício">Exercício</a><a id="Exercício-1"></a><a class="docs-heading-anchor-permalink" href="#Exercício" title="Permalink"></a></h2><p>1 - Usando o BEM resolva o mesmo problema de <strong>difusão</strong> e compare com o MDF. Como o termo transiente aparece na equação integral? O que precisa ser feito para descrever <span>$u_t$</span> em termos das matrizes do BEM?</p><h2 id="Equação-da-onda"><a class="docs-heading-anchor" href="#Equação-da-onda">Equação da onda</a><a id="Equação-da-onda-1"></a><a class="docs-heading-anchor-permalink" href="#Equação-da-onda" title="Permalink"></a></h2><p>A equação da onda é dada por     <span>$u_{tt} - c^2 u_{xx} = 0.$</span> Usaremos <span>$x \in [0,1]$</span> e <span>$t&gt; 0$</span> como o domínio. </p><p>Para reduzir a ordem desse problema podemos definir: </p><p><span>$u_t = y, \\  y_t = c^2 u_{xx}.$</span></p><p>o que resultaria no sistema matricial:</p><p><span>$\begin{bmatrix}    \mathbf{u}&#39;(t) \\[2mm]  \mathbf{y}&#39;(t)  \end{bmatrix}  =  \begin{bmatrix}    \boldsymbol{0} &amp; I \\[2mm] c^2 \mathbf{D}_{xx} &amp; \boldsymbol{0}  \end{bmatrix}  \begin{bmatrix}    \mathbf{u}(t) \\[2mm] \mathbf{y}(t)  \end{bmatrix}.$</span></p><p>Usaremos velocidade <span>$c=2$</span>, as condições de Dirichlet <span>$u(0,t) = u(1,t) = 0$</span> e duas condições iniciais: </p><p class="math-container">\[u(x,0) = e^{-100(x+0.5)^2
}, \qquad 0 \le x \le 1,  \\u_t(x,0) = -u(x,0), \qquad 0 \le x \le 1.\]</p><pre><code class="language-julia hljs">n=100
 x,dx,dxx=diffmat(n,[-1,1])

f = (u,p,t) -&gt; p[1]*[p[2];u[2:p[4]-1];p[3];u[p[4]+1:end]]
init = x -&gt; exp(-100*(x+0.5)^2);
u0=[init.(x); -init.(x)]
tspan=(0,2)
c=2
ivp = ODEProblem(f,u0,tspan,[[zeros(n+1,n+1) I;c^2*dxx zeros(n+1,n+1)],0,0,n+1])
sol = solve(ivp,Tsit5());

plt = plot(xlabel=L&quot;x&quot;,ylabel=L&quot;u(x,t)&quot;,legend=:topleft,
          title=&quot;Solução da equação da onda&quot;)
for t in 0:0.2:2
    plot!(x[1:n-1],sol(t)[1:n-1],label=&quot;t=$t&quot;)
end
plt

anim = @animate for t in range(0,2,length=201) 
    plot(x[1:n-1],sol(t)[1:n-1],label=&quot;t=$t&quot;,
        xaxis=(L&quot;x&quot;), yaxis=(L&quot;u(x,t)&quot;,(-1.1,1.1)), 
        title=&quot;onda&quot;,leg=:topleft,dpi=100)
end
mp4(anim,&quot;onda.mp4&quot;,fps=30)</code></pre><p><a href="../onda.mp4">onda.mp4</a></p><h2 id="Desafio"><a class="docs-heading-anchor" href="#Desafio">Desafio</a><a id="Desafio-1"></a><a class="docs-heading-anchor-permalink" href="#Desafio" title="Permalink"></a></h2><p>Usando o BEM resolva o mesmo problema e compare com o MDF. </p><pre><code class="language-julia hljs">x0=0
xf=1
l=xf-x0
H=[0.5 -.5
-.5 .5]
G=-[0 l/2
-l/2 0]
#T=0.5*(x1[1]+x1[2]).+(xs.-x0)/2*x1[3].+(xs.-xf)/2*x1[4]

Hi=[0.5 0.5]
Gi=[(xs.-x0)/2 (xs.-xf)/2]

Ht=[H zeros(2,2);Hi -I]
Gt=[G ;Gi ]
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../02-interpola/">« Interpolação</a><a class="docs-footer-nextpage" href="../10-exemplos/">Exemplos »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 3 February 2025 11:13">Monday 3 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
